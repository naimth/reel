<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover" />
  <title>Portrait Flyby Reel â€” Mobile v1.4 FIXED</title>
  
  <!-- PWA Meta Tags -->
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="apple-mobile-web-app-title" content="Reel Maker">
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="theme-color" content="#0b0b0e">
  
  <!-- Touch Icons -->
  <link rel="apple-touch-icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 512 512'><rect fill='%230b0b0e' width='512' height='512'/><path fill='%238ad2ff' d='M256 128l128 96-128 96-128-96z'/><circle fill='%23ffc98a' cx='256' cy='320' r='64'/></svg>">
  
  <!-- Prevent text size adjustment on orientation change -->
  <meta name="format-detection" content="telephone=no">
  <style>
	:root{ --bg:#0b0b0e; --panel:#14141a; --muted:#8b8b99; --accent:#8ad2ff; --accent2:#ffc98a; --good:#67ffa7; --warn:#ffd166; --bad:#ff6b6b }
	html,body{height:100%; margin:0; background:var(--bg); color:#eaeaf2; font-family:system-ui,-apple-system,Segoe UI,Roboto,Inter,Arial,sans-serif}
	#app{display:grid; grid-template-columns:320px 1fr; grid-template-rows:auto 1fr auto; height:100%}
	header{grid-column:1 / -1; padding:12px 16px; display:flex; align-items:center; gap:12px; border-bottom:1px solid #1f1f27}
	header h1{font-size:16px; font-weight:600; margin:0}
	header .hint{color:var(--muted); font-size:12px}
	#left{grid-row:2; grid-column:1; overflow:auto; border-right:1px solid #1f1f27}
	#right{grid-row:2; grid-column:2; position:relative; overflow:hidden; display:grid; place-items:center; background:#0a0a0a; user-select:none}
	#controls{padding:12px; position:sticky; top:0}
	.card{background:var(--panel); border:1px solid #23232d; border-radius:14px; padding:12px; margin-bottom:12px; box-shadow:0 8px 24px rgba(0,0,0,.25)}
	.card h3{margin:.25rem 0 .5rem; font-size:13px; letter-spacing:.02em; color:#d7d7e7}
	label{display:flex; align-items:center; justify-content:space-between; gap:8px; font-size:12px; color:#c9c9d8; margin:8px 0}
	input[type=range]{width:160px}
	input[type=number], select{background:#0f0f15; color:#fff; border:1px solid #2a2a35; border-radius:8px; padding:6px 8px; width:96px}
	input[type=file]{width:100%}
	button{appearance:none; background:#1c1c26; border:1px solid #2a2a35; color:#fff; padding:10px 12px; border-radius:12px; font-weight:600; cursor:pointer}
	button.primary{background:linear-gradient(135deg,#1c2730,#1a1a26); border-color:#2b3b49}
	button.good{background:linear-gradient(135deg,#103121,#0e261a); border-color:#2b6145}
	button.warn{background:linear-gradient(135deg,#312910,#261e0e); border-color:#614f2b}
	button:disabled{opacity:.5; cursor:not-allowed}
	.row{display:flex; align-items:center; justify-content:space-between; gap:8px}
	.stack{display:flex; flex-direction:column; gap:6px}
	.small{font-size:11px; color:var(--muted)}
	.pill{font-size:11px; padding:4px 8px; border-radius:999px; background:#101018; border:1px solid #252535; display:inline-flex; align-items:center; gap:6px}
	canvas{display:block; touch-action:none; cursor:grab; user-select:none; pointer-events:auto;}
@media (max-width: 768px) {
  canvas { width: 100% !important; height: 100% !important; touch-action: none; }
}
	#overlay{position:absolute; inset:0; display:flex; align-items:center; justify-content:center; pointer-events:none}
	#legend{position:absolute; bottom:10px; left:10px; background:rgba(0,0,0,.45); padding:8px 10px; border-radius:10px; font-size:11px}
	#recDot{width:10px; height:10px; border-radius:50%; background:#f33; box-shadow:0 0 0 0 rgba(255,80,80,.7); animation:pulse 1.4s infinite}
	@keyframes pulse{0%{box-shadow:0 0 0 0 rgba(255,80,80,.7)}70%{box-shadow:0 0 0 12px rgba(255,80,80,0)}100%{box-shadow:0 0 0 0 rgba(255,80,80,0)}}
	.diag{display:grid; grid-template-columns:1fr auto; gap:6px; font-size:12px}
	.ok{color:#9cffbf} .bad{color:#ff9999}
/* Collapsible cards */
.card.collapsible > .card-body { display: none; }
.card.collapsible.open > .card-body { display: block; }
.card .card-header { display:flex; align-items:center; justify-content:space-between; cursor:pointer; padding:4px 0; }
.card .chev { font-size: 12px; opacity:.7; margin-left: 8px; }

/* Mobile-specific styles */
@media (max-width: 768px) {
  #app { 
    grid-template-columns: 1fr; 
    grid-template-rows: auto auto 1fr; 
    height: 100vh;
  }
  #left { 
    grid-row: 2;
    grid-column: 1;
    border-right: none; 
    border-bottom: 1px solid #1f1f27; 
    max-height: none;
    overflow: visible;
    position: relative;
    z-index: 10;
  }
  #left.mobile-hidden {
    display: none;
  }
  #right {
    grid-row: 3;
    grid-column: 1;
    height: 100%;
    min-height: 60vh;
  }
  #controls {
    position: relative;
    top: 0;
    padding: 8px;
    max-height: 40vh;
    overflow-y: auto;
  }
  header { font-size: 14px; padding: 8px 12px; }
  header h1 { font-size: 14px; }
  .card { margin-bottom: 8px; padding: 10px; }
  button { padding: 8px 10px; font-size: 13px; }
  label { font-size: 11px; }
  input[type=range] { width: 120px; }
  input[type=number], select { width: 80px; font-size: 12px; }
  
  /* All cards start collapsed on mobile */
  .card.collapsible {
    margin-bottom: 4px;
  }
  .card.collapsible > .card-body {
    display: none;
  }
  .card.collapsible.open > .card-body {
    display: block;
  }
}

/* Toggle controls button (mobile only) */
#toggleControlsBtn {
  display: none;
  position: fixed;
  top: 60px;
  left: 10px;
  z-index: 1001;
  background: var(--accent);
  color: #000;
  border: none;
  padding: 8px 12px;
  border-radius: 8px;
  font-size: 12px;
  font-weight: 600;
  box-shadow: 0 2px 8px rgba(0,0,0,0.3);
}
@media (max-width: 768px) {
  #toggleControlsBtn { display: block; }
}

/* Full-screen mode for recording */
body.fullscreen-mode { overflow: hidden; }
body.fullscreen-mode #app { display: none; }
body.fullscreen-mode #right { display: block !important; position: fixed; inset: 0; z-index: 9999; }
body.fullscreen-mode canvas { width: 100vw !important; height: 100vh !important; }

/* Screen Record Mode overlay */
#screenRecordOverlay {
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,0.95);
  z-index: 10000;
  display: none;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  color: white;
  font-family: system-ui, -apple-system, sans-serif;
  text-align: center;
  padding: 20px;
}
#screenRecordOverlay.active { display: flex; }

/* Countdown animation */
#countdown {
  font-size: 120px;
  font-weight: 700;
  color: var(--accent);
  margin: 40px 0;
  animation: countdownPulse 1s ease-in-out;
}
@keyframes countdownPulse {
  0%, 100% { transform: scale(1); opacity: 1; }
  50% { transform: scale(1.2); opacity: 0.8; }
}

/* Recording indicator */
#recordingIndicator {
  position: fixed;
  top: 20px;
  right: 20px;
  background: rgba(255, 51, 51, 0.9);
  color: white;
  padding: 8px 16px;
  border-radius: 20px;
  font-size: 14px;
  font-weight: 600;
  display: none;
  align-items: center;
  gap: 8px;
  z-index: 10001;
  box-shadow: 0 4px 12px rgba(0,0,0,0.3);
}
#recordingIndicator.active { display: flex; }
#recordingIndicator::before {
  content: '';
  width: 10px;
  height: 10px;
  background: white;
  border-radius: 50%;
  animation: blink 1.5s infinite;
}
@keyframes blink {
  0%, 100% { opacity: 1; }
  50% { opacity: 0.3; }
}

/* Tap to exit hint */
#tapToExit {
  position: fixed;
  bottom: 40px;
  left: 50%;
  transform: translateX(-50%);
  background: rgba(0,0,0,0.7);
  color: white;
  padding: 12px 24px;
  border-radius: 24px;
  font-size: 16px;
  display: none;
  z-index: 10001;
  animation: fadeInUp 0.5s ease-out;
}
#tapToExit.active { display: block; }
@keyframes fadeInUp {
  from { opacity: 0; transform: translateX(-50%) translateY(20px); }
  to { opacity: 1; transform: translateX(-50%) translateY(0); }
}

/* Mobile record button removed - using direct recording */

/* Touch feedback */
.touch-feedback {
  position: fixed;
  width: 60px;
  height: 60px;
  border: 2px solid rgba(138, 210, 255, 0.6);
  border-radius: 50%;
  pointer-events: none;
  z-index: 9998;
  animation: touchRipple 0.6s ease-out;
}
@keyframes touchRipple {
  from { transform: scale(0.5); opacity: 1; }
  to { transform: scale(2); opacity: 0; }
}

/* Instructions overlay */
#instructionsOverlay {
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,0.9);
  z-index: 10002;
  display: none;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  padding: 30px;
  color: white;
  overflow-y: auto;
}
#instructionsOverlay.active { display: flex; }
#instructionsOverlay h2 { color: var(--accent); margin-bottom: 20px; }
#instructionsOverlay ol { text-align: left; line-height: 1.8; max-width: 500px; }
#instructionsOverlay li { margin-bottom: 12px; }
#instructionsOverlay button { margin-top: 30px; padding: 14px 32px; font-size: 16px; }


  </style>
<style>#gl{touch-action:manipulation;}</style></head>
<body>
  <!-- Toggle Controls Button (Mobile) -->
  <button id="toggleControlsBtn">â˜° Controls</button>

  <!-- Screen Record Mode Overlay -->
  <div id="screenRecordOverlay">
    <div id="overlayContent">
      <h2 style="font-size: 24px; margin-bottom: 20px;">Get Ready!</h2>
      <p style="font-size: 16px; margin-bottom: 10px;">Starting iOS Screen Recording...</p>
      <p style="font-size: 14px; color: #999; margin-bottom: 40px;">Swipe down and tap the record button in Control Center</p>
      <div id="countdown">3</div>
      <p style="font-size: 14px; color: #999;">Preview will start automatically</p>
    </div>
  </div>

  <!-- Recording Indicator -->
  <div id="recordingIndicator">
    <span>Screen Recording</span>
  </div>

  <!-- Tap to Exit Hint -->
  <div id="tapToExit">Tap anywhere to exit</div>

  <!-- Mobile Record Button removed - use direct recording instead -->

  <!-- Instructions Overlay -->
  <div id="instructionsOverlay">
    <div style="max-width: 600px;">
      <h2>ðŸ“± iPhone Recording Options</h2>
      
      <div style="background: rgba(138, 210, 255, 0.1); padding: 15px; border-radius: 10px; margin-bottom: 20px;">
        <h3 style="margin-top: 0; color: var(--accent);">âœ¨ Good News!</h3>
        <p style="margin-bottom: 10px;">Your device may support <strong>direct video recording</strong>! Try clicking the regular "Record" button first. If it works and downloads a video, you don't need Screen Record Mode!</p>
        <p style="font-size: 12px; color: #999; margin: 0;">Direct recording = better quality + easier workflow</p>
      </div>

      <h3>Option 1: Direct Recording (Try This First!)</h3>
      <ol>
        <li><strong>Create Your Path:</strong><br>Position camera and add checkpoints</li>
        <li><strong>Hit "Record":</strong><br>Click the regular Record button in controls</li>
        <li><strong>Let It Play:</strong><br>Preview plays through your path</li>
        <li><strong>Download:</strong><br>Video saves automatically to your device!</li>
      </ol>

      <h3 style="margin-top: 30px;">Option 2: iOS Screen Recording (Backup)</h3>
      <p>If direct recording doesn't work, use this method:</p>
      <ol>
        <li><strong>Setup Screen Recording:</strong><br>Settings â†’ Control Center â†’ Add "Screen Recording"</li>
        <li><strong>Create Your Path:</strong><br>Position camera and add checkpoints</li>
        <li><strong>Tap Red ðŸŽ¥ Button:</strong><br>The floating button at bottom-right</li>
        <li><strong>Start iOS Recording:</strong><br>Swipe down, tap record button</li>
        <li><strong>Wait for Countdown:</strong><br>3-2-1 and preview starts</li>
        <li><strong>Stop Recording:</strong><br>Tap red bar at top â†’ Stop</li>
        <li><strong>Trim & Share:</strong><br>Photos app â†’ trim â†’ upload to Instagram!</li>
      </ol>
      <button id="closeInstructions" class="primary">Got It!</button>
    </div>
  </div>

  <div id="app">
	<header>
	  <h1>Portrait Flyby Reel</h1>
	  <span class="pill"><span style="width:6px;height:6px;border-radius:50%;background:var(--accent);"></span> v1.4</span>
	  <span class="hint">Touch viewport to move camera</span>
	  <button id="showMobileHelp" style="margin-left:auto;padding:6px 12px;font-size:12px;background:var(--accent);color:#000;border:none;border-radius:8px;font-weight:600;">Help</button>
	</header>

	<aside id="left">
	  <div id="controls">
<div class="card" id="quickControlsCard">
  <h3>Quick Controls â€” Path & Record</h3>
  <div class="stack">
    <!-- Mini Path Builder -->
    <div class="row" style="gap:8px;flex-wrap:wrap">
      <button id="qcPathRecord" class="primary">Start Building Path</button>
      <button id="qcSpeedRamp" style="display:none; background:linear-gradient(135deg,#2a1a30,#1a1a26); border-color:#4a2b5a;">Speedramp Start</button>
      <button id="qcPathFinish" class="good" disabled>Finish Path</button>
      <button id="qcPathClear" class="warn" disabled>Clear Path</button>
    </div>
    <div class="small" style="text-align:right">Checkpoints: <span id="qcCheckpointCount">0</span> <span id="qcSpeedRampIndicator" style="display:none; color:var(--accent2);">ðŸŽ¬</span></div>

    <!-- Image Deck -->
    <div class="row" style="gap:8px;flex-wrap:wrap;margin-top:6px">
      <button id="qcPrevImg">â—€ Prev</button>
      <button id="qcNextImg" class="primary">Next â–¶</button>
    </div>

    <!-- Record Controls -->
    <div class="row" style="gap:8px;flex-wrap:wrap">
      <button id="qcPreview" class="primary">Preview Path</button>
      <button id="qcRecord" class="good">Record (WebM)</button>
      <button id="qcStop" class="warn">Stop</button>
    </div>
  </div>
</div>

	<div class="card">
	  <h3>1) Image(s)</h3>
	  <div class="stack">
		<input id="file" type="file" accept="image/*" multiple />
		<div class="small">Large images are supported; the app autoâ€‘mipmaps and caps texture size for performance.</div>
		<label>Max texture (px)
		  <span>
			<input type="checkbox" id="maxTexAuto" checked> Auto
			<input type="number" id="maxTexN" min="2048" max="16384" step="256" value="8192" disabled>
		  </span>
		</label>
		<div class="small">Auto uses your GPU limit. Uncheck to set a manual cap.</div>
	  </div>
	</div>

	<div class="card">
	  <h3>2) Canvas Preset</h3>
	  <div class="row">
		<label>Output <select id="preset">
		  <option value="reel">Instagram Reel â€” 1080Ã—1920 @30fps</option>
		  <option value="post">Instagram Portrait Post â€” 1080Ã—1350 @30fps</option>
		  <option value="story">Story â€” 1080Ã—1920 @30fps</option>
		  <option value="custom">Customâ€¦</option>
		</select></label>
	  </div>
	  <div id="customDims" class="stack" style="display:none">
		<div class="row"><label>Width <input type="number" id="w" min="320" value="1080"></label></div>
		<div class="row"><label>Height <input type="number" id="h" min="320" value="1920"></label></div>
		<div class="row"><label>FPS <input type="number" id="fps" min="24" max="60" value="30"></label></div>
	  </div>
	</div>

	<div class="card">
	  <h3>3) Flight Path</h3>
	  <div class="stack">
		<select id="path">
		  <option value="customPath" disabled>Custom Cinematic Path</option>
		  <option value="orbit360">Full Orbit (encircle)</option>
		  <option value="heliOrbit">Helical Orbit (encircle + elevation)</option>
		  <option value="lissajous">Lissajous Encircle</option>
		  <option value="orbitArc">Orbit Arc (cinematic)</option>
		  <option value="dollyReveal">Dollyâ€‘In Reveal</option>
		  <option value="figure8">Figureâ€‘Eight Sweep</option>
		  <option value="sCurve">Sâ€‘Curve Strafe</option>
		  <option value="spiralInOut">Spiral In/Out</option>
		</select>
		<label>Duration (s)
		  <span>
			<input type="range" id="duration" min="2" max="60" step="1" value="30">
			<input type="number" id="durationN" min="2" max="60" step="1" value="30">
		  </span>
		</label>
		<label>Ease Curve
		  <select id="ease">
			<option value="easeInOut">Ease Inâ€‘Out (smooth)</option>
			<option value="constant">Constant speed</option>
			<option value="easeIn">Ease In</option>
			<option value="easeOut">Ease Out</option>
		  </select>
		</label>
		<label>Min Distance
		  <span>
			<input type="range" id="minDist" min="0.01" max="6" step="0.1" value="0.01">
			<input type="number" id="minDistN" min="0.01" max="6" step="0.1" value="0.01">
		  </span>
		</label>
		<label>Max Distance
		  <span>
			<input type="range" id="maxDist" min="1" max="50" step="0.1" value="50">
			<input type="number" id="maxDistN" min="1" max="50" step="0.1" value="50">
		  </span>
		</label>
		<label>Yaw Amplitude (Â°)
		  <span>
			<input type="range" id="yawAmp" min="0" max="70" step="1" value="35">
			<input type="number" id="yawAmpN" min="0" max="70" step="1" value="35">
		  </span>
		</label>
		<label>Pitch Amplitude (Â°)
		  <span>
			<input type="range" id="pitchAmp" min="0" max="40" step="1" value="18">
			<input type="number" id="pitchAmpN" min="0" max="40" step="1" value="18">
		  </span>
		</label>
		<label>FOV Zoom (Â°)
		  <span>
			<input type="range" id="fovMin" min="5" max="120" step="1" value="24">
			<input type="number" id="fovMinN" min="5" max="120" step="1" value="24">
		  </span>
		</label>
		<label>â†³ to
		  <span>
			<input type="range" id="fovMax" min="5" max="120" step="1" value="45">
			<input type="number" id="fovMaxN" min="5" max="120" step="1" value="45">
		  </span>
		</label>
	  </div>
	</div>
	
	<div class="card">
	  <h3>Cinematic Path Builder</h3>
	  <div class="stack">
		<div class="small">Create a custom camera path by adding checkpoints. Manually position the camera, then click "Add Checkpoint".</div>
		<div class="small" style="margin-top:8px; padding:8px; background:rgba(138,210,255,0.1); border-radius:6px;">
		  <strong>How it works:</strong><br>
		  â€¢ Equal time per segment (base behavior)<br>
		  â€¢ Distance scaling: slower when close, faster when far<br>
		  â€¢ Use Speedramp buttons for dramatic slowâ†’fastâ†’slow zones<br>
		  â€¢ Butter Smoothing adds gimbal-like polish
		</div>
		<div class="row" style="gap:8px; flex-wrap:wrap">
			<button id="pathRecordBtn" class="primary">Start Building Path</button>
			<button id="speedRampBtn" style="display:none; background:linear-gradient(135deg,#2a1a30,#1a1a26); border-color:#4a2b5a;">Speedramp Start</button>
			<button id="pathFinishBtn" class="good" disabled>Finish Path</button>
			<button id="pathClearBtn" class="warn" disabled>Clear Path</button>
		</div>
		<div class="small" style="text-align: right;">Checkpoints: <span id="checkpointCountEl">0</span> <span id="speedRampIndicator" style="display:none; color:var(--accent2);">ðŸŽ¬ Recording speedramp...</span></div>
		<label>Path Smoothing
		  <span>
			<input type="range" id="pathTension" min="0" max="1" step="0.05" value="1">
			<input type="number" id="pathTensionN" min="0" max="1" step="0.05" value="1">
		  </span>
		</label>
		<div class="small" style="margin-top:-4px">Controls path tightness at waypoints. 0.5 is default.</div>
		
		<!-- NEW: Checkpoint Speed Ramping Controls -->
		<hr style="border-color:#2a2a35; margin: 8px 0;">
		<label class="row">
		  <span><input type="checkbox" id="rampCheckpoints"> Ease at Checkpoints</span>
		</label>

		<label>Image Fade (ms)
		  <span>
			<input type="number" id="deckFadeMs" min="0" step="50" value="600">
		  </span>
		</label>

		<div class="small" style="margin-top:-4px">Smoothly eases into/out of checkpoints for all motions.</div>
		<label>Ease Strength<span>
			<input type="range" id="rampPower" min="1.0" max="200" step="0.5" value="80">
			<input type="number" id="rampPowerN" min="1.0" max="200" step="0.5" value="80">
        </span>
      </label>
      <div class="small" style="margin-top:-4px">Higher = ultra-smooth corners. Try 80-150 for gimbal-smooth motion. 200 = maximum butter.</div>

      <!-- NEW: Butter Smoothing (critically-damped pose filter) -->
      <hr style="border-color:#2a2a35; margin: 8px 0;">
      <label class="row">
        <span><input type="checkbox" id="butterSmooth" checked> Butter Smoothing</span>
        <span class="small">Temporal pose filter</span>
      </label>
      <label>Smoothing Time (ms)
        <span>
          <input type="range" id="butterMs" min="0" max="2000" step="10" value="800">
          <input type="number" id="butterMsN" min="0" max="2000" step="10" value="800">
        </span>
      </label>
      <div class="small" style="margin-top:-4px">Try 800-1200ms for gimbal-smooth motion. 1500-2000ms for ultra-butter smoothness.</div>
			
			<!-- Extra Smoothing Pass -->
			<label class="row">
			  <span><input type="checkbox" id="superSmooth" checked> Triple-Pass Smoothing</span>
			  <span class="small">Maximum butter</span>
			</label>
			<div class="small" style="margin-top:-4px">Applies additional smoothing passes for ultra-professional gimbal motion. May add slight lag.</div>
			
			<div class="small" style="margin-top:4px">When finished, the path will be available in the dropdown above.</div>
	  </div>
	</div>

	<div class="card">
	  <h3>Manual Controls</h3>
	  <div class="stack">
		<label class="row"><span><input type="checkbox" id="lockRoll" checked> Lock roll (0Â°)</span><span class="small">Droneâ€‘like, no bank</span></label>
		<label class="row"><span><input type="checkbox" id="invertPitch" checked> Invert vertical drag</span><span class="small">Drag up â†’ move down</span></label>
		<label class="row"><span><input type="checkbox" id="cylMode"> Cylindrical manual control</span><span class="small">Left/Right=Ï†, Up/Down=Z, Wheel=R. Always looks at focus.</span></label>
		<label class="row"><span><input type="checkbox" id="stickyOrbit" checked> Sticky orbit (toggle via click)</span><span class="small">Quick tap to latch/unlatch rotate</span></label>
		<label>Zoom step (%)
		  <span>
			<input type="range" id="zoomStep" min="1" max="50" step="1" value="5">
			<input type="number" id="zoomStepN" min="1" max="50" step="1" value="5">
		  </span>
		</label>
		 <hr style="border-color:#2a2a35; margin: 8px 0;">
		<label class="row">
		  <span><input type="checkbox" id="enableSpeedScale" checked> Enable Speed Scaling</span>
		  <span class="small">Adjusts speed with distance</span>
		</label>
		<label>Distance Speed Power<span>
			<input type="range" id="speedScalePower" min="0.02" max="1.0" step="0.01" value="1.0">
			<input type="number" id="speedScalePowerN" min="0.02" max="1.0" step="0.01" value="1.0">
		  </span>
		</label>
	  </div>
	</div>

	<div class="card">
	  <h3>Focus Point</h3>
	  <div class="stack">
		<div class="small">Use <b>Shift + Click</b> on the image to pick a focus point. Camera always tracks this point in cylindrical mode.</div>
		<label>Focus X (plane)
		  <span>
			<input type="range" id="focusX" min="-0.5" max="0.5" step="0.001" value="0">
			<input type="number" id="focusXN" step="0.001" value="0">
		  </span>
		</label>
		<label>Focus Y (plane)
		  <span>
			<input type="range" id="focusY" min="-0.75" max="0.75" step="0.001" value="0">
			<input type="number" id="focusYN" step="0.001" value="0">
		  </span>
		</label>
		<div class="row"><button id="resetFocus">Center Focus</button><button id="perpendicularBtn">Perpendicular</button></div>
		<label class="row"><span><input type="checkbox" id="panLocksFocus" checked> Pan updates focus (lock pivot)</span><span class="small">For cylindrical, enable this to reframe</span></label>
	  </div>
	</div>

	<div class="card">
	  <h3>Look & Light</h3>
	  <label>Ambient Light
		<span>
		  <input type="range" id="amb" min="0" max="2" step="0.01" value="1.0">
		  <input type="number" id="ambN" min="0" max="2" step="0.01" value="1.0">
		</span>
	  </label>
	  <label>Key Light Intensity
		<span>
		  <input type="range" id="key" min="0" max="1.0" step="0.01" value="1.0">
		  <input type="number" id="keyN" min="0" max="1.0" step="0.01" value="1.0">
		</span>
	  </label>
	  <label>Back Light Intensity
		<span>
		  <input type="range" id="backKey" min="0" max="5" step="0.01" value="1.0">
		  <input type="number" id="backKeyN" min="0" max="5" step="0.01" value="1.0">
		</span>
	  </label>
	  <label>Key Light Angle (Â°)
		<span>
		  <input type="range" id="keyAng" min="-90" max="90" step="1" value="45">
		  <input type="number" id="keyAngN" min="-90" max="90" step="1" value="45">
		</span>
	  </label>
      <label>Key Light Azimuth (Â°)
        <span>
          <input type="range" id="keyAz" min="-180" max="180" step="1" value="45">
          <input type="number" id="keyAzN" min="-180" max="180" step="1" value="45">
        </span>
      </label>
	  <label>Reflectivity (metalness)
		<span>
		  <input type="range" id="metal" min="0" max="1" step="0.01" value="0.2">
		  <input type="number" id="metalN" min="0" max="1" step="0.01" value="0.2">
		</span>
	  </label>
	  <label>Microâ€‘roughness
		<span>
		  <input type="range" id="rough" min="0" max="1" step="0.01" value="0.3">
		  <input type="number" id="roughN" min="0" max="1" step="0.01" value="0.3">
		</span>
	  </label>
	  <label>Specular Luminance
		<span>
		  <input type="range" id="spec" min="0" max="1" step="0.01" value="0.5">
		  <input type="number" id="specN" min="0" max="1" step="0.01" value="0.5">
		</span>
	  </label>
	  <label>Photo Emissive (selfâ€‘light)
		<span>
		  <input type="range" id="photoEmis" min="0" max="2" step="0.01" value="1.0">
		  <input type="number" id="photoEmisN" min="0" max="2" step="0.01" value="1.0">
		</span>
	  </label>
	  <label>Back/Sides Emissive
		<span>
		  <input type="range" id="backEmis" min="0" max="0.2" step="0.005" value="0.025">
		  <input type="number" id="backEmisN" min="0" max="0.2" step="0.005" value="0.025">
		</span>
	  </label>
	  <label>Exposure
		<span>
		  <input type="range" id="exposure" min="0.5" max="2.5" step="0.05" value="1.0">
		  <input type="number" id="exposureN" min="0.5" max="2.5" step="0.05" value="1.0">
		</span>
	  </label>

	  <label>Tone Mapping
		<span>
		  <select id="toneMapSel">
			<option value="linear">Linear (neutral)</option>
			<option value="none">None</option>
			<option value="aces">ACES (cinematic)</option>
			<option value="reinhard">Reinhard</option>
		  </select>
		</span>
	  </label>

	  <label>Thickness (depth)
		<span>
		  <input type="range" id="thick" min="0" max="0.1" step="0.001" value="0.025">
		  <input type="number" id="thickN" min="0" max="0.1" step="0.001" value="0.025">
		</span>
	  </label>
	  <label class="row"><span><input type="checkbox" id="showFrame" checked> Show frame outline</span><span class="small">Helps locate the canvas</span></label>
	  <div class="small">Background is true black. The photo can emit light for an HDRâ€‘like punch.</div>
	
	  <div class="row" style="margin-top:6px; justify-content:flex-start; gap:8px">
		<button id="resetPhotoMode" class="primary">Reset to Photo Mode</button>
		<span class="small" id="photoModeBadge" style="padding:4px 8px;border:1px solid #2a2a35;border-radius:999px;background:#101018">Photo Mode</span>
	  </div>

	</div>
	
	<div class="card">
	  <h3>Scenery</h3>
	  <div class="stack">
		<label class="row">
		  <span><input type="checkbox" id="showStars" checked> Show Starfield</span>
		  <span class="small">Adds a particle background</span>
		</label>
	  </div>
	</div>

	<div class="card">
	  <h3>Post-Processing</h3>
	  <div class="stack">
		<label class="row">
		  <span><input type="checkbox" id="enableBloom" checked> Enable Bloom</span>
		  <span class="small">Adds a glow effect</span>
		</label>
		<label>Threshold
		  <span>
			<input type="range" id="bloomThreshold" min="0" max="1" step="0.01" value="0.85">
			<input type="number" id="bloomThresholdN" min="0" max="1" step="0.01" value="0.85">
		  </span>
		</label>
		<label>Strength
		  <span>
			<input type="range" id="bloomStrength" min="0" max="3" step="0.01" value="0.35">
			<input type="number" id="bloomStrengthN" min="0" max="3" step="0.01" value="0.35">
		  </span>
		</label>
		<label>Radius
		  <span>
			<input type="range" id="bloomRadius" min="0" max="1" step="0.01" value="0.1">
			<input type="number" id="bloomRadiusN" min="0" max="1" step="0.01" value="0.1">
		  </span>
		</label>
		<hr style="border-color:#2a2a35; margin: 8px 0;">
		<h4>Advanced Lens Flare</h4>
		<label class="row">
		  <span><input type="checkbox" id="enableAdvFlare" checked> Enable Flare</span>
		  <span class="small">Shader-based effect</span>
		</label>
		<label>Starburst
		  <span>
			<input type="range" id="starburst" min="0" max="1" step="0.01" value="0.25">
			<input type="number" id="starburstN" min="0" max="1" step="0.01" value="0.25">
		  </span>
		</label>
		<label>Lens Dirt
		  <span>
			<input type="range" id="lensDirt" min="0" max="2" step="0.01" value="0.4">
			<input type="number" id="lensDirtN" min="0" max="2" step="0.01" value="0.4">
		  </span>
		</label>
		<hr style="border-color:#2a2a35; margin: 8px 0;">
		<h4>Volumetric God Rays</h4>
		<label class="row">
		  <span><input type="checkbox" id="enableGodRays" checked> Enable God Rays</span>
		</label>
		<label>Density
		  <span>
			<input type="range" id="grDensity" min="0" max="1" step="0.01" value="0.95">
			<input type="number" id="grDensityN" min="0" max="1" step="0.01" value="0.95">
		  </span>
		</label>
		<label>Decay
		  <span>
			<input type="range" id="grDecay" min="0.8" max="1" step="0.001" value="0.98">
			<input type="number" id="grDecayN" min="0.8" max="1" step="0.001" value="0.98">
		  </span>
		</label>
		<label>Weight
		  <span>
			<input type="range" id="grWeight" min="0" max="1" step="0.01" value="0.3">
			<input type="number" id="grWeightN" min="0" max="1" step="0.01" value="0.3">
		  </span>
		</label>
		<label>Exposure
		  <span>
			<input type="range" id="grExposure" min="0" max="1" step="0.01" value="0.5">
			<input type="number" id="grExposureN" min="0" max="1" step="0.01" value="0.5">
		  </span>
		</label>
	  </div>
	</div>

	<div class="card">
	  <h3>Record</h3>
	  <div class="row" style="gap:8px; flex-wrap:wrap">
		<button id="previewBtn" class="primary">Preview Path</button>
		<button id="recordBtn" class="good" disabled>Record (WebM)</button>
		<button id="stopBtn" class="warn" disabled>Stop</button>
	  </div>
	  <div id="pathProgressDisplay" class="small" style="display:none; margin-top: 8px;"></div>
	  <label>Export Scale (during recording)
		<span>
		  <input type="range" id="exportScale" min="1" max="4" step="0.25" value="1">
		  <input type="number" id="exportScaleN" min="1" max="4" step="0.25" value="1">
		</span>
	  </label>
	  <div class="small" style="margin-top:4px">Preview stays at the chosen preset size; recording temporarily renders the canvas at (scale Ã— width) Ã— (scale Ã— height).</div>
	  <div class="small" style="margin-top:8px">Recording uses the browser <code>MediaRecorder</code>. Chrome outputs WebM/VP9. Convert to MP4/H.264 for Instagram (e.g., QuickTime/HandBrake/FFmpeg). Duration controls total clip length.</div>
	</div>

	<div class="card">
	  <h3>Diagnostics (auto)</h3>
	  <div class="diag">
		<span>Three.js module</span><span id="dThree">â€”</span>
		<span>OrbitControls module</span><span id="dControls">â€”</span>
		<span>EffectComposer module</span><span id="dComposer">â€”</span>
		<span>UnrealBloomPass module</span><span id="dBloom">â€”</span>
		<span>ShaderPass module</span><span id="dShader">â€”</span>
		<span>WebGL context</span><span id="dGL">â€”</span>
		<span>Max texture size</span><span id="dMaxTex">â€”</span>
		<span>Anisotropy</span><span id="dAniso">â€”</span>
		<span>MediaRecorder</span><span id="dMR">â€”</span>
	  </div>
	  <div class="small">If any item shows a red âœ–, try a modern Chromium/Firefox/Safari. Everything is inlined via ESM CDN.</div>
	</div>
	  </div>
	</aside>

	<main id="right">
	  <canvas id="gl"></canvas>
	  <div id="overlay" style="display:none"><div class="pill"><div id="recDot"></div> Recordingâ€¦</div></div>
	</main>

	<footer style="grid-column:1 / -1; display:flex; align-items:center; justify-content:space-between; padding:8px 12px; border-top:1px solid #1f1f27; font-size:12px; color:#fff9">
	  <div>Â© 2025 â€” Singleâ€‘file demo</div>
	</footer>
  </div>

  <script type="module">
	import * as THREE from 'https://esm.sh/three@0.161.0';
	import { OrbitControls } from 'https://esm.sh/three@0.161.0/examples/jsm/controls/OrbitControls.js';
	import { EffectComposer } from 'https://esm.sh/three@0.161.0/examples/jsm/postprocessing/EffectComposer.js';
	import { RenderPass } from 'https://esm.sh/three@0.161.0/examples/jsm/postprocessing/RenderPass.js';
	import { UnrealBloomPass } from 'https://esm.sh/three@0.161.0/examples/jsm/postprocessing/UnrealBloomPass.js';
	import { ShaderPass } from 'https://esm.sh/three@0.161.0/examples/jsm/postprocessing/ShaderPass.js';

	// CRITICAL FIX: Expose THREE globally so deck code can access it
	window.THREE = THREE;
	globalThis.THREE = THREE;
	console.log('[THREE] Exposed THREE globally. Revision:', THREE.REVISION);

	const setDiag = (id, ok, extra='')=>{ const el=document.getElementById(id); if(!el) return; el.textContent = ok? `âœ” ${extra}` : `âœ– ${extra}`; el.className = ok? 'ok':'bad'; };

	// DOM refs
	const canvas = document.getElementById('gl');

// Double-click canvas â†’ hard reset
	try{
	  canvas.addEventListener('dblclick', (e)=>{
		e.preventDefault();
		// FIX: Signal to the pointerup handler to ignore the upcoming tap event.
		window.__ignoreNextTap = true;
		try {
		  const pb=document.getElementById('perpendicularBtn');
		  if(pb) pb.click();
		} catch(_){}
	  }, {capture:true});
	}catch(_){}
	
	// Prevent native context menu to avoid interrupting right-drag pan
	canvas.addEventListener('contextmenu', (e)=> e.preventDefault());
	const fileInput = document.getElementById('file');
	const presetSel = document.getElementById('preset');
	const customDims = document.getElementById('customDims');
	const wEl = document.getElementById('w');
	const hEl = document.getElementById('h');
	const fpsEl = document.getElementById('fps');
	const pathSel = document.getElementById('path');
	const durationEl = document.getElementById('duration');
	const durationN = document.getElementById('durationN');
	const easeSel = document.getElementById('ease');
	const yawAmp = document.getElementById('yawAmp');
	const yawAmpN = document.getElementById('yawAmpN');
	const pitchAmp = document.getElementById('pitchAmp');
	const pitchAmpN = document.getElementById('pitchAmpN');
	const fovMin = document.getElementById('fovMin');
	const fovMinN = document.getElementById('fovMinN');
	const fovMax = document.getElementById('fovMax');
	const fovMaxN = document.getElementById('fovMaxN');
	const minDist = document.getElementById('minDist');
	const minDistN = document.getElementById('minDistN');
	const maxDist = document.getElementById('maxDist');
	const maxDistN = document.getElementById('maxDistN');
	const focusX = document.getElementById('focusX');
	const focusXN = document.getElementById('focusXN');
	const focusY = document.getElementById('focusY');
	const focusYN = document.getElementById('focusYN');
	const resetFocus = document.getElementById('resetFocus');
	const panLocksFocus = document.getElementById('panLocksFocus');
	if(panLocksFocus) panLocksFocus.checked = true;
	const lockRoll = document.getElementById('lockRoll');
	const invertPitch = document.getElementById('invertPitch');
	const cylMode = document.getElementById('cylMode');
	const stickyOrbit = document.getElementById('stickyOrbit');
	const zoomStep = document.getElementById('zoomStep');
	
	const INFINITE_DRAG = false; // leave OFF for normal cursor; switch to true only if you want real infinite drag

// Effective zoom percent per frame when velocity=1 (map slider to slower baseline)
function getZoomPct(){
  const el = document.getElementById('zoomStep');
  const raw = el ? parseFloat(el.value||'1') : 1;
  // Map 1..50 slider to 0.25x..12.5x percent/frame
  // At default 1 â†’ 0.25% per 16.7ms when vel=1 (much slower than before)
  return Math.max(0.05, raw * 0.25);
}
// Keep number input in sync even if block above didn't add it
try{ if(zoomStep && zoomStepN){ zoomStep.addEventListener('input', ()=> zoomStepN.value = zoomStep.value);
zoomStepN.addEventListener('input', ()=> zoomStep.value = zoomStepN.value); } }catch(_){}
	const zoomStepN = document.getElementById('zoomStepN');
	const amb = document.getElementById('amb');
	const ambN = document.getElementById('ambN');
	const key = document.getElementById('key');
	const keyN = document.getElementById('keyN');
	const backKey = document.getElementById('backKey');
	const backKeyN = document.getElementById('backKeyN');
	const keyAng = document.getElementById('keyAng');
	const keyAngN = document.getElementById('keyAngN');
      const keyAz = document.getElementById('keyAz');
      const keyAzN = document.getElementById('keyAzN');
	const metal = document.getElementById('metal');
	const metalN = document.getElementById('metalN');
	const rough = document.getElementById('rough');
	const roughN = document.getElementById('roughN');
	const spec = document.getElementById('spec');
	const specN = document.getElementById('specN');
	const photoEmis = document.getElementById('photoEmis');
	const photoEmisN = document.getElementById('photoEmisN');
	const backEmis = document.getElementById('backEmis');
	const backEmisN = document.getElementById('backEmisN');
	const exposure = document.getElementById('exposure');
	const exposureN = document.getElementById('exposureN');
	const thick = document.getElementById('thick');
	const thickN = document.getElementById('thickN');
	const showFrame = document.getElementById('showFrame');
	const maxTexAuto = document.getElementById('maxTexAuto');
	const maxTexN = document.getElementById('maxTexN');
	const exportScale = document.getElementById('exportScale');
	const exportScaleN = document.getElementById('exportScaleN');
	const previewBtn = document.getElementById('previewBtn');
	const recordBtn = document.getElementById('recordBtn');
	const stopBtn = document.getElementById('stopBtn');
	const overlay = document.getElementById('overlay');
	const rightPane = document.getElementById('right');
	const showStars = document.getElementById('showStars');
	const enableBloom = document.getElementById('enableBloom');
	const bloomThreshold = document.getElementById('bloomThreshold');
	const bloomThresholdN = document.getElementById('bloomThresholdN');
	const bloomStrength = document.getElementById('bloomStrength');
	const bloomStrengthN = document.getElementById('bloomStrengthN');
	const bloomRadius = document.getElementById('bloomRadius');
	const bloomRadiusN = document.getElementById('bloomRadiusN');
	const enableAdvFlare = document.getElementById('enableAdvFlare');
	const starburst = document.getElementById('starburst');
	const starburstN = document.getElementById('starburstN');
	const lensDirt = document.getElementById('lensDirt');
	const lensDirtN = document.getElementById('lensDirtN');
	const enableGodRays = document.getElementById('enableGodRays');
	const grDensity = document.getElementById('grDensity');
	const grDensityN = document.getElementById('grDensityN');
	const grDecay = document.getElementById('grDecay');
	const grDecayN = document.getElementById('grDecayN');
	const grWeight = document.getElementById('grWeight');
	const grWeightN = document.getElementById('grWeightN');
	const grExposure = document.getElementById('grExposure');
	const grExposureN = document.getElementById('grExposureN');
	const enableSpeedScale = document.getElementById('enableSpeedScale');
	const speedScalePower = document.getElementById('speedScalePower');
	const speedScalePowerN = document.getElementById('speedScalePowerN');

	// --- Cinematic Path Builder UI ---
	const pathRecordBtn = document.getElementById('pathRecordBtn');
	const pathFinishBtn = document.getElementById('pathFinishBtn');
	const pathClearBtn = document.getElementById('pathClearBtn');
	const checkpointCountEl = document.getElementById('checkpointCountEl');
	const speedRampBtn = document.getElementById('speedRampBtn');
	const speedRampIndicator = document.getElementById('speedRampIndicator');
	const customPathOption = pathSel.querySelector('option[value="customPath"]');
	const pathProgressDisplay = document.getElementById('pathProgressDisplay');
	const pathTension = document.getElementById('pathTension');
	const pathTensionN = document.getElementById('pathTensionN');
	const orbitSmooth = document.getElementById('orbitSmooth');
	// NEW: Ramping controls
	const rampCheckpoints = document.getElementById('rampCheckpoints');
	const rampPower = document.getElementById('rampPower');
	const rampPowerN = document.getElementById('rampPowerN');


	
	const butterSmooth = document.getElementById('butterSmooth');
	const butterMs = document.getElementById('butterMs');
	const butterMsN = document.getElementById('butterMsN');
	const superSmooth = document.getElementById('superSmooth');
// --- Selective Bloom Setup ---
	const BASE_LAYER = 0;
	const BLOOM_LAYER = 1;
	const bloomLayer = new THREE.Layers();
	bloomLayer.set(BLOOM_LAYER);
	const darkMaterial = new THREE.MeshBasicMaterial({ color: 'black' });
	const materials = {};

	let photoMode = false;
	// THREE basics
	let renderer, scene, camera, controls, pivot; let focus = new THREE.Vector3(0,0,0);
	let lastX = 0, lastY = 0;
	let starfield = null; // Variable for our starfield
	let flareLight = null; // The bright light source for the flare
	
	// --- Post-Processing ---
	let bloomComposer, finalComposer; let fadeUniform=null; // Replaced the single 'composer'
	let bloomPass, flarePass, godRaysPass, finalPass;
	
	let occlusionRenderTarget;
	let depthMaskRT, maskMaterial;
	let blackMaterial = new THREE.MeshBasicMaterial({ color: 0x000000 });
	// Global flags used by both OrbitControls and enhanced handlers
	let suppressPanLock = false;
let __clickSlop = 7;           // px threshold to treat as a click (no-drag)
let __leftDownAt = {x:0,y:0,t:0}, __rightDownAt = {x:0,y:0,t:0};
let __leftClickCandidate = false, __rightClickCandidate = false;

	let suppressPanLockUntil = 0;
	let targetW=1080, targetH=1920;
	let panActive = false; // For preventing pivot updates during strafe

	// --- Cinematic Path State ---
	let isRecordingPath = false;
	let cinematicPathCheckpoints = [];
	let isRecordingSpeedRamp = false; // true after clicking "Speedramp Start", waiting for "Speedramp End"
	
	// NEW: Timing tracking variables
	let pathRecordingStartTime = 0;
	let lastCheckpointTime = 0;
	
	let pathOffsetCurve = null;
	let pathFocusCurve = null;
	let pathFovCurve = null;
	let pathTimeMap = null;

	// Calculate minimum viable duration based on path content
	function calculateMinimumDuration() {
		if (!cinematicPathCheckpoints || cinematicPathCheckpoints.length < 2) return 2;
		
		let minDuration = 0;
		
		// Add 2s for fade in, 2s for fade out
		minDuration += 4;
		
		// Add time for each checkpoint transition (minimum 0.5s per transition)
		minDuration += (cinematicPathCheckpoints.length - 1) * 0.5;
		
		// Add pause time for photo transitions
		cinematicPathCheckpoints.forEach(cp => {
			if (cp.isPause) {
				minDuration += (cp.pauseDuration || 0) / 1000;
			}
		});
		
		return Math.max(2, Math.ceil(minDuration));
	}

	// Update duration UI constraints
	function updateDurationConstraints() {
		const minDur = calculateMinimumDuration();
		const durationEl = document.getElementById('duration');
		const durationN = document.getElementById('durationN');
		if (durationEl) {
			durationEl.min = minDur;
			if (parseFloat(durationEl.value) < minDur) {
				durationEl.value = minDur;
				if (durationN) durationN.value = minDur;
			}
		}
		if (durationN) {
			durationN.min = minDur;
		}
	}

	// CRITICAL FIX: Make isMobileDevice global so it's accessible everywhere (especially in __wheelZoomStep)
	const isMobileDevice = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);

	try{
	  renderer = new THREE.WebGLRenderer({ canvas, antialias:true, alpha:false });
	  renderer.autoClear = false; // Important for multi-pass rendering
  try{ window.renderer = renderer; }catch(e){}
	  renderer.setPixelRatio(1);
	  renderer.outputColorSpace = THREE.SRGBColorSpace;
	  renderer.toneMapping = THREE.NoToneMapping; // IMPORTANT: Disable global tone mapping
	  renderer.toneMappingExposure = 1.0;
	  scene = new THREE.Scene();
	  scene.background = new THREE.Color(0x000000);
	    try{ window.scene = scene; }catch(e){}
camera = new THREE.PerspectiveCamera(50, 1, 0.01, 200);
	  
try{ camera.layers.enable(1); }catch(e){}
camera.position.set(0,0,4);
	  camera.up.set(0,1,0);
	  controls = new OrbitControls(camera, canvas);
	  controls.enableDamping = false; controls.dampingFactor = 0;
	  controls.enablePan = true; controls.enableZoom = true; 
	  // MOBILE FIX: Enable rotation for touch devices (needed for touch controls to work)
	  // isMobileDevice is now defined globally above
	  controls.enableRotate = isMobileDevice; // TRUE on mobile, FALSE on desktop
	  controls.target = new THREE.Vector3(0,0,0);
	  controls.mouseButtons = { LEFT: THREE.MOUSE.ROTATE, MIDDLE: THREE.MOUSE.DOLLY, RIGHT: null };
	  controls.touches = { ONE: THREE.TOUCH.ROTATE, TWO: THREE.TOUCH.DOLLY_PAN };
	  controls.target.copy(focus);
	  controls.update();
	  setDiag('dControls', !!controls && typeof controls.update==='function', 'OrbitControls');
	  setDiag('dThree', true, `r${THREE.REVISION}`);
	  setDiag('dComposer', typeof EffectComposer === 'function');
	  setDiag('dBloom', typeof UnrealBloomPass === 'function');
	  setDiag('dShader', typeof ShaderPass === 'function');
	  const gl = renderer.getContext(); setDiag('dGL', !!gl, gl? gl.getParameter(gl.VERSION):'');
	  var HW_MAX_TEX=0; try{ HW_MAX_TEX = gl? gl.getParameter(gl.MAX_TEXTURE_SIZE):0; }catch(e){ HW_MAX_TEX=0; }
	  setDiag('dMaxTex', !!HW_MAX_TEX, String(HW_MAX_TEX||''));
	  const _aniso = (renderer.capabilities.getMaxAnisotropy && renderer.capabilities.getMaxAnisotropy()) || renderer.capabilities.maxAnisotropy || 1;
	  setDiag('dAniso', true, String(_aniso));
	  setDiag('dMR', 'MediaRecorder' in window);

	  pivot = new THREE.Object3D(); scene.add(pivot); pivot.position.copy(focus); pivot.add(camera);
	  window.__HW_MAX_TEX__ = HW_MAX_TEX;
	}catch(err){
	  console.error(err);
	  setDiag('dThree', false, String(err));
	  setDiag('dGL', false);
	}

	const group = new THREE.Group(); scene.add(group);

	// Helpers

// === Neutral PMREM for clearcoat reflections ===
let __coatEnvTex = null;

// ===== TedEnv: minimal dynamic studio environment (key/fill/back; no front) =====
(function(){
  const G = (typeof globalThis !== 'undefined' ? globalThis : window);
  if (!G.TedEnv) G.TedEnv = { pmrem:null, scene:null, rt:null, tex:null, boxes:{} };

  function mkPanel(scene,w,h){
    const g = new THREE.PlaneGeometry(w,h);
    const m = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent:true, opacity: 1.0 });
    const q = new THREE.Mesh(g, m);
    scene.add(q);
    return q;
  }

  G.TedEnv.build = function(renderer, params){
    const ambI  = Number(params && params.ambI != null ? params.ambI : 1.0);
    const keyI  = Number(params && params.keyI != null ? params.keyI : 1.0);
    const backI = Number(params && params.backI != null ? params.backI : 0.8);
    const keyAngDeg = Number(params && params.keyAngDeg != null ? params.keyAngDeg : 45);

    if (!this.pmrem) this.pmrem = new THREE.PMREMGenerator(renderer);
    if (!this.scene){
      this.scene = new THREE.Scene();
      this.scene.background = new THREE.Color(0x050607);
      this.boxes = this.boxes || {};
      this.boxes.key  = mkPanel(this.scene, 6.0, 3.0);
      this.boxes.key2 = mkPanel(this.scene, 6.0, 3.0);
      this.boxes.fill = mkPanel(this.scene, 4.0, 2.2);
      this.boxes.back = mkPanel(this.scene, 8.0, 8.0);
    }

    const rad = THREE.MathUtils.degToRad(keyAngDeg);
    const R = 6.0;
    const xk = Math.sin(rad) * R, zk = -Math.cos(rad) * R;
const radBack = rad + Math.PI; const xb = -xk, zb = -zk;
// console.log('[TedEnv] key/back pos', {xk,zk, xb,zb});

    // Position panels (avoid facing +Z)
    const key = this.boxes.key;    key.position.set(xk, 2.0, zk); key.rotation.set(-0.2, Math.atan2(-xk, -zk), 0);
    const fill = this.boxes.fill;  fill.position.set(-xk*0.6, 1.0, zk*0.7 - 1.4); fill.rotation.set(-0.1, Math.atan2(xk*0.6, -zk*0.7 + 1.4), 0);
    const back = this.boxes.back;  back.position.set(-xk, back.position.y || 0, -zk); back.lookAt(0,0,0); back.lookAt(0,0,0);
    back.lookAt(0,0,0);
back.rotation.set(0.2, 0, 0);

    // Intensities via opacity + high color to push PMREM energy
    key.material.opacity  = Math.min(1, keyI * 1.0);
    key.material.color.setRGB(4.0,4.0,4.0);
    const key2 = this.boxes.key2;
    key2.position.copy(key.position);
    key2.rotation.copy(key.rotation);
    key2.material.opacity = Math.min(1, keyI * 1.0);
    key2.material.color.setRGB(4.0,4.0,4.0);

    fill.material.opacity = Math.min(1, ambI * 1.0);
    fill.material.color.setRGB(2.5,2.5,2.5);

    back.material.opacity = Math.min(1, backI * 1.0);
    back.material.color.setRGB(3.0,3.0,3.0);

    try { if (this.rt) { if (this.rt.texture && this.rt.texture.dispose) this.rt.texture.dispose(); if (this.rt.dispose) this.rt.dispose(); } } catch(e){}
    this.rt = this.pmrem.fromScene(this.scene, 0.04);
    this.tex = this.rt.texture;
    return this.tex;
  };

  G.TedEnv.refreshFromUI = function(){
    try{
      const amb  = parseFloat((document.getElementById('amb')||{}).value || 1);
      const key  = parseFloat((document.getElementById('key')||{}).value || 1);
      const back = parseFloat((document.getElementById('backKey')||{}).value || 0.8);
      const ang  = parseFloat((document.getElementById('keyAng')||{}).value || 45);
            const azEl = document.getElementById('keyAz');
      const azN  = document.getElementById('keyAzN');
      const azRaw = parseFloat((azEl||{}).value || 45);
      if (azN && !isNaN(azRaw)) { azN.value = String(azRaw); }
const r = G.renderer || G['renderer'];
      if (!r) { setTimeout(G.TedEnv.refreshFromUI, 120); return; }
      const tex = G.TedEnv.build(r, { ambI:amb, keyI:back, backI:key, keyAngDeg:ang, keyAzDeg:(azRaw) });
      if (G.scene) G.scene.environment = tex;
      if (G.photoCoat && G.photoCoat.material) { G.photoCoat.material.envMap = tex; G.photoCoat.material.needsUpdate = true; }
      // console.log('[TedEnv] rebuilt env', {amb, key, back, ang});
    }catch(e){ console.warn('[TedEnv] refresh error', e); }
  };

  function hook(){
    const ids = ['amb','key','backKey','keyAng', 'keyAz'];
    ids.forEach(id => {
      const el = document.getElementById(id);
      if (el && !el.__tedHook){
        const fire = function(){ try{ G.TedEnv.refreshFromUI(); }catch(e){} };
        el.addEventListener('input', fire);
        el.addEventListener('change', fire);
        el.__tedHook = true;
      }
    });
    const cards = Array.prototype.slice.call(document.querySelectorAll('#controls .card'));
    const ll = cards.find(function(c){ return /Look\s*&\s*Light/i.test((c.textContent||'')); });
    if (ll){
      const sliders = ll.querySelectorAll('input[type="range"]');
      Array.prototype.forEach.call(sliders, function(el){
        if (!el.__tedHook){
          const fire = function(){ try{ G.TedEnv.refreshFromUI(); }catch(e){} };
          el.addEventListener('input', fire);
          el.addEventListener('change', fire);
          el.__tedHook = true;
        }
      });
    }
  }
  document.addEventListener('DOMContentLoaded', hook);
  setTimeout(hook, 300);
  setInterval(hook, 1500);
})();
function setupCoatEnv(renderer){
  // console.log('[TedEnv] setupCoatEnv -> dynamic only');
  try{
    if (!renderer && (globalThis.renderer || globalThis['renderer'])) renderer = (globalThis.renderer || globalThis['renderer']);
    if (globalThis.TedEnv && TedEnv.refreshFromUI) TedEnv.refreshFromUI();
// console.log('[TedEnv] front/back convention = front is -Z');
// console.log('[TedEnv] key panel Z flipped to front');
    return (globalThis.TedEnv && TedEnv.tex) ? TedEnv.tex : null;
  }catch(e){ console.warn('[TedEnv] setup failed', e); return null; }
}


	const isVec3=(v)=>v&&typeof v.x==='number'&&typeof v.y==='number'&&typeof v.z==='number';
	const safeTarget=()=>{ try{ if(!controls) return null; if(!isVec3(controls.target)) controls.target=new THREE.Vector3(); return controls.target; }catch{ return null; } };

	// Raycaster (Shift+Click focus)
	const raycaster = new THREE.Raycaster();
	const ndc = new THREE.Vector2();

	// Lights
	const ambLight = new THREE.AmbientLight(0xffffff, parseFloat(amb.value)); scene.add(ambLight);
	const keyLight = new THREE.DirectionalLight(0xffffff, parseFloat(key.value)); scene.add(keyLight); keyLight.position.set(2,2,2);
	const hemi = new THREE.HemisphereLight(0x222233, 0x000000, 0.08); scene.add(hemi);
	const backLight = new THREE.DirectionalLight(0xffffff, parseFloat(backKey.value)); scene.add(backLight);
      try{ window.ambLight = ambLight; window.keyLight = keyLight; window.backLight = backLight; }catch(e){}
 backLight.position.set(2,2,-2.5);

	// Photo meshes
	let photoMesh=null, backMesh=null, sidesMesh=null, photoAspect=3/4;
	let photoTex = null;
	Object.defineProperty(window, 'photoTex', {
	  get() { return photoTex; },
	  set(v) { photoTex = v; },
	  configurable: true
	});
	let photoCoat = null;

	
// Soft disc texture for star points (bloom-friendly)
function makeDiscTexture(size=128){
  const c=document.createElement('canvas'); c.width=c.height=size;
  const ctx=c.getContext('2d');
  const g=ctx.createRadialGradient(size/2,size/2,0,size/2,size/2,size/2);
  g.addColorStop(0.0,'rgba(255,255,255,1)');
  g.addColorStop(0.5,'rgba(255,255,255,0.25)');
  g.addColorStop(1.0,'rgba(255,255,255,0)');
  ctx.fillStyle=g; ctx.fillRect(0,0,size,size);
  const tex=new THREE.CanvasTexture(c);
  tex.colorSpace = THREE.SRGBColorSpace;
  tex.minFilter=THREE.LinearMipmapLinearFilter; tex.magFilter=THREE.LinearFilter; tex.generateMipmaps=true;
  return tex;
}

// --- Starfield Creation ---
	function createStarfield() {
	if (starfield) {
		scene.remove(starfield);
		starfield.geometry.dispose();
		starfield.material.dispose();
	}

	const starVertices = [];
	for (let i = 0; i < 10000; i++) {
		const x = THREE.MathUtils.randFloatSpread(200);
		const y = THREE.MathUtils.randFloatSpread(200);
		const z = THREE.MathUtils.randFloatSpread(200);
		starVertices.push(x, y, z);
	}

	const geometry = new THREE.BufferGeometry();
	geometry.setAttribute('position', new THREE.Float32BufferAttribute(starVertices, 3));

	const material = new THREE.PointsMaterial({ color: 0xffffff, size: 0.12, map: makeDiscTexture(128), sizeAttenuation: true, transparent: true, opacity: 0.95, depthWrite: false, blending: THREE.AdditiveBlending });

	starfield = new THREE.Points(geometry, material);
	starfield.layers.enable(BLOOM_LAYER); // Assign to bloom layer
	starfield.visible = showStars.checked;
	scene.add(starfield);
	}
	
	// --- Light Source for Flare ---
	function createFlareLight() {
	if (flareLight) scene.remove(flareLight);
	// Remove any old visible mesh if it exists
	const oldStar = scene.getObjectByName('flareStar');
	if(oldStar) scene.remove(oldStar);

	flareLight = new THREE.PointLight(0xffeebf, 2.5, 2000); // Warmer color, more intensity
	flareLight.position.set(2, 1.5, -3); // Closer and more visible position
	scene.add(flareLight);

	// Add a visible mesh to represent the star
	const starGeo = new THREE.SphereGeometry(0.1, 32, 32);
	const starMat = new THREE.MeshBasicMaterial({ color: 0xffeebf, blending: THREE.AdditiveBlending });
	const starMesh = new THREE.Mesh(starGeo, starMat);
	starMesh.name = 'flareStar';
	starMesh.position.copy(flareLight.position);
	starMesh.layers.enable(BLOOM_LAYER); // Assign to bloom layer
	scene.add(starMesh);
	}

	// --- Post-Processing Setup ---
	function setupPostProcessing() {
	// 1. Base Render Pass
	const renderPass = new RenderPass(scene, camera);

	// 2. Bloom Composer (renders only BLOOM_LAYER)
	bloomComposer = new EffectComposer(renderer);
	bloomComposer.renderToScreen = false; // Don't render to screen, we'll use the result later
	bloomComposer.addPass(renderPass);

	// Occlusion Composer for God Rays
	occlusionRenderTarget = new THREE.WebGLRenderTarget(window.innerWidth / 2, window.innerHeight / 2);
	
	
	// Depth/occlusion mask to gate bloom & rays behind solid geometry
	depthMaskRT = new THREE.WebGLRenderTarget(window.innerWidth, window.innerHeight);
	maskMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff, side: THREE.DoubleSide });
// God Rays Shader Pass
	const godRaysShader = {
		uniforms: {
			'tDiffuse': { value: null },
			'tOcclusion': { value: null },
			'uLightPositionNDC': { value: new THREE.Vector2() },
			'uDensity': { value: parseFloat(grDensity.value) },
			'uDecay': { value: parseFloat(grDecay.value) },
			'uWeight': { value: parseFloat(grWeight.value) },
			'uExposure': { value: parseFloat(grExposure.value) },
		},
		vertexShader: `
			varying vec2 vUv;
			void main() {
				vUv = uv;
				gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
			}
		`,
		fragmentShader: `
			uniform sampler2D tDiffuse;
			uniform sampler2D tOcclusion;
			uniform vec2 uLightPositionNDC;
			uniform float uDensity;
			uniform float uDecay;
			uniform float uWeight;
			uniform float uExposure;
			varying vec2 vUv;
			
			const int NUM_SAMPLES = 100;

			void main() {
				vec4 originalColor = texture2D(tDiffuse, vUv);
				vec2 delta = vUv - uLightPositionNDC;
				delta *= 1.0 / float(NUM_SAMPLES) * uDensity;
				float illuminationDecay = 1.0;
				
				vec4 godRayColor = vec4(0.0);

				for (int i = 0; i < NUM_SAMPLES; i++) {
					vec2 sampleUv = vUv - delta * float(i);
					vec2 suvClamped = clamp(sampleUv, vec2(0.0), vec2(1.0));
float inBounds = step(0.0, sampleUv.x) * step(sampleUv.x, 1.0)
		   * step(0.0, sampleUv.y) * step(sampleUv.y, 1.0);
float occlusion = texture2D(tOcclusion, suvClamped).r * inBounds;
					godRayColor += occlusion * illuminationDecay * uWeight;
					illuminationDecay *= uDecay;
				}
				
				gl_FragColor = originalColor + godRayColor * uExposure;
			}
		`
	};
	godRaysPass = new ShaderPass(godRaysShader);
	godRaysPass.uniforms.tOcclusion.value = occlusionRenderTarget.texture;

	godRaysPass.enabled = enableGodRays.checked;
	bloomComposer.addPass(godRaysPass);

	// Bloom Pass
	bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
	bloomPass.threshold = parseFloat(bloomThreshold.value);
	bloomPass.strength = parseFloat(bloomStrength.value);
	bloomPass.radius = parseFloat(bloomRadius.value);
	bloomPass.enabled = true; // force-on; UI can still toggle later via listener
	bloomComposer.addPass(bloomPass);

	// Advanced Lens Flare Shader Pass
	const dirtTexture = createProceduralDirtTexture();
	const flareShader = {
		uniforms: {
			'tDiffuse': { value: null },
			'uLightPositionNDC': { value: new THREE.Vector3() },
			'uDirtTexture': { value: dirtTexture },
			'uStarburst': { value: parseFloat(starburst.value) },
			'uLensDirt': { value: parseFloat(lensDirt.value) },
			'uResolution': { value: new THREE.Vector2(canvas.width, canvas.height) }
		},
		vertexShader: `
			varying vec2 vUv;
			void main() {
				vUv = uv;
				gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
			}
		`,
		fragmentShader: `
			uniform sampler2D tDiffuse;
			uniform sampler2D uDirtTexture;
			uniform vec3 uLightPositionNDC;
			uniform float uStarburst;
			uniform float uLensDirt;
			uniform vec2 uResolution;
			varying vec2 vUv;

			void main() {
				vec4 originalColor = texture2D(tDiffuse, vUv);
				vec2 screenPos = vUv * 2.0 - 1.0;
			float aspect = uResolution.x / uResolution.y;
				screenPos.x *= aspect;
			vec2 lightPos = uLightPositionNDC.xy; lightPos.x *= aspect;
			vec2 lightVec = lightPos - screenPos;
				float lightDist = length(lightVec);

				
				vec2 dirtUv = vUv;
				
				// Center UVs and scale them to "cover" the viewport, preventing distortion.
				vec2 centeredUv = dirtUv - 0.5;
				if (aspect >= 1.0) { // Landscape or square
					centeredUv.x *= aspect;
				} else { // Portrait
					centeredUv.y /= aspect;
				}
				// Oversample center of dirt texture to avoid visible edges on resize
float oversampleScale = 2.0;
centeredUv /= oversampleScale;
dirtUv = centeredUv + 0.5;
				
				// Flip the Y-coordinate to match the canvas texture's orientation.
				dirtUv.y = 1.0 - dirtUv.y;
				
				vec3 dirt = texture2D(uDirtTexture, dirtUv).rgb * uLensDirt;

				

				vec3 ghosts = vec3(0.0);
				for (int i = 0; i < 5; i++) {
					vec2 ghostUv = screenPos - lightVec * (float(i) * 0.2 + 0.2);
					float ghostFalloff = pow(1.0 - length(ghostUv), 8.0);
					ghosts += vec3(0.2, 0.25, 0.3) * ghostFalloff * 0.5;
				}

				vec2 starburstVec = normalize(lightVec);
				float angle = atan(starburstVec.y, starburstVec.x);
				float starburstEffect = 0.0;
				if (uStarburst > 0.0) {
					for (int i = 0; i < 8; i++) {
						float offset = float(i) / 8.0 * 3.14159 * 2.0;
						vec2 sampleVec = vec2(cos(angle + offset), sin(angle + offset));
						for (int j = 1; j < 12; j++) {
							vec2 sampleUv = vUv + vec2(sampleVec.x / aspect, sampleVec.y) * (float(j) * 0.005);
							float luma = dot(texture2D(tDiffuse, sampleUv).rgb, vec3(0.299, 0.587, 0.114));
							starburstEffect += pow(luma, 4.0) * (1.0 - float(j) / 12.0);
						}
					}
				}
				vec3 starburstColor = vec3(0.8, 0.8, 1.0) * starburstEffect * uStarburst * 0.1;

				float flareVisibility = max(0.0, 1.0 - lightDist * 0.8);
				vec3 finalFlare = (ghosts + starburstColor + dirt) * flareVisibility * smoothstep(0.0, 1.0, uLightPositionNDC.z);
				
				gl_FragColor = originalColor + vec4(finalFlare, 1.0);
			}
		`
	};
	flarePass = new ShaderPass(flareShader);
	flarePass.enabled = enableAdvFlare.checked;
	bloomComposer.addPass(flarePass);

	// 3. Final Composer (combines base and bloom with selective tone mapping)
	finalComposer = new EffectComposer(renderer);
	finalComposer.addPass(renderPass);

	finalPass = new ShaderPass(
		new THREE.ShaderMaterial({
			uniforms: {
				baseTexture: { value: null },
				bloomTexture: { value: null },
				occludeTexture: { value: null },
				toneMappingType: { value: 0 }, // 0:None, 1:Linear, 2:Reinhard, 3:ACES
				exposure: { value: 1.0 }
			},
			vertexShader: `
				varying vec2 vUv;
				void main() {
					vUv = uv;
					gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

}
			`,
			fragmentShader: `
				uniform sampler2D baseTexture;
				uniform sampler2D bloomTexture;
				uniform float uFade;
				
				uniform sampler2D occludeTexture;
uniform int toneMappingType;
				uniform float exposure;
				varying vec2 vUv;

				// ACES Filmic Tone Mapping
				vec3 ACESFilmicToneMapping( vec3 color ) {
					color *= 0.6;
					float a = 2.51;
					float b = 0.03;
					float c = 2.43;
					float d = 0.59;
					float e = 0.14;
					return clamp((color * (a * color + b)) / (color * (c * color + d) + e), 0.0, 1.0);
				}

				// Reinhard Tone Mapping
				vec3 ReinhardToneMapping( vec3 color ) {
					color *= exposure;
					return clamp( color / ( vec3( 1.0 ) + color ), 0.0, 1.0 );
				}
				
				void main() {
					vec4 baseColor = texture2D( baseTexture, vUv );
					vec4 bloomColor = texture2D( bloomTexture, vUv );

					if (toneMappingType == 1) { // Linear
						bloomColor.rgb *= exposure;
					} else if (toneMappingType == 2) { // Reinhard
						bloomColor.rgb = ReinhardToneMapping(bloomColor.rgb);
					} else if (toneMappingType == 3) { // ACES
						bloomColor.rgb = ACESFilmicToneMapping(bloomColor.rgb * exposure);
					}
					
					// Gating disabled: photo renders on top already, so we don't need to suppress post-FX here.
// float occ = texture2D(occludeTexture, vUv).r;
// float block = step(0.5, occ);
// bloomColor *= (1.0 - block);
					vec4 outColor = baseColor + bloomColor;
					gl_FragColor = vec4(outColor.rgb * uFade, outColor.a);
				}
			`,
			defines: {}
		}), 'baseTexture'
	);
finalPass.uniforms.occludeTexture.value = depthMaskRT.texture;
finalPass.needsSwap = true;
	finalPass.uniforms.bloomTexture.value = bloomComposer.renderTarget2.texture;
finalComposer.addPass(finalPass);
finalPass.uniforms.uFade = { value: 1.0 };
fadeUniform = finalPass.uniforms.uFade;
// Expose fadeUniform globally for crossfade transitions
try { globalThis.fadeUniform = fadeUniform; window.fadeUniform = fadeUniform; } catch(_){}
	}
	
	function createProceduralDirtTexture() {
	const size = 512;
	const canvas = document.createElement('canvas');
	canvas.width = size;
	canvas.height = size;
	const ctx = canvas.getContext('2d');
	ctx.fillStyle = '#111';
	ctx.fillRect(0, 0, size, size);
	for (let i = 0; i < 50; i++) {
		const x = Math.random() * size;
		const y = Math.random() * size;
		const r = Math.random() * 30 + 5;
		const opacity = Math.random() * 0.1 + 0.05;
		ctx.fillStyle = `rgba(255, 255, 255, ${opacity})`;
		ctx.beginPath();
		ctx.arc(x, y, r, 0, Math.PI * 2);
		ctx.fill();
	}
	return new THREE.CanvasTexture(canvas);
	}

	// Toggle starfield visibility
	showStars.addEventListener('change', () => {
	if (starfield) starfield.visible = showStars.checked;
	});

	// Toggle bloom and update params
	enableBloom.addEventListener('change', () => {
	if (bloomPass) bloomPass.enabled = enableBloom.checked;
	});
	const updateBloom = () => {
	if (bloomPass) {
		bloomPass.threshold = parseFloat(bloomThreshold.value);
		bloomPass.strength = parseFloat(bloomStrength.value);
		bloomPass.radius = parseFloat(bloomRadius.value);
	}
	};
	[bloomThreshold, bloomStrength, bloomRadius].forEach(el => el.addEventListener('input', updateBloom));

	// Toggle advanced flare and update params
	enableAdvFlare.addEventListener('change', () => {
	if (flarePass) flarePass.enabled = enableAdvFlare.checked;
	});
	const updateFlare = () => {
	if (flarePass) {
		flarePass.uniforms.uStarburst.value = parseFloat(starburst.value);
		flarePass.uniforms.uLensDirt.value = parseFloat(lensDirt.value);
	}
	};
	[starburst, lensDirt].forEach(el => el.addEventListener('input', updateFlare));

	// Toggle God Rays and update params
	enableGodRays.addEventListener('change', () => {
	if (godRaysPass) godRaysPass.enabled = enableGodRays.checked;
	});
	const updateGodRays = () => {
	if (godRaysPass) {
		godRaysPass.uniforms.uDensity.value = parseFloat(grDensity.value);
		godRaysPass.uniforms.uDecay.value = parseFloat(grDecay.value);
		godRaysPass.uniforms.uWeight.value = parseFloat(grWeight.value);
		godRaysPass.uniforms.uExposure.value = parseFloat(grExposure.value);
	}
	};
	[grDensity, grDecay, grWeight, grExposure].forEach(el => el.addEventListener('input', updateGodRays));


	// Layout/size
	function setRendererSize(){
	  const preset = presetSel.value; let w=1080, h=1920, fps=30;
	  if(preset==='post'){ w=1080; h=1350; }
	  if(preset==='custom'){ w=parseInt(wEl.value||1080); h=parseInt(hEl.value||1920); fps=parseInt(fpsEl.value||30); } else { fps=30; }
	  renderer.setSize(w,h,false);
	  if (bloomComposer) bloomComposer.setSize(w, h);
	  if (finalComposer) finalComposer.setSize(w, h);
	  if (occlusionRenderTarget) occlusionRenderTarget.setSize(w / 2, h / 2);
		if (depthMaskRT) depthMaskRT.setSize(w, h);
if (flarePass) flarePass.uniforms.uResolution.value.set(w, h);
	  camera.aspect = w/h; camera.updateProjectionMatrix();
	  targetW = w; targetH = h; canvas.style.aspectRatio = `${w} / ${h}`; layoutCanvas(); updateFrameOutline();
	  return {w,h,fps};
	}
	function layoutCanvas(){ const cw=rightPane.clientWidth||canvas.parentElement.clientWidth, ch=rightPane.clientHeight||canvas.parentElement.clientHeight; if(!cw||!ch) return; const s=Math.min(cw/targetW, ch/targetH); const wpx=Math.max(1,Math.floor(targetW*s)); const hpx=Math.max(1,Math.floor(targetH*s)); canvas.style.width=wpx+'px'; canvas.style.height=hpx+'px'; updateFrameOutline(); }
	function updateFrameOutline(){ const show = document.getElementById('showFrame'); if(show && show.checked){ canvas.style.outline='1px solid #2f2f3a'; canvas.style.boxShadow='0 0 0 1px #2f2f3a'; } else { canvas.style.outline='none'; canvas.style.boxShadow='none'; } }

	const syncPairs=(a,b)=>{ a.addEventListener('input',()=>b.value=a.value); b.addEventListener('input',()=>a.value=b.value); };
	[[durationEl,durationN],[yawAmp,yawAmpN],[pitchAmp,pitchAmpN],[fovMin,fovMinN],[fovMax,fovMaxN],[focusX,focusXN],[focusY,focusYN],[amb,ambN],[key,keyN],[backKey,backKeyN],[keyAng,keyAngN],[metal,metalN],[rough,roughN],[spec,specN],[photoEmis,photoEmisN],[backEmis,backEmisN],[exposure,exposureN],[thick,thickN],[minDist,minDistN],[maxDist,maxDistN],[exportScale,exportScaleN], [bloomThreshold, bloomThresholdN], [bloomStrength, bloomStrengthN], [bloomRadius, bloomRadiusN], [starburst, starburstN], [lensDirt, lensDirtN], [grDensity, grDensityN], [grDecay, grDecayN], [grWeight, grWeightN], [grExposure, grExposureN], [speedScalePower, speedScalePowerN],[zoomStep, zoomStepN], [pathTension, pathTensionN], [rampPower, rampPowerN]].forEach(([x,y])=>{ if(x&&y) syncPairs(x,y); });
// Add Butter sync
if (butterMs && butterMsN) { (function(a,b){ a.addEventListener('input',()=>b.value=a.value); b.addEventListener('input',()=>a.value=b.value); })(butterMs,butterMsN); }

// --- Set distance limits for OrbitControls ---
function updateControlLimits() {
	if (controls) {
	controls.minDistance = parseFloat(minDist.value) || 0.01;
	controls.maxDistance = parseFloat(maxDist.value) || 50;
	}
}
minDist.addEventListener('input', updateControlLimits);
minDistN.addEventListener('input', updateControlLimits);
maxDist.addEventListener('input', updateControlLimits);
maxDistN.addEventListener('input', updateControlLimits);
updateControlLimits(); // Set initial values on load

// --- Make Look & Light controls actually affect the scene ---
const lookAndLightIds = [
  'amb','ambN','key','keyN','backKey','backKeyN','keyAng','keyAngN',
  'metal','metalN','rough','roughN','spec','specN',
  'photoEmis','photoEmisN','backEmis','backEmisN','exposure','exposureN'
];
lookAndLightIds.forEach(id => {
  const el = document.getElementById(id);
  if (el) el.addEventListener('input', ()=>updateLookAndLighting(true));
});


// === Inject "Photo Clearcoat" sliders into Look & Light card ===
;(function injectClearcoatControls(){
  const card = [...document.querySelectorAll('.card h3')]
	.find(h => /Look\s*&\s*Light/i.test(h.textContent))?.closest('.card');
  if (!card || document.getElementById('coat')) return;

  const mk = (label, id, min, max, step, val) => `
	<label>${label}
	  <span>
	<input type="range" id="${id}" min="${min}" max="${max}" step="${step}" value="${val}">
	<input type="number" id="${id}N" min="${min}" max="${max}" step="${step}" value="${val}">
	  </span>
	</label>`;
  const wrap = document.createElement('div');
  wrap.innerHTML = `
	<hr style="border-color:#2a2a35; margin: 8px 0;">
	<h4 style="margin:.25rem 0 .5rem;font-size:12px;color:#c9c9d8">Photo Clearcoat (gloss overlay)</h4>
	${mk('Coat Strength', 'coat', 0, 1, 0.01, 0.3)}
	${mk('Coat Roughness', 'coatRough', 0, 1, 0.01, 0.2)}
	${mk('Coat Env Intensity', 'coatEnv', 0, 5, 0.01, 0.3)}
  `;
  card.appendChild(wrap);

  const sync = (a,b)=>{ a.addEventListener('input',()=>b.value=a.value); b.addEventListener('input',()=>a.value=b.value); };
  [['coat','coatN'],['coatRough','coatRoughN'],['coatEnv','coatEnvN']].forEach(([x,y])=>{
	const A=document.getElementById(x), B=document.getElementById(y); if(A&&B) sync(A,B);
  });
})();


// === Clearcoat live updates ===
;['coat','coatN','coatRough','coatRoughN','coatEnv','coatEnvN'].forEach(id=>{
  const el = document.getElementById(id);
  if(!el) return;
  el.addEventListener('input', ()=>{
	if(photoCoat && photoCoat.material && photoCoat.material.isMeshPhysicalMaterial){
	  photoCoat.material.clearcoat = parseFloat(document.getElementById('coat')?.value) || 0.3;
	  photoCoat.material.clearcoatRoughness = parseFloat(document.getElementById('coatRough')?.value) || 0.2;
	  photoCoat.material.envMapIntensity = parseFloat(document.getElementById('coatEnv')?.value) || 0.3;
	  photoCoat.material.needsUpdate = true;
	}
  });
});


// --- Thickness changes require rebuilding the mesh (adds sides/back depth) ---
const rebuildFromThickness = () => createOrUpdatePhotoMesh && createOrUpdatePhotoMesh();
	// Center camera & focus on startup
	if(controls){ controls.target.set(0,0,0); controls.update(); }
	if(camera){ camera.position.set(0,0,5); camera.lookAt(0,0,0); }
	focus.set(0,0,0); updateFocusInputs({syncControls:true});

['thick','thickN'].forEach(id => {
  const el = document.getElementById(id);
  if (el) el.addEventListener('input', rebuildFromThickness);
});

// (Optional) keep the frame outline toggle live
if (typeof updateFrameOutline === 'function') {
  const showFrame = document.getElementById('showFrame');
  if (showFrame) showFrame.addEventListener('change', updateFrameOutline);
}


	function enterPhotoMode(){ applyNeutralNearPhotoDefaults();
	frameFrontOfPhoto(); }
	function enterLitMode(){ const badge=document.getElementById('photoModeBadge'); if(badge){ badge.textContent='Lit Mode'; badge.style.color='#ffd166'; } }

	
	function applyNeutralNearPhotoDefaults(){
	  const badge = document.getElementById('photoModeBadge'); if(badge){ badge.textContent='Nearâ€‘Photo Baseline'; badge.style.color='#9cffbf'; }
	  // Set sliders
	  const setV = (id, val)=>{ const el=document.getElementById(id); const elN=document.getElementById(id+'N'); if(el){ el.value=String(val); } if(elN){ elN.value=String(val); } };
	  setV('amb', 1.0); setV('ambN', 1.0);
	  setV('key', 1.0); setV('keyN', 1.0);
	  setV('backKey', 1.0); setV('backKeyN', 1.0);
	  setV('metal', 0.2); setV('metalN', 0.2);
	  setV('rough', 0.3); setV('roughN', 0.3);
	  setV('spec', 0.5); setV('specN', 0.5);
	  setV('photoEmis', 1.0); setV('photoEmisN', 1.0);
	  setV('backEmis', 0.025); setV('backEmisN', 0.025);
	  setV('exposure', 1.0); setV('exposureN', 1.0);
	  // Update
	  updateLookAndLighting(false);
	  // Update selector UI
	  const tmSel = document.getElementById('toneMapSel'); if(tmSel){ tmSel.value = 'linear'; }
	  if (finalPass) finalPass.uniforms.toneMappingType.value = 1;
	}


	window.addEventListener('resize', layoutCanvas); window.addEventListener('orientationchange', layoutCanvas);
	presetSel.addEventListener('change', ()=>{ customDims.style.display = presetSel.value==='custom' ? 'block':'none'; setRendererSize();
	createOrUpdatePhotoMesh();
	applyNeutralNearPhotoDefaults();
	createOrUpdatePhotoMesh();
	applyNeutralNearPhotoDefaults();

	// Start with nearâ€‘photo Lit baseline (no material swap)
	});
	;[wEl,hEl,fpsEl].forEach(el=>el.addEventListener('input', setRendererSize));

	// Around line 1444, add this new function
	
	// Around line 1444
	// Around line 1551
	function _endAndCleanupOrbit() {
		cylRotating = false;
		orbitRotating = false;
		__cancelInertia();
	
		// --- NEW UNIFIED "BAKE AND RESET" LOGIC ---
		// This robust sequence is now the universal cleanup for all manual operations.
	
		// Step 1: Make camera a free agent to get its true world position.
		scene.attach(camera);
	
		// Step 2: Reset the pivot's rotation to zero.
		pivot.rotation.set(0, 0, 0);
		pivot.updateWorldMatrix(true);
	
		// Step 3: Re-parent the camera to the now-clean pivot.
		pivot.attach(camera);
	
		// Step 4: Perform the "Cylindrical Reset" to simplify the local transform.
		const finalState = cylFromCamera();
		applyRig(finalState.phi, finalState.r, finalState.elev);
	
		// Step 5: Finalize by re-enabling and syncing controls.
		if (controls) {
			controls.enabled = true;
			controls.target.copy(focus);
			controls.update();
		}
	}
	
	function __cancelAllSticky(){
	  try{ if (panActive) endPan(false); }catch(_){}
	  try{ _endAndCleanupOrbit(); }catch(_){}
	  try{ rmbLatched = false; }catch(_){}
	  try{ window.__orbitLatched = false; }catch(_){}
	  try{ panOverride=false; panGestureLock=false; rightDown=false; leftDown=false; hasDragged=false; rightHasDragged=false; }catch(_){}
	  try{ if (controls) controls.enabled = true; }catch(_){}
	}

	
	// Center the camera front-on and frame the whole photo with a tiny margin
	function frameFrontOfPhoto(margin=0.02){
	  try{
	// Reset rotations
	if(pivot){ pivot.rotation.set(0,0,0); }
	// Focus at image center
	if(focus){ focus.set(0,0,0); }
	
	// Compute distance to fit the actual photo mesh dimensions
	const PIXEL_SCALE = 0.00025;
	const useNativeDimensions = (typeof window.photoWidth === 'number' && typeof window.photoHeight === 'number');
	
	let WIDTH, HEIGHT;
	if (useNativeDimensions) {
	  WIDTH = window.photoWidth * PIXEL_SCALE;
	  HEIGHT = window.photoHeight * PIXEL_SCALE;
	} else {
	  WIDTH = 1;
	  HEIGHT = 1 / (photoAspect||1);
	}
	
	const vfov = (camera.fov||50) * Math.PI/180;
	const aspect = camera.aspect || 1;
	const hfov = 2*Math.atan(Math.tan(vfov/2) * aspect);
	const needZForH = (HEIGHT/2) / Math.tan(vfov/2);
	const needZForW = (WIDTH/2)  / Math.tan(hfov/2);
	const r = Math.max(needZForH, needZForW) * (1+margin);
	// Place camera using rig (phi=0 front-on, elev=0)
	applyRig(0, r, 0, camera.fov);
	// Sync controls target to focus and update inputs
	if(controls){ controls.target.set(0,0,0); controls.update(); }
	if(typeof updateFocusInputs==='function'){ updateFocusInputs({syncControls:true}); }
	  }catch(err){ console.warn('frameFrontOfPhoto failed:', err); }
	}

	function updateFocusRanges(){ 
	  // Calculate actual mesh dimensions (must match createOrUpdatePhotoMesh logic)
	  const PIXEL_SCALE = 0.00025;
	  const useNativeDimensions = (typeof window.photoWidth === 'number' && typeof window.photoHeight === 'number');
	  
	  let width, height;
	  if (useNativeDimensions) {
	    width = window.photoWidth * PIXEL_SCALE;
	    height = window.photoHeight * PIXEL_SCALE;
	  } else {
	    width = 1;
	    height = width / photoAspect;
	  }
	  
	  // Set pan limits based on actual mesh dimensions
	  focusX.min = (-width/2).toFixed(3); 
	  focusX.max = (width/2).toFixed(3); 
	  focusY.min = (-height/2).toFixed(3); 
	  focusY.max = (height/2).toFixed(3); 
	  
	  console.log('[updateFocusRanges] Updated limits:', {width, height, xMin: focusX.min, xMax: focusX.max, yMin: focusY.min, yMax: focusY.max});
	  updateFocusInputs({syncControls:true}); 
	}
	function updateFocusInputs({syncControls=true}={}){ 
	  // Calculate actual mesh dimensions (must match createOrUpdatePhotoMesh logic)
	  const PIXEL_SCALE = 0.00025;
	  const useNativeDimensions = (typeof window.photoWidth === 'number' && typeof window.photoHeight === 'number');
	  
	  let width, height;
	  if (useNativeDimensions) {
	    width = window.photoWidth * PIXEL_SCALE;
	    height = window.photoHeight * PIXEL_SCALE;
	  } else {
	    width = 1;
	    height = width / photoAspect;
	  }
	  
	  const clampedX = THREE.MathUtils.clamp(focus.x, -width/2, width/2); 
	  const clampedY = THREE.MathUtils.clamp(focus.y, -height/2, height/2); 
	  focus.set(clampedX, clampedY, 0); 
	  focusXN.value = focusX.value = clampedX.toFixed(3); 
	  focusYN.value = focusY.value = clampedY.toFixed(3); 
	  if(syncControls){ const t=safeTarget(); if(t) t.copy(focus); } 
	}
	function setFocusFromInputs(opts={syncControls:true}){ focus.set(parseFloat(focusX.value||0), parseFloat(focusY.value||0), 0); updateFocusInputs(opts); }
	[focusX, focusXN, focusY, focusYN].forEach(el=>el.addEventListener('input', ()=>setFocusFromInputs({syncControls:true})));
	if (panLocksFocus){ panLocksFocus.addEventListener('change', ()=>{ if(panLocksFocus.checked){ updateFocusInputs({syncControls:true}); } }); }

	function updateLookAndLighting(fromUI=false){
    try{ if (keyEl) keyEl.max = '1.0'; }catch(e){}


    // Keep back directional exactly opposite key (front = -Z)
    try{
      const ang = parseFloat(document.getElementById('keyAng')?.value)||0;
      const R = 6.0;
      const ak = THREE.MathUtils.degToRad(ang);
      const xk = Math.sin(ak)*R, zk = -Math.cos(ak)*R; // key in front when angâ‰ˆ0
      const xb = -xk, zb = -zk;                        // back opposite
      if (typeof keyDir  !== 'undefined') { keyDir.position.set(xk, keyDir.position.y||2.0, zk); keyDir.lookAt(0,0,0); }
      if (typeof backDir !== 'undefined') { backDir.position.set(xb, backDir.position.y||2.0, zb); backDir.lookAt(0,0,0); }
      // console.log('[LL] key/backDir', {xk,zk, xb,zb});
    }catch(e){}
    
    // Keep back directional exactly 180Â° from key
    try{
      const ang = parseFloat(document.getElementById('keyAng')?.value)||0;
      const a = THREE.MathUtils.degToRad(ang) + Math.PI;
      const R = 6.0;
      const xb = Math.sin(a)*R, zb = Math.cos(a)*R;
      if (typeof backDir !== 'undefined') { backDir.position.set(xb, backDir.position.y||2.0, zb); backDir.lookAt(0,0,0); }
      if (typeof keyDir !== 'undefined')  { keyDir.lookAt(0,0,0); }
      // console.log('[LL] backDir set opposite key', {xb,zb});
    }catch(e){}
    
    // Keep back directional opposite key
    try{
      const ang = parseFloat(document.getElementById('keyAng')?.value)||0;
      const a = THREE.MathUtils.degToRad(ang) + Math.PI;
      const R = 6.0;
      const xb = Math.sin(a)*R, zb = Math.cos(a)*R;
      if (typeof backDir !== 'undefined') { backDir.position.set(xb, backDir.position.y||2.0, zb); backDir.lookAt(0,0,0); }
      if (typeof keyDir  !== 'undefined') { keyDir.lookAt(0,0,0); }
      // console.log('[LL] back light set opposite key');
    }catch(e){}
    	  const amb = document.getElementById('amb'), ambN=document.getElementById('ambN');
	  const key = document.getElementById('key'), keyN=document.getElementById('keyN');
	  const backKey = document.getElementById('backKey'), backKeyN=document.getElementById('backKeyN');
	  const keyAng = document.getElementById('keyAng'), keyAngN=document.getElementById('keyAngN');
	  const metal = document.getElementById('metal'), metalN=document.getElementById('metalN');
	  const rough = document.getElementById('rough'), roughN=document.getElementById('roughN');
	  const spec = document.getElementById('spec'), specN=document.getElementById('specN');
	  const photoEmis = document.getElementById('photoEmis'), photoEmisN=document.getElementById('photoEmisN');
	  const backEmis = document.getElementById('backEmis'), backEmisN=document.getElementById('backEmisN');
	  const exposure = document.getElementById('exposure'), exposureN=document.getElementById('exposureN');
	  if(finalPass) finalPass.uniforms.exposure.value = parseFloat(exposure.value||1);
	  ambLight.intensity=parseFloat(amb.value||0);
	  keyLight.intensity=parseFloat(key.value||0);
	  backLight.intensity=parseFloat(backKey.value||0);
	  const keyAngleRad=THREE.MathUtils.degToRad(parseFloat(keyAng.value||0)); const radius=5;
	  keyLight.position.set(Math.cos(keyAngleRad)*radius, Math.sin(keyAngleRad)*radius*0.6, 2.5);
	  keyLight.target=photoMesh||group; keyLight.target.updateMatrixWorld();
	  backLight.position.set(Math.cos(keyAngleRad)*radius, Math.sin(keyAngleRad)*radius*0.6, -2.5); backLight.target=photoMesh||group; backLight.target.updateMatrixWorld();
	  if(photoMesh){
	const m = photoMesh.material;
	// Base photo is unlit (MeshBasicMaterial), keep pixels pure
	if (m && m.isMeshBasicMaterial) {
	  // do nothing
	}
  }
	  if(backMesh){ const bm=backMesh.material; bm.metalness=parseFloat(metal.value); bm.roughness=parseFloat(rough.value); bm.specularIntensity=parseFloat(spec.value); bm.emissiveIntensity=parseFloat(backEmis.value); bm.emissive.set(0xffffff); bm.needsUpdate=true; }
	  if(sidesMesh){ const mats=Array.isArray(sidesMesh.material)?sidesMesh.material:[sidesMesh.material]; for(const sm of mats){ if(sm && sm.isMeshPhysicalMaterial){ sm.metalness=parseFloat(metal.value); sm.roughness=parseFloat(rough.value); sm.specularIntensity=parseFloat(spec.value); sm.emissiveIntensity=parseFloat(backEmis.value); sm.emissive.set(0xffffff); sm.side=THREE.DoubleSide; sm.needsUpdate=true; } } }
	}

	// Build/refresh meshes
	
function createOrUpdatePhotoMesh(){
	// Define a scale factor: 1 pixel = 0.001 units (adjustable)
	  const PIXEL_SCALE = 0.00025;
	
	// Use native dimensions if available, otherwise fall back to aspect-based sizing
	const useNativeDimensions = (typeof window.photoWidth === 'number' && typeof window.photoHeight === 'number');
	
	let WIDTH, HEIGHT;
	if (useNativeDimensions) {
	  WIDTH = window.photoWidth * PIXEL_SCALE;
	  HEIGHT = window.photoHeight * PIXEL_SCALE;
	} else {
	  // Fallback to normalized sizing
	  WIDTH = 1;
	  HEIGHT = WIDTH / photoAspect;
	}

  // Cleanup old
  [photoMesh, photoCoat, backMesh, sidesMesh].forEach(m => {
	if(!m) return;
	if(m.parent) m.parent.remove(m);
	m.geometry?.dispose?.();
	if(Array.isArray(m.material)) m.material.forEach(mm=>mm.dispose?.());
	else m.material?.dispose?.();
  });
  photoMesh = photoCoat = backMesh = sidesMesh = null;

  const geo = new THREE.PlaneGeometry(WIDTH,HEIGHT,1,1);

  // Flip UVs once for upright with flipY=false
  if(geo && geo.attributes && geo.attributes.uv){
	const uvAttr = geo.attributes.uv;
	for(let i=0;i<uvAttr.count;i++){ uvAttr.setY(i, 1 - uvAttr.getY(i)); }
	uvAttr.needsUpdate = true;
  }

  // 1) Base photo: unlit, no tone mapping
  const baseMat = new THREE.MeshBasicMaterial({ map: photoTex, toneMapped: true, transparent: false });
  photoMesh = new THREE.Mesh(geo, baseMat);
  photoMesh.layers.set(BASE_LAYER);
  photoMesh.renderOrder = 10;
  group.add(photoMesh);
  
  // CRITICAL: Expose globally for deck code
  window.photoMesh = photoMesh;
  globalThis.photoMesh = photoMesh;

  // 2) Clearcoat overlay: additive coat-only
  const coat = parseFloat(document.getElementById('coat')?.value) || 0.3;
  const coatR = parseFloat(document.getElementById('coatRough')?.value) || 0.2;
  const coatEnvI = parseFloat(document.getElementById('coatEnv')?.value) || 0.3;
  // setup env
  (async()=>{
	const env = await setupCoatEnv(renderer);
	// Apply as global environment so PBR reflections are guaranteed
	scene.environment = (globalThis.TedEnv && TedEnv.tex) ? TedEnv.tex : env;
	
// --- Tiny clearcoat normal map to make the highlight visible on a flat plane ---
function makeCoatNormalTexture(size=64, amp=0.15){
  const c = document.createElement('canvas'); c.width = c.height = size;
  const ctx = c.getContext('2d');
  const img = ctx.createImageData(size, size);
  for(let y=0;y<size;y++){
    for(let x=0;x<size;x++){
      const n = (Math.sin(x*12.9898 + y*78.233)*43758.5453)%1;
      const nx = ((n*2-1) * amp);
      const ny = ((Math.sin((x+y)*0.7)*0.5) * amp);
      const nz = Math.sqrt(Math.max(0.0, 1.0 - nx*nx - ny*ny));
      const r = Math.floor((nx*0.5+0.5)*255);
      const g = Math.floor((ny*0.5+0.5)*255);
      const b = Math.floor((nz*0.5+0.5)*255);
      const i = (y*size + x)*4;
      img.data[i+0]=r; img.data[i+1]=g; img.data[i+2]=b; img.data[i+3]=255;
    }
  }
  ctx.putImageData(img,0,0);
  const tex = new THREE.CanvasTexture(c);
  tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
  tex.anisotropy = 2;
  return tex;
}

const coatMat = new THREE.MeshPhysicalMaterial({
	  color: 0x000000,
	  metalness: 0.0,
	  roughness: 1.0,
	  specularIntensity: 0.0,
	  clearcoat: coat,
	  clearcoatRoughness: coatR,
	  envMap: env,
	  envMapIntensity: coatEnvI,
	  transparent: true,
	  blending: THREE.AdditiveBlending,
	  depthTest: true,
	  depthWrite: false,
	  polygonOffset: true,
	  polygonOffsetFactor: -2,
	  side: THREE.FrontSide,
	  toneMapped: false,
	  ior: 1.5
	});
	

// --- Fresnel override: adjustable clearcoat F0 (normal-incidence reflectance) ---
try {
  (function patchClearcoatFresnel(mat, f0){
    // f0 in [0..1]; try 0.20â€“0.40 for a strong front sheen (1.0 = mirror)
    f0 = (typeof f0 === 'number' ? Math.min(Math.max(f0, 0.0), 1.0) : 0.30);
    if (!mat) { console.warn('[coat] No material to patch'); return; }

    // Ensure a unique program so our override compiles distinctly when F0 changes
    mat.customProgramCacheKey = () => 'coatF0-v2-' + f0.toFixed(3);

    mat.onBeforeCompile = (shader) => {
      // Use a VEC3 uniform because many F_Schlick calls expect vec3 F0
      shader.uniforms.uClearcoatF0 = { value: new THREE.Vector3(f0, f0, f0) };

      // Prepend the uniform and replace both float and vec3 variants of the hardcoded 0.04
      let fs = shader.fragmentShader;
      fs = 'uniform vec3 uClearcoatF0;\n' + fs;

      // Replace F_Schlick( 0.04, ... )
      fs = fs.replace(/F_Schlick\(\s*0\.04\s*,/g, 'F_Schlick( uClearcoatF0 ,');
      // Replace F_Schlick( vec3(0.04), ... ) and variants with whitespace
      fs = fs.replace(/F_Schlick\(\s*vec3\(\s*0\.04\s*\)\s*,/g, 'F_Schlick( uClearcoatF0 ,');

      shader.fragmentShader = fs;
      mat.userData.shader = shader; // handle for runtime tweaking
    };

    mat.needsUpdate = true;
    // console.log('[coat] Fresnel override active (v2); F0 =', f0);
  })( (typeof coatMat!=='undefined' && coatMat) || (window.photoCoat && photoCoat.material), 0.30 );

  // Console helper to tweak F0 at runtime
  window.setClearcoatF0 = function(v){
    var m = (window.photoCoat && photoCoat.material);
    var sh = m && m.userData && m.userData.shader;
    if (sh && sh.uniforms && sh.uniforms.uClearcoatF0){
      var vv = Math.max(0, Math.min(1, Number(v)));
      sh.uniforms.uClearcoatF0.value.set(vv, vv, vv);
      // console.log('[coat] uClearcoatF0 ->', vv);
    } else {
      // console.warn('[coat] clearcoat F0 uniform not ready yet');
    }
  };
} catch (e) {
  console.warn('[coat] Fresnel override failed', e);
}
try { if (globalThis.TedEnv && TedEnv.tex) { coatMat.envMap = TedEnv.tex; coatMat.needsUpdate = true;  } } catch(e){}
photoCoat = new THREE.Mesh(geo.clone(), coatMat);
	photoCoat.layers.set(BASE_LAYER);
	photoCoat.renderOrder = 11;
	group.add(photoCoat);
  
  try{ window.photoCoat = photoCoat; if (window.TedEnv && TedEnv.refreshFromUI) TedEnv.refreshFromUI(); }catch(e){}
})();

  // 3) Back & sides PBR (bloom layer)
  const backMat = new THREE.MeshPhysicalMaterial({
	color:0x121214, emissive:0xffffff,
	emissiveIntensity: parseFloat(document.getElementById('backEmis').value),
	envMapIntensity:0,
	metalness: parseFloat(document.getElementById('metal').value),
	roughness: parseFloat(document.getElementById('rough').value),
	specularIntensity: parseFloat(document.getElementById('spec').value),
	side: THREE.FrontSide,
	polygonOffset: true,
	polygonOffsetFactor: -4,
	polygonOffsetUnits: -4
  });
  backMesh = new THREE.Mesh(geo.clone(), backMat);
  backMesh.rotation.y = Math.PI;
  const depth = Math.max(0, parseFloat(document.getElementById('thick').value||0));
  backMesh.position.set(0,0, depth>0 ? -depth-0.0005 : -0.02);
  backMesh.layers.enable(BLOOM_LAYER);
  group.add(backMesh);

  if(depth>0){
	const boxGeo=new THREE.BoxGeometry(WIDTH,HEIGHT,depth);
	const sideMat=new THREE.MeshPhysicalMaterial({
	  color:0x121214, emissive:0xffffff,
	  emissiveIntensity: parseFloat(document.getElementById('backEmis').value),
	  metalness: parseFloat(document.getElementById('metal').value),
	  roughness: parseFloat(document.getElementById('rough').value),
	  specularIntensity: parseFloat(document.getElementById('spec').value),
	  side: THREE.DoubleSide
	});
	const invisible=new THREE.MeshBasicMaterial({ transparent:true, opacity:0, depthWrite:false, depthTest:false });
	sidesMesh=new THREE.Mesh(boxGeo,[sideMat,sideMat,sideMat,sideMat,invisible,invisible]);
	sidesMesh.position.set(0,0,-depth/2);
	sidesMesh.layers.enable(BLOOM_LAYER);
	group.add(sidesMesh);
  }

  updateFocusRanges();
  try{ if (globalThis.TedEnv && TedEnv.refreshFromUI) TedEnv.refreshFromUI(); }catch(e){}
}

try { window.createOrUpdatePhotoMesh = createOrUpdatePhotoMesh; } catch(_){}

	// Prevent OrbitControls from fighting cylindrical mode
	function syncControlsForMode(){
	  const isCyl = (cylMode && cylMode.checked);
	  if (controls){
	controls.enableRotate = !isCyl;
	controls.enableZoom   = !isCyl;
	controls.enablePan    = true;
	  }
	}
	syncControlsForMode();
	if (cylMode){ cylMode.addEventListener('change', syncControlsForMode); }

	// ===== Adaptive Highâ€‘Res Loader (keeps earlier "upright" behavior) =====
	function getMaxTexDim(){ if(maxTexAuto && maxTexAuto.checked){ return Math.max(2048, window.__HW_MAX_TEX__||8192); } const v = parseInt(maxTexN?.value||'8192',10); const hw = Math.max(2048, window.__HW_MAX_TEX__||16384); return Math.min(Math.max(2048,v||8192), hw); }
	async function loadTextureFromFile(file){
	  try{
		let bmp;
		if('createImageBitmap' in window){ bmp = await createImageBitmap(file); }
		else { bmp = await new Promise((res,rej)=>{ const img=new Image(); img.onload=()=>res(img); img.onerror=rej; img.src=URL.createObjectURL(file); }); }
		
		// Capture original dimensions before any scaling
		const origWidth = bmp.width;
		const origHeight = bmp.height;
		const maxDim = getMaxTexDim();
		const scale = Math.min(1, maxDim/Math.max(origWidth, origHeight));
		
		// ALWAYS convert to canvas (even when scale >= 1) to avoid ImageBitmap serialization issues
		const c = document.createElement('canvas');
		c.width = (scale >= 1) ? origWidth : Math.round(origWidth * scale);
		c.height = (scale >= 1) ? origHeight : Math.round(origHeight * scale);
		const ctx = c.getContext('2d', {alpha:false});
		ctx.imageSmoothingEnabled = true;
		ctx.imageSmoothingQuality = 'high';
		ctx.drawImage(bmp, 0, 0, c.width, c.height);
		
		// Create texture from canvas
		let tex = new THREE.CanvasTexture(c);
		
		// Match previously working build: upright on +Z plane
		tex.flipY = false;
		tex.colorSpace=THREE.SRGBColorSpace; 
		tex.needsUpdate=true; 
		tex.generateMipmaps=true;
		tex.minFilter=THREE.LinearMipmapLinearFilter; 
		tex.magFilter=THREE.LinearFilter;
		tex.wrapS=THREE.ClampToEdgeWrapping; 
		tex.wrapT=THREE.ClampToEdgeWrapping;
		const aniso=(renderer.capabilities.getMaxAnisotropy && renderer.capabilities.getMaxAnisotropy()) || renderer.capabilities.maxAnisotropy || 1; 
		tex.anisotropy=aniso;
		
		// Return all the data including original dimensions
		return { 
		  texture: tex, 
		  aspect: (origWidth/origHeight),
		  width: origWidth,
		  height: origHeight
		};
	  }catch(err){ 
		console.error(err); 
		throw err; 
	  }
	}
	// CRITICAL: Expose loadTextureFromFile globally for deck code
	window.loadTextureFromFile = loadTextureFromFile;
	globalThis.loadTextureFromFile = loadTextureFromFile;
	console.log('[TEXTURE] loadTextureFromFile exposed globally');

	// ===== Paths & cylindrical preview (minimal paths kept) =====
	const Easings={ constant:t=>t, easeIn:t=>t*t*(1.5-t), easeOut:t=>1-Math.pow(1-t,2), easeInOut:t=>0.5*(1-Math.cos(Math.PI*t)) };
	let playing=false, startTime=0, durationMs=30000;
	let phi0=0, r0=2, elev0=0;
	
	// Pre-playback state for custom paths (to restore after preview)
	let __prePlaybackState = null;
	
	function __savePrePlaybackState() {
		const cameraWorldPos = new THREE.Vector3();
		camera.getWorldPosition(cameraWorldPos);
		__prePlaybackState = {
			cameraPos: cameraWorldPos.clone(),
			focus: focus.clone(),
			fov: camera.fov,
			deckIdx: globalThis.deckIndex || 0
		};
	}
	
	function __restorePrePlaybackState() {
		if (!__prePlaybackState) return;
		
		// Restore camera position relative to focus
		focus.copy(__prePlaybackState.focus);
		pivot.position.copy(focus);
		
		const offset = __prePlaybackState.cameraPos.clone().sub(focus);
		camera.position.copy(offset); // Position relative to pivot
		camera.fov = __prePlaybackState.fov;
		camera.updateProjectionMatrix();
		camera.lookAt(new THREE.Vector3(0, 0, 0)); // Look at pivot origin (which is at focus)
		
		// Sync OrbitControls
		const t = safeTarget();
		if (t) t.copy(focus);
		if (controls) controls.update();
		
		// Restore deck index if needed (use crossfadeTo with 0ms for instant switch)
		if (typeof globalThis.__deck_crossfadeTo === 'function' && __prePlaybackState.deckIdx !== globalThis.deckIndex) {
			globalThis.__deck_crossfadeTo(__prePlaybackState.deckIdx, 0);
		}
		
		__prePlaybackState = null;
	}
	
	function __applyEndOfPathState() {
		// Set camera to the final position of the path
		if (!cinematicPathCheckpoints || cinematicPathCheckpoints.length < 1) return;
		
		const lastCp = cinematicPathCheckpoints[cinematicPathCheckpoints.length - 1];
		
		focus.copy(lastCp.focus);
		pivot.position.copy(focus);
		
		camera.position.copy(lastCp.offset); // Position relative to pivot
		camera.fov = lastCp.fov;
		camera.updateProjectionMatrix();
		camera.lookAt(new THREE.Vector3(0, 0, 0));
		
		// Sync OrbitControls
		const t = safeTarget();
		if (t) t.copy(focus);
		if (controls) controls.update();
		
		// Set deck to final image (use crossfadeTo with 0ms for instant switch)
		if (typeof globalThis.__deck_crossfadeTo === 'function' && lastCp.deckIdx !== globalThis.deckIndex) {
			globalThis.__deck_crossfadeTo(lastCp.deckIdx, 0);
		}
		
		__prePlaybackState = null;
	}
	function capturePreviewAnchor(){
	  const c = cylFromCamera();
	  phi0 = c.phi; r0 = c.r; elev0 = c.elev;
	}
	function computeCameraPose(t){
	  const toRad = THREE.MathUtils.degToRad;
	  const hfovFromVFOV = (vfov, aspect)=> 2*Math.atan(Math.tan(vfov/2)*aspect);
	  const vNeededFor = (L, widthEff, height, aspect)=>{
	const vH = 2*Math.atan((height*0.5)/L);
	const hNeeded = 2*Math.atan((widthEff*0.5)/L);
	const vFromH = 2*Math.atan(Math.tan(hNeeded/2)/Math.max(1e-6, aspect));
	return Math.max(vH, vFromH);
	  };
	  const ease = Easings[easeSel.value]??Easings.easeInOut; const tt = ease(t);
	  const minD = parseFloat(document.getElementById('minDist').value), maxD = parseFloat(document.getElementById('maxDist').value);
	  const fovAdeg = parseFloat(document.getElementById('fovMin').value), fovBdeg = parseFloat(document.getElementById('fovMax').value);
	  const fovA = toRad(Math.min(fovAdeg, fovBdeg)), fovB = toRad(Math.max(fovAdeg, fovBdeg));
	  const yawA = THREE.MathUtils.degToRad(parseFloat(document.getElementById('yawAmp').value||0));
	  const pitchA = THREE.MathUtils.degToRad(parseFloat(document.getElementById('pitchAmp').value||0));
	  const aspect = Math.max(1e-6, camera.aspect);
	  const SPAN = Math.max(0.0001, parseFloat(document.getElementById('maxDist').value)-parseFloat(document.getElementById('minDist').value));

	  let dPhi=0, dR=0, dElev=0, fovMix=0.5;
	  switch(pathSel.value){
	case 'orbit360':{
	  dPhi = 2*Math.PI*1*tt;
	  dR   = 0.12*SPAN*Math.sin(tt*Math.PI*2);
	  dElev= 0;
	  fovMix = (Math.sin(tt*Math.PI*2)+1)/2*0.5+0.25;
	  break;
	}
	case 'heliOrbit': {
	  dPhi = 2 * Math.PI * tt;
	  dR = 0.1 * SPAN * Math.sin(tt * Math.PI * 2);
	  dElev = pitchA * (tt * 2 - 1); // Linear elevation change
	  fovMix = (Math.sin(tt * Math.PI * 2) + 1) / 2 * 0.5 + 0.25;
	  break;
	}
	case 'lissajous': {
	  dPhi = yawA * Math.sin(tt * Math.PI * 4);
	  dR = 0.15 * SPAN * Math.sin(tt * Math.PI * 6);
	  dElev = pitchA * Math.sin(tt * Math.PI * 2);
	  fovMix = (Math.sin(tt * Math.PI * 2) + 1) / 2;
	  break;
	}
	case 'orbitArc': {
	  dPhi = yawA * (tt * 2 - 1); // Sweep from -yawA to +yawA
	  dR = 0.25 * SPAN * Math.sin(tt * Math.PI); // Gentle dolly in/out
	  dElev = pitchA * Math.sin(tt * Math.PI);
	  fovMix = 0.4 + 0.2 * Math.sin(tt * Math.PI);
	  break;
	}
	case 'dollyReveal':{
	  dPhi = Math.sin(tt*Math.PI)*yawA*0.6;
	  dR   = -0.55*SPAN*(1-Math.cos(Math.PI*tt));
	  dElev= 0;
	  fovMix = 0.35 + 0.55*(1-tt);
	  break;
	}
	case 'figure8': {
	  dPhi = yawA * Math.sin(tt * Math.PI * 2); // Two lobes for yaw
	  dR = 0.2 * SPAN * Math.sin(tt * Math.PI * 4); // Fast in/out dolly
	  dElev = pitchA * Math.sin(tt * Math.PI);
	  fovMix = 0.5 + 0.2 * Math.sin(tt * Math.PI * 2);
	  break;
	}
	case 'sCurve': {
	  dPhi = yawA * Math.sin(tt * Math.PI);
	  dR = -0.5 * SPAN * (tt * 2 - 1); // Dolly from far to near
	  dElev = 0;
	  fovMix = 1.0 - tt;
	  break;
	}
	case 'spiralInOut': {
	  dPhi = 3 * Math.PI * tt; // Multiple rotations
	  dR = (SPAN / 2) * Math.sin(tt * Math.PI); // Dolly in then out
	  dElev = pitchA * Math.cos(tt * Math.PI) * 0.5;
	  fovMix = 0.5 + 0.5 * Math.sin(tt * Math.PI);
	  break;
	}
	default:{ dPhi=0; dR=0; dElev=0; fovMix=0.5; }
	  }

	  let phi = phi0 + dPhi;
	  let rBase = THREE.MathUtils.clamp(r0 + dR, minD, maxD);
	  let elevR = elev0 + dElev;
	  let vfov = THREE.MathUtils.lerp(fovA, fovB, THREE.MathUtils.clamp(fovMix,0,1));

	  const widthEff = 1 * Math.abs(Math.cos(phi % (2*Math.PI)));
	  const LminA = Math.max( ( (1/Math.max(1e-9, photoAspect))*0.5 )/Math.tan(vfov/2), (widthEff*0.5)/Math.tan(hfovFromVFOV(vfov, aspect)/2) );
	  let rNeeded = Math.sqrt(Math.max(0, LminA*LminA - elevR*elevR));
	  let r = Math.max(rBase, rNeeded, minD);
	  if(r > maxD){
	const Ltarget = Math.sqrt(maxD*maxD + elevR*elevR);
	const vNeed = vNeededFor(Ltarget, widthEff, 1/Math.max(1e-9, photoAspect), aspect);
	const vfovTry = Math.min(fovB, Math.max(vfov, vNeed));
	const LminB = Math.max( ( (1/Math.max(1e-9, photoAspect))*0.5 )/Math.tan(vfovTry/2), (widthEff*0.5)/Math.tan(hfovFromVFOV(vfovTry, aspect)/2) );
	const rNeeded2 = Math.sqrt(Math.max(0, LminB*LminB - elevR*elevR));
	if(rNeeded2 <= maxD){ vfov = vfovTry; r = Math.max(minD, Math.min(maxD, Math.max(rBase, rNeeded2))); }
	else { vfov = vfovTry; r = Math.min(rNeeded2, maxD*1.08); }
	  }
	  return { phi, r, elev: elevR, fov: THREE.MathUtils.radToDeg(vfov) };
	}

	// ===== Manual Interaction (cylindrical, worldâ€‘space aware) =====
	const WORLD_UP = new THREE.Vector3(0,1,0);
	const tmpWorld = new THREE.Vector3();

	function cylFromCamera(){
	  camera.getWorldPosition(tmpWorld);            // read WORLD position
	  const rel = tmpWorld.clone().sub(focus);
	  const phi = Math.atan2(rel.x, rel.z);
	  const r   = Math.max(0.001, Math.hypot(rel.x, rel.z));
	  const elev= rel.y;
	  return {phi, r, elev};
	}

	function applyRig(phi, r, elev, fovDeg=null){
	  pivot.position.copy(focus);
	  pivot.rotation.set(0, phi, 0);
	  camera.position.set(0, elev, r); // local to pivot
	  camera.up.copy(WORLD_UP);
	  camera.lookAt(pivot.position);
	  if(fovDeg!=null){ camera.fov = fovDeg; camera.updateProjectionMatrix(); }
	}
	
	// --- PASTE THESE TWO LINES HERE ---
	window.applyRig = applyRig;
	window.cylFromCamera = cylFromCamera;
	
// --- Home pose snapshot (for double-click reset) ---
let __HOMEPOSE__ = null;
function snapshotHome(){
  try{ const c = cylFromCamera(); __HOMEPOSE__ = {phi:c.phi, r:c.r, elev:c.elev, fov: camera.fov}; }catch(_){}
}
setTimeout(()=>{ if(!__HOMEPOSE__) snapshotHome(); }, 0);

// Hard reset: center focus, restore home pose, clear sticky/latches

function hardReset(){
  try{ suppressPanLock = true; }catch(_){}
  try{ window.__orbitLatched = false; }catch(_){}
  try{ if (typeof panActive!=='undefined') panActive=false; }catch(_){}
  try{ if (typeof panOverride!=='undefined') panOverride=false; }catch(_){}
  try{ if(controls) controls.enabled = true; }catch(_){}
  try{ focus.set(0,0,0); }catch(_){}
  try{ if (controls && controls.target){ controls.target.set(0,0,0); controls.update?.(); } }catch(_){}
  try{
	if (typeof frameFrontOfPhoto === 'function'){
	  frameFrontOfPhoto(0.02); // recompute r + enforce phi=0, elev=0
	} else {
	  // Fallback: compute a front-on fit manually using actual mesh dimensions
	  const PIXEL_SCALE = 0.00025;
	  const useNativeDimensions = (typeof window.photoWidth === 'number' && typeof window.photoHeight === 'number');
	  
	  let WIDTH, HEIGHT;
	  if (useNativeDimensions) {
	    WIDTH = window.photoWidth * PIXEL_SCALE;
	    HEIGHT = window.photoHeight * PIXEL_SCALE;
	  } else {
	    WIDTH = 1;
	    HEIGHT = 1/(photoAspect||1);
	  }
	  
	  const vfov = (camera.fov||50) * Math.PI/180;
	  const aspect = camera.aspect || 1;
	  const hfov = 2*Math.atan(Math.tan(vfov/2) * aspect);
	  const needZForH = (HEIGHT/2) / Math.tan(vfov/2);
	  const needZForW = (WIDTH/2)  / Math.tan(hfov/2);
	  const r = Math.max(needZForH, needZForW) * 1.02;
	  applyRig(0, r, 0, camera.fov);
	}
  }catch(_){}
  try{ updateFocusInputs({syncControls:true}); }catch(_){}
  requestAnimationFrame(()=>{ try{ suppressPanLock = false; }catch(_){} });
}

let startX=0, startY=0; let orbitRotating=false, cylRotating=false;
	const startVec = new THREE.Vector3();
	const startSph = new THREE.Spherical();
	let startPhi=0, startElev=0, dragR=1; const PHI_SENS=0.005; const ELEV_SENS=0.005; const YAW_SENS=0.005; const PITCH_SENS=0.005; const EPS=0.01;

	// DELETE the existing applyCylFromStart function.
	// REPLACE the existing applyOrbitFromStart function with this new unified version.
	
	function applyOrbitFromStart(dx, dy) {
	  const yawSign = -1;
	  const pitchSign = (invertPitch && invertPitch.checked) ? -1 : 1;
	
	  // Set from the world-space vector captured at the start of the drag
	  startSph.setFromVector3(startVec);
	
	  // --- SPEED SCALING (from original cylindrical function) ---
	  let scale = 1.0;
	  if (enableSpeedScale.checked) {
		const power = parseFloat(speedScalePower.value);
		// Use the radius from the spherical coordinate as the distance
		scale = Math.pow(Math.max(0.1, startSph.radius), power) * 0.75;
	  }
	  // --- END SCALING ---
	
	  const theta = startSph.theta + dx * YAW_SENS * yawSign * scale;
	  const phi = THREE.MathUtils.clamp(startSph.phi + dy * PITCH_SENS * pitchSign * scale, EPS, Math.PI - EPS);
	
	  // Calculate the new world-space position
	  const v = new THREE.Vector3().setFromSpherical(new THREE.Spherical(startSph.radius, phi, theta));
	  camera.position.copy(focus).add(v);
	  
	  // Always look at the focus point
	  camera.up.copy(WORLD_UP);
	  camera.lookAt(focus);
	}



	


	// // Wheel â†’ radial zoom with smooth inertia (preserve Ï† and elevation exactly)
let __wheelZoomRAF=null, __wheelZoomVel=0, __wheelLastT=0;
// FIX: Track whether zoom started with camera on pivot (persists across frames)
let __wheelZoomStartedOnPivot = false;
// Replace the entire __wheelZoomStep function around line 1258

function __wheelZoomStep(t){
	// CHECK: Did external code (like prepareForZoom) kill our velocity?
	if (window.__wheelZoomKilled) {
		__wheelZoomVel = 0;
		cancelAnimationFrame(__wheelZoomRAF);
		__wheelZoomRAF = null;
		__wheelLastT = 0;
		__wheelZoomStartedOnPivot = false;
		window.__wheelZoomKilled = false;
		return;
	}
	
	if(!__wheelLastT){ __wheelLastT = t; }
	const dt = Math.max(0, Math.min(100, t - __wheelLastT));
	__wheelLastT = t;
	const pct = getZoomPct();
	const per = 1 + (pct/100);
	const frames = (dt / 16.7) * Math.abs(__wheelZoomVel);
	const sgn = (__wheelZoomVel >= 0) ? 1 : -1;
	const factor = Math.pow(per, frames*sgn);
	// --- add at the top of __wheelZoomStep, after computing `factor` ---
	const __sticky = !!window.__orbitLatched;
	

	const minDEl = document.getElementById('minDist');
	const maxDEl = document.getElementById('maxDist');
	const minD = parseFloat((minDEl && minDEl.value) || '0.01');
	const maxD = parseFloat((maxDEl && maxDEl.value) || '100');

	const currentlyOnPivot = (camera.parent === pivot);
	
	// Only detach if actually on pivot
	if (currentlyOnPivot) {
		scene.attach(camera);
	}

	const viewVector = new THREE.Vector3();
	viewVector.copy(focus).sub(camera.position).normalize();
	const currentDist = camera.position.distanceTo(focus);
	const newDist = THREE.MathUtils.clamp(currentDist * factor, minD, maxD);
	
	if (Math.abs(currentDist - newDist) > 1e-6) {
		const moveDist = currentDist - newDist;
		camera.position.addScaledVector(viewVector, moveDist);
		// âœ… keep sticky-orbitâ€™s baseline in sync with the new radius
		// AFTER (safe)
		if (window.__orbitLatched || orbitRotating) { try { startVec.copy(camera.position).sub(focus); } catch(_) {} }

	}

	__wheelZoomVel *= 0.92;

	if (Math.abs(__wheelZoomVel) < 0.01){
		// Cleanup
		if (isMobileDevice) {
		  // MOBILE FIX: Always ensure controls are enabled after zoom
		  // This prevents the freeze issue on mobile devices
		  try { if (controls) controls.enabled = true; } catch (_) {}
		} else if (window.__orbitLatched || orbitRotating) {
		  // Orbit is active: prime the next orbit move with a fresh baseline, don't do full cleanup
		  try { startVec.copy(camera.position).sub(focus); } catch (_) {}
		  try { if (controls) controls.enabled = false; } catch (_) {}
		} else if (__wheelZoomStartedOnPivot) {
		  // Desktop normal mode: full cleanup (uses the flag from when zoom STARTED)
		  _endAndCleanupOrbit();
		}

		
		cancelAnimationFrame(__wheelZoomRAF);
		__wheelZoomRAF = null;
		__wheelLastT = 0;
		__wheelZoomVel = 0;  // Explicitly reset velocity
		__wheelZoomStartedOnPivot = false;  // Reset the flag
		return;
	}
	__wheelZoomRAF = requestAnimationFrame(__wheelZoomStep);
}
// Replace the entire canvas.addEventListener('wheel', ...) block around line 1335

// Replace the canvas.addEventListener('wheel', ...) block around line 1358
// with this updated version.

canvas.addEventListener('wheel', (e)=>{
  // MOBILE FIX: On mobile, let OrbitControls handle zoom via native touch events
  // Don't intercept wheel events which might be synthesized from touch gestures
  if (isMobileDevice) {
    return; // Let OrbitControls handle it
  }
  
  // Check for pan, playing, OR sticky orbit
  const panOrPlaying = (typeof panActive !== 'undefined' && panActive) || (typeof playing !== 'undefined' && playing);
  const isStickyOrbiting = window.__orbitLatched;

  if (panOrPlaying || isStickyOrbiting) { // If panning, playing, or sticky orbiting...
	e.preventDefault();
	const dir = Math.sign(e.deltaY || 0);
	if (dir !== 0){
	  __wheelZoomVel = Math.max(-3, Math.min(3, __wheelZoomVel + dir * 0.6));
	  if(!__wheelZoomRAF){
		// FIX: Capture whether camera is on pivot when zoom STARTS (even in pan/orbit mode)
		__wheelZoomStartedOnPivot = (camera.parent === pivot);
		// For pan/play/orbit, we do NOT detach the camera. The zoom logic will handle it.
		__wheelZoomRAF = requestAnimationFrame(__wheelZoomStep);
	  }
	}
	return;
  }

  // This is the fallback logic for default mode zoom (when NOT panning or sticky orbiting)
  
  // Default mode zoom (when NOT panning, playing, or sticky orbiting)
  e.preventDefault();
  const dir = Math.sign(e.deltaY || 0);
  if (dir !== 0){
	__wheelZoomVel = Math.max(-3, Math.min(3, __wheelZoomVel + dir * 0.6));
	if (!__wheelZoomRAF){
	  // FIX: Capture whether camera is on pivot when zoom STARTS
	  __wheelZoomStartedOnPivot = (camera.parent === pivot);
	  __wheelZoomRAF = requestAnimationFrame(__wheelZoomStep);
	}
  }


}, { passive:false });

	// Shift+Click to set focus on the photo
	canvas.addEventListener('pointerdown', (e)=>{
	  if(!e.shiftKey || !photoMesh) return;
	  const rect=canvas.getBoundingClientRect(); const ndc=new THREE.Vector2();
	  ndc.x=((e.clientX-rect.left)/rect.width)*2-1; ndc.y=-((e.clientY-rect.top)/rect.height)*2+1;
	  raycaster.setFromCamera(ndc,camera); const hit=raycaster.intersectObject(photoMesh,true)[0]; if(hit){ focus.copy(hit.point); updateFocusInputs({syncControls:true}); }
	});

	// Pan updates focus via OrbitControls target (optional)
	let prevTarget = null; const initPrevTarget = ()=>{ const t=safeTarget(); prevTarget = t? t.clone() : focus.clone(); }; initPrevTarget();
	if(controls){
	  controls.addEventListener('change', ()=>{
	if(playing) return;
	const t=safeTarget(); if(!t){ return; }
	if(!prevTarget || !isVec3(prevTarget)){ prevTarget = t.clone(); return; }
	if(panLocksFocus && panLocksFocus.checked){
	  // Skip while we're programmatically panning (Alt clutch) to avoid jitter
	  if (suppressPanLock || performance.now() < suppressPanLockUntil){ prevTarget.copy(t); return; }
	  const dx = (t?.x ?? 0) - (prevTarget?.x ?? 0);
	  const dy = (t?.y ?? 0) - (prevTarget?.y ?? 0);
	  if(dx*dx + dy*dy > 0){ focus.set(focus.x + dx, focus.y + dy, 0); updateFocusInputs({syncControls:true}); }
	}
	prevTarget.copy(t);
	if((cylMode && cylMode.checked)) t.copy(focus);
	  });
	}

	function darkenNonBloomed(obj) {
	if (obj.isMesh && bloomLayer.test(obj.layers) === false) {
		materials[obj.uuid] = obj.material;
		obj.material = darkMaterial;
	}
	}

	function restoreMaterial(obj) {
	if (materials[obj.uuid]) {
		obj.material = materials[obj.uuid];
		delete materials[obj.uuid];
	}
	}

	// Main loop
	function animate(){
	  requestAnimationFrame(animate);

	  // Animate starfield
	  if (starfield) {
	starfield.rotation.y -= 0.0001;
	  }

	  // Update light positions for shaders
	  if ((flarePass && flarePass.enabled || godRaysPass && godRaysPass.enabled) && flareLight) {
	  const screenPos = new THREE.Vector3();
	  flareLight.getWorldPosition(screenPos);
	  screenPos.project(camera);
	  if (flarePass) flarePass.uniforms.uLightPositionNDC.value.copy(screenPos);
	  if (godRaysPass) godRaysPass.uniforms.uLightPositionNDC.value.set(screenPos.x * 0.5 + 0.5, screenPos.y * 0.5 + 0.5);
	  }

	// Tone mapping selector (sticky for manual changes)
	if(!window.__tm_setup__){ window.__tm_setup__=true;
	const toneMapSel = document.getElementById('toneMapSel');
	function applyToneMapChoice(v){
	if (!finalPass) return;
	if(v==='aces'){ finalPass.uniforms.toneMappingType.value = 3; }
	else if(v==='reinhard'){ finalPass.uniforms.toneMappingType.value = 2; }
	else if(v==='linear'){ finalPass.uniforms.toneMappingType.value = 1; }
	else { finalPass.uniforms.toneMappingType.value = 0; }
	}
	if(toneMapSel){
	  // Load sticky
	  try{ const saved = localStorage.getItem('toneMapSel') || 'linear'; toneMapSel.value = saved; }catch(_){ toneMapSel.value = 'linear'; }
	  // Apply choice (only if not overridden by a Photo Reset)
	  applyToneMapChoice(toneMapSel.value);
	  toneMapSel.addEventListener('change', ()=>{
	const v = toneMapSel.value;
	applyToneMapChoice(v);
	try{ localStorage.setItem('toneMapSel', v); }catch(_){}
	  });
	} }
	
	// MOBILE FIX: Force controls to stay enabled on mobile devices
	// This prevents any stray code from disabling touch interaction
	if (isMobileDevice && controls && !playing) {
	  // Clear stuck states
	  if (window.__orbitLatched) window.__orbitLatched = false;
	  if (panActive && !leftDown && !rightDown) panActive = false;
	  
	  // Ensure controls are enabled
	  if (!controls.enabled) {
		controls.enabled = true;
	  }
	}
	
	if (controls && controls.enabled && !panActive) {
	  const t = safeTarget(); if (t) t.copy(focus);
	  controls.update();
	}
	  if(pivot && !panActive){ pivot.position.copy(focus); }
	  
	if(playing){
	const elapsedTime = performance.now() - startTime;
	const isFinished = elapsedTime >= durationMs;
	
	// --- Fade in/out controller (2s each) - ONLY during recording ---
	// During preview: skip fade, show full image immediately
	// During recording: apply fade in/out for final video
	const isActuallyRecording = recorder && recorder.state === 'recording';
	const fadeMs = 2000; // 2 second fade duration
	
	// Calculate fade alpha
	let __fadeAlpha = 1.0;
	if (isActuallyRecording) {
	  const fin = Math.min(1, Math.max(0, elapsedTime / fadeMs));
	  const fout = Math.min(1, Math.max(0, (durationMs - elapsedTime) / fadeMs));
	  __fadeAlpha = Math.min(fin, fout);
	}
	
	// Calculate motion time - during recording, motion only happens AFTER fade-in completes
	// and stops BEFORE fade-out begins
	let linearTime;
	if (isActuallyRecording) {
	  // Effective motion duration = total - fadeIn - fadeOut
	  const motionDuration = durationMs - (fadeMs * 2);
	  const motionStart = fadeMs;
	  const motionEnd = durationMs - fadeMs;
	  
	  if (elapsedTime < motionStart) {
	    // During fade-in: hold at start position
	    linearTime = 0;
	  } else if (elapsedTime > motionEnd) {
	    // During fade-out: hold at end position
	    linearTime = 1;
	  } else {
	    // During motion: map elapsed time to 0-1
	    linearTime = (elapsedTime - motionStart) / motionDuration;
	  }
	} else {
	  // Preview: normal linear time (no hold periods)
	  linearTime = isFinished ? 1.0 : elapsedTime / durationMs;
	}
	
	// Apply fade to uniforms and materials
	if (fadeUniform && !globalThis.__crossfadeActive) {
	  fadeUniform.value = __fadeAlpha;
	  
	  // Fade photo mesh
	  if (photoMesh && photoMesh.material){
	    if (!photoMesh.material.transparent) { photoMesh.material.transparent = true; photoMesh.material.needsUpdate = true; }
	    photoMesh.material.opacity = __fadeAlpha;
	  }
	  if (photoCoat && photoCoat.material){
	    if (!photoCoat.material.transparent) { photoCoat.material.transparent = true; photoCoat.material.needsUpdate = true; }
	    photoCoat.material.opacity = __fadeAlpha;
	  }
	  
	  // Fade the sun/star light source - this ensures true black at fade boundaries
	  const flareStar = scene.getObjectByName('flareStar');
	  if (flareStar && flareStar.material) {
	    if (!flareStar.material.transparent) { flareStar.material.transparent = true; flareStar.material.needsUpdate = true; }
	    flareStar.material.opacity = __fadeAlpha;
	  }
	  if (flareLight) {
	    // Also dim the actual light intensity
	    flareLight.intensity = 2.5 * __fadeAlpha;
	  }
	}
	

	if (pathSel.value === 'customPath' && cinematicPathCheckpoints && cinematicPathCheckpoints.length >= 2) {
		// ============================================
		// UNIFIED PLAYBACK SYSTEM
		// ============================================
		// All path playback goes through getUnifiedPathPose() which handles:
		// - Timing-based segment progression
		// - Speedramp zones with extreme easing
		// - Per-segment smoothing
		// Then butter smoothing is applied for final gimbal-like polish
		
		const ease = Easings[easeSel.value] ?? Easings.easeInOut;
		const easedTime = ease(linearTime);
		
		// Get the raw pose from unified system
		const rawPose = getUnifiedPathPose(easedTime);
		
		// Apply butter smoothing for gimbal-like motion
		let finalPose = rawPose;
		if (typeof applyButterSmoothing === 'function') {
			finalPose = applyButterSmoothing(rawPose.offset, rawPose.focus, rawPose.fov, easedTime);
			// Preserve deck info from raw pose
			finalPose.deckIdx = rawPose.deckIdx;
			finalPose.deckFadeMs = rawPose.deckFadeMs;
		}
		
		// Handle deck switching
		const want = finalPose.deckIdx;
		const fadeMs = finalPose.deckFadeMs || 600;
		const st = (globalThis.__deckByCheckpoint || (globalThis.__deckByCheckpoint = { idx: -1 }));
		if (want >= 0 && want !== st.idx && globalThis.__deck_crossfadeTo) {
			globalThis.__deck_crossfadeTo(want, fadeMs);
			st.idx = want;
		}
		
		// Apply final camera pose
		const newFocusPos = finalPose.focus;
		const newOffset = finalPose.offset;
		const newFov = finalPose.fov;
		
		camera.position.copy(newFocusPos.clone().add(newOffset));
		focus.copy(newFocusPos);
		camera.fov = newFov;
		camera.updateProjectionMatrix();
		camera.up.set(0, 1, 0);
		camera.lookAt(newFocusPos);
		
		const t = safeTarget();
		if (t) t.copy(newFocusPos);
		
		// Update progress display
		if (pathProgressDisplay && cinematicPathCheckpoints.length > 0) {
			const pct = Math.round(easedTime * 100);
			pathProgressDisplay.textContent = `Playback: ${pct}%`;
		}
		
	} else {
		const desired = computeCameraPose(linearTime);
		applyRig(desired.phi, desired.r, desired.elev, desired.fov);
	}

	if (isFinished) {
		stopPlayback();
		if(recorder && recorder.state==='recording') stopRecording();
	}
	}
	  
	  // Occlusion pass for God Rays
	  if (godRaysPass && godRaysPass.enabled) {
	const flareStar = scene.getObjectByName('flareStar');
	const wasVisible = flareStar ? flareStar.visible : false;
	if (flareStar) flareStar.visible = false; // Hide the light source itself

	const currentRenderTarget = renderer.getRenderTarget();
	renderer.setRenderTarget(occlusionRenderTarget);
	renderer.clear();

	const originalBackground = scene.background;
	scene.background = null;

	scene.overrideMaterial = blackMaterial;
	
	const originalLayers = camera.layers.mask;
	camera.layers.set(BASE_LAYER); // Render only occluders on base layer

	renderer.render(scene, camera);

	camera.layers.mask = originalLayers; // Restore layers

	scene.overrideMaterial = null;
	scene.background = originalBackground;

	renderer.setRenderTarget(currentRenderTarget);

	if (flareStar) flareStar.visible = wasVisible; // Restore visibility

	// PASS 2: render bright sources (flare + stars) into occlusion RT
	// Goal: emulate the 3D model's "bright-pass" so rays have energy
	const __prevTarget = renderer.getRenderTarget();
	renderer.setRenderTarget(occlusionRenderTarget);
	// Do NOT clear; we want bright sources drawn over the black occluders we just wrote

	// Render only bright things
	const __prevLayers = camera.layers.mask;
	camera.layers.set(BLOOM_LAYER);

	const __prevOverride = scene.overrideMaterial;
	scene.overrideMaterial = null;

	// Ensure bright light sprite is visible
	if (flareStar) flareStar.visible = true;

	// Temporarily tweak starfield material to additive + low opacity for a softer occlusion
	const __sf = scene.getObjectByName('starfield');
	let __sfPrevMat = null;
	if (__sf && __sf.material) {
	  __sfPrevMat = __sf.material;
	  const __tmp = __sfPrevMat.clone();
	  __tmp.transparent = true;
	  __tmp.depthWrite = false;
	  __tmp.blending = THREE.AdditiveBlending;
	  __tmp.opacity = 0.10;
	  __sf.material = __tmp;
	}

	renderer.render(scene, camera);

	// Restore starfield material and state
	if (__sf && __sfPrevMat) { __sf.material = __sfPrevMat; }
	scene.overrideMaterial = __prevOverride;
	camera.layers.mask = __prevLayers;
	renderer.setRenderTarget(__prevTarget);
  
  // Build depth/occlusion mask so bloom/rays don't show through the PHOTO silhouette only
  {
	const currentTarget2 = renderer.getRenderTarget();
	const prevMask2 = camera.layers.mask;
	const prevOverride2 = scene.overrideMaterial;

	// Hide bright sprites so they don't punch holes in the mask
	const _flareStar = scene.getObjectByName('flareStar');
	const _starfield = scene.getObjectByName('starfield');
	const _hidden = [];
	if (_flareStar) { _hidden.push(_flareStar); _flareStar.visible = false; }
	if (_starfield) { _hidden.push(_starfield); _starfield.visible = false; }

	// Hide back/sides so they DON'T occlude (they would fill the whole screen)
	// Store their original visibility state
	const backMeshWasVisible = (typeof backMesh !== 'undefined' && backMesh) ? backMesh.visible : false;
	const sidesMeshWasVisible = (typeof sidesMesh !== 'undefined' && sidesMesh) ? sidesMesh.visible : false;
	if (backMesh) backMesh.visible = false;
	if (sidesMesh) sidesMesh.visible = false;

	// Ensure photo mesh is visible for silhouette
	const photoMeshWasVisible = (typeof photoMesh !== 'undefined' && photoMesh) ? photoMesh.visible : true;
	if (photoMesh) photoMesh.visible = true;

	renderer.setRenderTarget(depthMaskRT);
	renderer.setClearColor(0x000000, 1);
	renderer.clear(true, true, true);

	scene.overrideMaterial = maskMaterial;
	camera.layers.set(BASE_LAYER);
	renderer.render(scene, camera);

	// restore everything
	camera.layers.mask = prevMask2;
	scene.overrideMaterial = prevOverride2;
	renderer.setRenderTarget(currentTarget2);
	
	// Restore sprite visibility
	for (const o of _hidden) {
	  if (o) o.visible = true;
	}
	
	// Always restore frame visibility (fixes bug where frame disappears permanently)
	if (backMesh) backMesh.visible = true;
	if (sidesMesh) sidesMesh.visible = true;
	if (photoMesh) photoMesh.visible = photoMeshWasVisible;
  }


	  }

	// --- Render Pipeline ---
	renderer.clear();

	// 1. Render BLOOM layer
	camera.layers.set(BLOOM_LAYER);
	scene.traverse(darkenNonBloomed);
	bloomComposer.render();
	scene.traverse(restoreMaterial);

	// 2. Render BASE layer and combine
	camera.layers.set(BASE_LAYER);
	
if (fadeUniform && !playing && !globalThis.__crossfadeActive){ 
  fadeUniform.value = 1.0; 
  if (photoMesh && photoMesh.material){ photoMesh.material.opacity = 1.0; /* leave transparent=true ok */ }
  if (photoCoat && photoCoat.material){ photoCoat.material.opacity = 1.0; }
}

	finalComposer.render();
	
	// --- Draw photo base + coat last so post-FX stay behind
	try{
	  renderer.clearDepth();
	  if (photoMesh) renderer.render(photoMesh, camera);
	  if (photoCoat) renderer.render(photoCoat, camera);
	}catch(e){ console.warn('final overlay render failed', e); }
	}
	
	// Initial setup calls
	createStarfield();
	createFlareLight();
	setupPostProcessing();
	requestAnimationFrame(animate);

	function updateDuration(){ const sec=parseFloat(durationEl.value||30); durationN.value=sec; durationMs=Math.round(sec*1000); precomputeSpeedAdjustedPath(); }
	durationEl.addEventListener('input', updateDuration); durationN.addEventListener('input', ()=>{ durationEl.value=durationN.value; updateDuration(); }); updateDuration();

	function stopPlayback() {
	playing = false;
	if (pathProgressDisplay) {
		pathProgressDisplay.style.display = 'none';
	}

	// Restore full visibility after playback ends
	if (fadeUniform) fadeUniform.value = 1.0;
	if (photoMesh && photoMesh.material) {
		photoMesh.material.opacity = 1.0;
		photoMesh.material.needsUpdate = true;
	}
	if (photoCoat && photoCoat.material) {
		photoCoat.material.opacity = 1.0;
		photoCoat.material.needsUpdate = true;
	}
	// Restore sun/star visibility
	const flareStar = scene.getObjectByName('flareStar');
	if (flareStar && flareStar.material) {
		flareStar.material.opacity = 1.0;
		flareStar.material.needsUpdate = true;
	}
	if (flareLight) flareLight.intensity = 2.5; // Restore original intensity

	// After any kind of playback, re-attach the camera to the pivot
	// to restore normal manual control functionality.
	pivot.attach(camera);

	// For custom paths: restore camera to pre-playback position
	// This returns user to where they were before pressing Preview
	if (__prePlaybackState) {
		__restorePrePlaybackState();
	}

	if(controls){
		controls.enabled=true;
		controls.enablePan=true;
		const t=safeTarget();
		if(t) t.copy(focus);
	}
	}

	function startPreview(){ 
	  if (playing) return; // Guard against rapid clicks
	  try { __cancelInertia(); } catch(e) {} // Cancel any manual move inertia

	  if (pathSel.value === 'customPath') {
	if (!pathOffsetCurve) {
		alert('Please build a custom path first, or select a different flight path.');
		return;
	}
	if (pathProgressDisplay) {
		pathProgressDisplay.style.display = 'block';
	}

	// Save current camera state BEFORE detaching from pivot
	// This allows us to restore position after preview ends
	__savePrePlaybackState();

	// De-parent from pivot to allow setting world positions directly during playback.
	// This makes playback independent of the camera's state before clicking Preview.
	scene.attach(camera);

	// Now that camera is a child of the scene, set its initial world state from the path's start.
	if (cinematicPathCheckpoints.length > 0) {
		// Get the exact start position, focus, and FOV from the pre-calculated curves.
		const focusWorldPos = pathFocusCurve.getPointAt(0);
		const offsetWorldVec = pathOffsetCurve.getPointAt(0);
		const cameraWorldPos = focusWorldPos.clone().add(offsetWorldVec);
		const startFov = pathFovCurve.getPointAt(0).y;

		camera.position.copy(cameraWorldPos);
		focus.copy(focusWorldPos);
		camera.fov = startFov;
		camera.updateProjectionMatrix();
		camera.lookAt(focus);
		
		const t = safeTarget();
		if(t) t.copy(focus);
		if (controls) controls.update(); // Force OrbitControls to sync to the new state before disabling.
	}
	  } else {
	// For preset paths, ensure camera is attached to the pivot rig.
	pivot.attach(camera);

	if (pathProgressDisplay) {
		pathProgressDisplay.style.display = 'none';
	}
	capturePreviewAnchor(); 
	// Sync target for preset paths, as focus doesn't change here.
	const t = safeTarget();
	if (t) t.copy(focus);
	  }

	  
	// Start on checkpoint[0] image - use instant (0ms) switch so image is ready immediately
	{ const cps = (typeof cinematicPathCheckpoints!=='undefined') ? cinematicPathCheckpoints : null;
	  if (cps && cps.length) {
	    const cp0 = cps[0];
	    const idx0 = (cp0 && Number.isInteger(cp0.deckIdx)) ? cp0.deckIdx : -1;
	    // Always use 0ms for initial image - we want it ready before playback starts
	    if (idx0 >= 0 && globalThis.__deck_crossfadeTo) {
	      globalThis.__deck_crossfadeTo(idx0, 0); // Instant switch
	      globalThis.__deckByCheckpoint = { seg:0, idx: idx0 };
	    } else {
	      globalThis.__deckByCheckpoint = { seg:-1, idx:-1 };
	    }
	  }
	}
	
	// Ensure image is fully rendered before starting playback timer
	// This prevents the "fade in" appearance at the start of preview
	requestAnimationFrame(() => {
	  requestAnimationFrame(() => {
	    playing=true; 
	    startTime=performance.now(); 
	    if(controls){ controls.enablePan=false; controls.enabled=false; }
	  });
	});
	}
	previewBtn.addEventListener('click', startPreview);

	setRendererSize();

	// Recording (oversampled)
	let recorder=null, recordedChunks=[];
	function startRecording(){
	  if (pathSel.value === 'customPath' && !pathOffsetCurve) {
	alert('Please build and finish a custom path before recording.');
	return;
	  }
	  const base = setRendererSize();
	  const scale = parseFloat(exportScale?.value||'1')||1;
	  const {w,h,fps} = base;
	  renderer.setSize(Math.round(w*scale), Math.round(h*scale), false);
	  if (bloomComposer) bloomComposer.setSize(Math.round(w*scale), Math.round(h*scale));
	  if (finalComposer) finalComposer.setSize(Math.round(w*scale), Math.round(h*scale));
	  
	  // IMPORTANT: Set everything to black BEFORE starting the recorder
	  // This ensures the very first frame is pure black
	  if (fadeUniform) fadeUniform.value = 0;
	  if (photoMesh && photoMesh.material) {
	    photoMesh.material.transparent = true;
	    photoMesh.material.opacity = 0;
	    photoMesh.material.needsUpdate = true;
	  }
	  if (photoCoat && photoCoat.material) {
	    photoCoat.material.transparent = true;
	    photoCoat.material.opacity = 0;
	    photoCoat.material.needsUpdate = true;
	  }
	  // Hide the sun/star too
	  const flareStar = scene.getObjectByName('flareStar');
	  if (flareStar && flareStar.material) {
	    flareStar.material.transparent = true;
	    flareStar.material.opacity = 0;
	    flareStar.material.needsUpdate = true;
	  }
	  if (flareLight) flareLight.intensity = 0;
	  
	  // Render a black frame first
	  if (finalComposer) {
	    finalComposer.render();
	  } else {
	    renderer.render(scene, camera);
	  }
	  
	  const stream = canvas.captureStream(fps);
	  const types=[  'video/mp4;codecs="avc1.42E01E"',  'video/mp4;codecs="avc1.4D401E"',  'video/mp4;codecs="avc1.64001E"',  'video/webm;codecs=h264',  'video/webm;codecs=vp9',  'video/webm;codecs=vp8',  'video/webm']; let mime='';for(const m of types){ if(window.MediaRecorder && MediaRecorder.isTypeSupported(m)){ mime=m; break; } }
	  if(!window.MediaRecorder){ alert('MediaRecorder not supported in this browser.'); return; }
	  recorder=new MediaRecorder(stream,{ mimeType:mime||undefined, videoBitsPerSecond:12_000_000 }); recordedChunks=[];
	  recorder.ondataavailable=(e)=>{ if(e.data && e.data.size>0) recordedChunks.push(e.data); };
	  recorder.onstop=saveRecording; 
	  recorder.start(); 
	  overlay.style.display='flex'; 
	  if(controls){ controls.enabled=false; }
	  
	  // Wait a couple frames to ensure black frame is captured, then start playback
	  requestAnimationFrame(() => {
	    requestAnimationFrame(() => {
	      startPreview();
	    });
	  });
	}
	function stopRecording(){ 
	try{ recorder?.stop(); }catch(e){ console.warn(e); } 
	overlay.style.display='none';
	recordBtn.disabled=false;
	stopBtn.disabled=true;
	setRendererSize(); 
	}
	stopBtn.addEventListener('click', ()=>{
	stopRecording();
	stopPlayback();
	});

	function saveRecording(){ const blob=new Blob(recordedChunks,{ type:recorder.mimeType||'video/webm' }); const url=URL.createObjectURL(blob); const a=document.createElement('a'); const stamp=new Date().toISOString().replace(/[:.]/g,'-'); const ext=(recorder.mimeType||'video/webm').includes('mp4')?'mp4':'webm'; a.href=url; a.download=`portrait-flyby-${stamp}.${ext}`; document.body.appendChild(a); a.click(); URL.revokeObjectURL(url); a.remove(); }
	document.addEventListener('click', (e)=>{ if(e.target && e.target.id==='resetPhotoMode'){ applyNeutralNearPhotoDefaults(); } });

	recordBtn.addEventListener('click', ()=>{ if(!photoMesh){ alert('Please load a source image first.'); return; } startRecording(); recordBtn.disabled=true; stopBtn.disabled=false; });
	

	// Image loader
	fileInput.addEventListener('change', async ()=>{ 
	  const files = fileInput.files;
	  if(!files || files.length === 0) return;
	  
	  // If multiple files selected, let the deck handler take care of it
	  if (files.length > 1) {
		console.log('[single-file handler] Multiple files detected, skipping single-file handler');
		return;
	  }
	  
	  const file = files[0];
	  console.log('[single-file handler] Processing single file:', file.name);
	  
	  try{ 
		const result = await loadTextureFromFile(file); 
		photoTex = result.texture; 
		photoAspect = result.aspect; 
		window.photoWidth = result.width;
		window.photoHeight = result.height;
		console.log('[single-file handler] Loaded:', {width: result.width, height: result.height, aspect: result.aspect});
		createOrUpdatePhotoMesh(); 
		applyNeutralNearPhotoDefaults(); 
		recordBtn.disabled=false; 
	  }catch(err){ 
		console.error('[single-file handler] Error:', err); 
		alert('Failed to load image.'); 
	  } 
	});
	// Reset focus
	resetFocus.addEventListener('click', ()=>{
	  try{ suppressPanLock = true; }catch(_){}
	  
	  // 1. Get current camera distance BEFORE changing the focus or position.
	  let currentDistance = 5; // Default fallback distance
	  try {
	  const c = cylFromCamera();
	  currentDistance = c.r;
	  } catch(_) {}

	  // 2. Center focus at origin.
	  focus.set(0,0,0);
	  
	  // 3. Apply a front-on view (phi=0, elev=0) at the preserved distance.
	  applyRig(0, currentDistance, 0);

	  // 4. Sync UI, controls target, and OrbitControls internal state.
	  updateFocusInputs({syncControls:true});
	  try{ 
	  if (controls) {
		  controls.target.set(0,0,0); 
		  controls.update?.(); 
	  }
	  }catch(_){}

	  // Reset prevTarget so the change-listener doesn't apply a large delta
	  try{ if (typeof prevTarget!=='undefined' && controls && controls.target){ prevTarget = controls.target.clone(); } }catch(_){}
	  
	  // Re-anchor cylindrical reference so pan-lock doesn't mirror/flip
	  try{ if (typeof capturePreviewAnchor === 'function') capturePreviewAnchor(); }catch(_){}
	  requestAnimationFrame(()=>{ try{ suppressPanLock = false; }catch(_){} });
	});

	// New: Perpendicular button logic
	const perpendicularBtn = document.getElementById('perpendicularBtn');
	if (perpendicularBtn) {
	perpendicularBtn.addEventListener('click', () => {
		try {
			// 1. Get current camera distance from the current focus point.
			const c = cylFromCamera();
			const currentDistance = c.r;
	
			// 2. Apply a front-on view (phi=0, elev=0) at the preserved distance, keeping the current focus.
			applyRig(0, currentDistance, 0);
	
			// 3. Sync OrbitControls internal state without changing the target.
			if (controls) {
				controls.update?.();
				// Unlatch sticky-orbit if it was on, and do the unified cleanup.
				window.__orbitLatched = false;
				try { latchOrbit = false; } catch(_) {}
				if (typeof _endAndCleanupOrbit === 'function') _endAndCleanupOrbit();

			}
	
			// FIX: If we are in a sticky pan, we MUST refresh the pan baseline
			// to prevent a jump on the next mouse move.
			if (typeof panActive !== 'undefined' && panActive && typeof lastX !== 'undefined' && typeof startPanAt !== 'undefined') {
				startPanAt(lastX, lastY);
			}
		} catch (_) {}
	});
	}

	// --- Cinematic Path Builder Logic ---
	function updatePathControls() {
	const isCustom = pathSel.value === 'customPath';
	// Keep ease enabled for custom paths, as it affects timing
	// easeSel.disabled = isCustom; 
	[yawAmp, yawAmpN, pitchAmp, pitchAmpN, fovMin, fovMinN, fovMax, fovMaxN, minDist, minDistN, maxDist, maxDistN].forEach(el => {
		if (el) el.disabled = isCustom;
	});
	}

	pathSel.addEventListener('change', updatePathControls);

	function buildCustomPathCurves() {
	if (cinematicPathCheckpoints.length < 2) {
		pathOffsetCurve = null;
		pathFocusCurve = null;
		pathFovCurve = null;
		return;
	}

	const offsetPoints = [];
	const focusPoints = [];
	const fovPoints = [];

	for (let i = 0; i < cinematicPathCheckpoints.length; i++) {
		const cp = cinematicPathCheckpoints[i];
		offsetPoints.push(cp.offset);
		focusPoints.push(cp.focus);
		const progress = i / (cinematicPathCheckpoints.length - 1);
		fovPoints.push(new THREE.Vector2(progress, cp.fov));
	}
	
	const tension = parseFloat(pathTension.value);

	pathOffsetCurve = new THREE.CatmullRomCurve3(offsetPoints, false, 'centripetal', tension);
	pathFocusCurve = new THREE.CatmullRomCurve3(focusPoints, false, 'centripetal', tension);
	pathFovCurve = new THREE.SplineCurve(fovPoints);
	
	precomputeSpeedAdjustedPath();
	}

	function precomputeSpeedAdjustedPath() {
	if (!pathOffsetCurve || cinematicPathCheckpoints.length < 2) {
		pathTimeMap = null;
		return;
	}

	if (!enableSpeedScale.checked) {
		pathTimeMap = null; // Signal to use linear time
		return;
	}

	const power = parseFloat(speedScalePower.value);
	const samples = 200; // More samples for better accuracy
	pathTimeMap = [{ rawProgress: 0, scaledTime: 0 }]; // Start at t=0, time=0
	let cumulativeTime = 0;
	
	let lastCamPos = pathFocusCurve.getPointAt(0).clone().add(pathOffsetCurve.getPointAt(0));
	// We integrate time over the path's progress
	for (let i = 1; i <= samples; i++) {
		const t = i / samples;
		const currentCamPos = pathFocusCurve.getPointAt(t).clone().add(pathOffsetCurve.getPointAt(t));
		const segmentLength = currentCamPos.distanceTo(lastCamPos);
		lastCamPos.copy(currentCamPos);

		// Use the average distance to focus for the segment for better accuracy
		const mid_t = (t + (i-1)/samples) / 2;
		const midFocusPos = pathFocusCurve.getPointAt(mid_t);
		const midCamPos = midFocusPos.clone().add(pathOffsetCurve.getPointAt(mid_t));
		const distanceToFocus = midCamPos.distanceTo(midFocusPos);
		
		const speed = Math.pow(Math.max(0.1, distanceToFocus), power);
		
		const timeForSegment = (speed > 1e-6) ? segmentLength / speed : 0;
		cumulativeTime += timeForSegment;
		
		pathTimeMap.push({ rawProgress: t, scaledTime: cumulativeTime });
	}

	// Normalize the scaled time to create a 0-1 time map
	if (cumulativeTime > 0) {
		for (const point of pathTimeMap) {
			point.scaledTime /= cumulativeTime;
		}
	} else { // Handle zero-length or zero-time path
		pathTimeMap = null;
	}
	}
	
	function getScaledProgress(linearTime) {
	if (!pathTimeMap || !enableSpeedScale.checked) {
		return linearTime; // No map, so progress is linear
	}

	if (linearTime <= 0) return 0;
	if (linearTime >= 1) return 1;

	// Find the segment in the time map where the linearTime falls
	for (let i = 1; i < pathTimeMap.length; i++) {
		const prev = pathTimeMap[i - 1];
		const curr = pathTimeMap[i];
		if (curr.scaledTime >= linearTime) {
			const timeSegmentDuration = curr.scaledTime - prev.scaledTime;
			
			if (timeSegmentDuration < 1e-9) { // Avoid division by zero
				return curr.rawProgress;
			}
			
			const timeIntoSegment = linearTime - prev.scaledTime;
			const progressWithinSegment = timeIntoSegment / timeSegmentDuration;
			
			return prev.rawProgress + progressWithinSegment * (curr.rawProgress - prev.rawProgress);
		}
	}

	return 1.0; // Should not be reached if map is correct, but a safe fallback
	}

// --- Minimum-jerk easing (quintic) and per-DOF sampling between checkpoints ---
function __minimumJerk(u){
  u = Math.min(Math.max(u,0),1);
  return u*u*u*(10 + u*(-15 + 6*u)); // 10u^3 - 15u^4 + 6u^5
}

// Blend between linear and minimum-jerk by strength [0..1]
function __ease01(u, strength){
  const mj = __minimumJerk(u);
  return THREE.MathUtils.lerp(u, mj, THREE.MathUtils.clamp(strength ?? 1.0, 0, 1));
}

// Map the 'rampPower' control to an ease strength in [0..1]
function __easeStrengthFromUI(){
  try {
    const p = parseFloat((document.getElementById('rampPower')||{}).value || '40');
    // Map UI 1..200 â†’ alpha âˆˆ [0, 0.95] for ultra-smooth motion
    // Higher values allow smoother transitions at checkpoints
    const t = (p - 1.0) / (200.0 - 1.0);
    const MAX_ALPHA = 0.95; // Allow up to 95% smoothing (only 5% linear at edges)
    let alpha = THREE.MathUtils.clamp(t, 0, 1) * MAX_ALPHA;
    // Reduced minimum edge slope to allow smoother corners
    const MIN_EDGE_SLOPE = 0.05; // Only keep 5% minimum linear speed (was 40%)
    alpha = Math.min(alpha, 1 - MIN_EDGE_SLOPE);
    return alpha;
  } catch(_) { return 0.4; }
}

// --- Feathered progress across the entire segment ---
// Instead of only easing at the endpoints, shape the *velocity* across the full segment
// with a raised-cosine profile, then integrate and normalize to get a monotonic s(u).
// baseAlpha âˆˆ [0..1] controls how deep the feathering is (1 = strongest).
// 'sharp' adds extra feathering on corners without disabling straight segments.
function __featheredProgress(u, baseAlpha, sharp){
  u = Math.min(Math.max(u,0),1);
  // Convert UI strength to an "edge slope" budget and amplitude for the cosine
  // baseAlpha=0 â†’ linear; baseAlpha=1 â†’ strongest feather within cap
  const minSlope = Math.max(0.001, 1.0 - baseAlpha); // Allow near-zero slope for ultra-smooth
  const sharpMix = 0.15 + 0.85 * (sharp||0);         // Higher sharp influence for corners
  const amp = ((1.0 - minSlope) * 0.5) * sharpMix;   // Hann amplitude
  const c0 = minSlope, c1 = amp;
  // Instantaneous speed v(u) = c0 + c1 * (1 - cos(2Ï€u)) (minSlope at ends, peak mid)
  // Integrated position S(u) = (c0+c1)u - (c1/(2Ï€)) sin(2Ï€u). Normalize by (c0+c1).
  const twopi = Math.PI * 2.0;
  const S = ((c0 + c1) * u) - (c1 / twopi) * Math.sin(twopi * u);
  const denom = (c0 + c1);
  return denom > 1e-6 ? (S / denom) : u;
}

// --- SPEEDRAMP: Ultra-smooth S-curve for speed ramped sections ---
// Uses a 7th-order (septic) smoothstep which has:
// - Zero velocity at start and end
// - Zero acceleration at start and end  
// - Zero jerk at start and end
// This creates the "maximum feathered" effect the user requested
function __septicSmoothstep(u) {
  u = Math.min(Math.max(u, 0), 1);
  // 7th order smoothstep: -20u^7 + 70u^6 - 84u^5 + 35u^4
  const u2 = u * u;
  const u3 = u2 * u;
  const u4 = u3 * u;
  return u4 * (35 - 84*u + 70*u2 - 20*u3);
}

// Even smoother: 9th-order (nonic) smoothstep for absolute butter
function __nonicSmoothstep(u) {
  u = Math.min(Math.max(u, 0), 1);
  // 9th order: 252u^5 - 1050u^6 + 1800u^7 - 1575u^8 + 560u^9
  const u2 = u * u;
  const u3 = u2 * u;
  const u4 = u3 * u;
  const u5 = u4 * u;
  return u5 * (252 - 1050*u + 1800*u2 - 1575*u3 + 560*u4);
}

// EXTREME speedramp: Power-based S-curve with dramatic speed differential
// At endpoints: velocity approaches zero (camera crawls/stops)
// At midpoint: velocity is `power` times faster than average (camera ZIPS)
// power=7 means midpoint is 7x faster than linear, endpoints nearly stopped
function __extremeSpeedRamp(u, power = 7) {
  u = Math.min(Math.max(u, 0), 1);
  if (u < 0.5) {
    // First half: slow start, accelerating
    return 0.5 * Math.pow(2 * u, power);
  } else {
    // Second half: decelerating to slow end
    return 1 - 0.5 * Math.pow(2 * (1 - u), power);
  }
}

// CINEMATIC SPEEDRAMP: Exponential-style curve for classic slow-BLAST-slow feel
// - First 25% of time: creeps through ~3% of distance (dramatic slow start)
// - Middle 50% of time: blasts through ~94% of distance (exponential acceleration)
// - Last 25% of time: creeps through ~3% of distance (dramatic slow landing)
// This gives the "hold... hold... WHOOSH... hold" feel of pro speedramps
function __cinematicSpeedRamp(u) {
  u = Math.min(Math.max(u, 0), 1);
  
  // Use a combination of exponential and power curves for maximum drama
  // The key insight: we want VERY flat slopes at the endpoints and VERY steep in middle
  
  // Attempt 1: Super-high power (15) gives ~32x speed differential
  // But blend with exponential for smoother acceleration feel
  const power = 15;
  
  let powerResult;
  if (u < 0.5) {
    powerResult = 0.5 * Math.pow(2 * u, power);
  } else {
    powerResult = 1 - 0.5 * Math.pow(2 * (1 - u), power);
  }
  
  // Exponential component: exp-based ease for natural acceleration feel
  // Maps 0->0, 0.5->0.5, 1->1 with exponential character
  const k = 8; // steepness
  let expResult;
  if (u < 0.5) {
    expResult = 0.5 * (Math.exp(k * (2*u - 1)) - Math.exp(-k)) / (1 - Math.exp(-k));
  } else {
    const v = 1 - u;
    expResult = 1 - 0.5 * (Math.exp(k * (2*v - 1)) - Math.exp(-k)) / (1 - Math.exp(-k));
  }
  
  // Blend: 70% power curve (for the dramatic hold at endpoints) + 30% exponential (for smooth accel)
  const result = powerResult * 0.7 + expResult * 0.3;
  
  return Math.max(0, Math.min(1, result));
}

// Even more extreme: combines power ease with additional smoothstep blend
// for buttery smooth acceleration/deceleration curves
function __ultraSpeedRamp(u, power = 8) {
  u = Math.min(Math.max(u, 0), 1);
  if (!isFinite(u)) return 0.5;
  
  // Base power ease
  let base;
  if (u < 0.5) {
    base = 0.5 * Math.pow(2 * u, power);
  } else {
    base = 1 - 0.5 * Math.pow(2 * (1 - u), power);
  }
  // Blend with nonic for extra smoothness at the very tips
  const blend = 0.15; // 15% nonic blend
  const nonic = __nonicSmoothstep(u);
  const result = base * (1 - blend) + nonic * blend;
  return isFinite(result) ? Math.max(0, Math.min(1, result)) : u;
}

// Find speedramp zones in checkpoint array
// Returns array of {startIdx, endIdx} objects
function __findSpeedRampZones(cps) {
  if (!cps || cps.length < 2) return [];
  const zones = [];
  let currentStart = -1;
  
  for (let i = 0; i < cps.length; i++) {
    const cp = cps[i];
    if (cp.speedRamp === 'start') {
      currentStart = i;
    } else if (cp.speedRamp === 'end' && currentStart >= 0) {
      zones.push({ startIdx: currentStart, endIdx: i });
      currentStart = -1;
    }
  }
  return zones;
}

// Check if a global progress value falls within a speedramp zone
// Returns { inZone: bool, localProgress: 0-1, zone: {startIdx, endIdx} }
function __getSpeedRampContext(globalProgress, cps) {
  if (!cps || cps.length < 2) return { inZone: false };
  
  const zones = __findSpeedRampZones(cps);
  const n = cps.length - 1;
  
  for (const zone of zones) {
    const zoneStartProgress = zone.startIdx / n;
    const zoneEndProgress = zone.endIdx / n;
    
    // Skip zones where start equals end (would cause division by zero)
    if (zoneEndProgress <= zoneStartProgress) continue;
    
    if (globalProgress >= zoneStartProgress && globalProgress <= zoneEndProgress) {
      const localProgress = (globalProgress - zoneStartProgress) / (zoneEndProgress - zoneStartProgress);
      return { inZone: true, localProgress: Math.max(0, Math.min(1, localProgress)), zone, zoneStartProgress, zoneEndProgress };
    }
  }
  return { inZone: false };
}

// Apply speedramp easing to remap global progress within a zone
function __applySpeedRampEasing(globalProgress, cps) {
  // Safety check input
  if (!isFinite(globalProgress)) return 0;
  globalProgress = Math.max(0, Math.min(1, globalProgress));
  
  const ctx = __getSpeedRampContext(globalProgress, cps);
  if (!ctx.inZone) return globalProgress;
  
  // Power=4 gives ~4x speed at midpoint, smooth transitions at boundaries
  // This creates a noticeable speed ramp without discontinuities
  const easedLocal = __extremeSpeedRamp(ctx.localProgress, 4);
  
  // Map back to global progress space and clamp for safety
  const result = ctx.zoneStartProgress + easedLocal * (ctx.zoneEndProgress - ctx.zoneStartProgress);
  return Math.max(0, Math.min(1, result));
}

// Debug version that returns extra info
function __applySpeedRampEasingDebug(globalProgress, cps) {
  // Safety check input
  if (!isFinite(globalProgress)) return { progress: 0, debug: { error: 'NaN input' } };
  globalProgress = Math.max(0, Math.min(1, globalProgress));
  
  const ctx = __getSpeedRampContext(globalProgress, cps);
  if (!ctx.inZone) {
    return { 
      progress: globalProgress, 
      debug: { inZone: false, pathProgress: globalProgress.toFixed(4) } 
    };
  }
  
  // Use power=4 for a noticeable but continuous effect
  // Power=4 gives ~4x speed at midpoint vs endpoints
  // Higher powers (10, 20) cause discontinuities at zone boundaries
  const power = 4;
  const easedLocal = __extremeSpeedRamp(ctx.localProgress, power);
  
  // Map back to global progress space and clamp for safety
  const result = ctx.zoneStartProgress + easedLocal * (ctx.zoneEndProgress - ctx.zoneStartProgress);
  const clampedResult = Math.max(0, Math.min(1, result));
  
  return { 
    progress: clampedResult, 
    debug: { 
      inZone: true,
      power: power,
      pathProgress: globalProgress.toFixed(4),
      localProgress: ctx.localProgress.toFixed(4),
      easedLocal: easedLocal.toFixed(6),
      rampedProgress: clampedResult.toFixed(4),
      zoneStart: ctx.zoneStartProgress.toFixed(4),
      zoneEnd: ctx.zoneEndProgress.toFixed(4)
    } 
  };
}

// --- Quaternion helpers for spherical CÂ¹ smoothing (SQUAD) of offset direction ---
function __qFromDir(dir){
  const z = new THREE.Vector3(0,0,1);
  const d = dir.clone().normalize();
  const q = new THREE.Quaternion();
  const dot = THREE.MathUtils.clamp(z.dot(d), -1, 1);
  if (dot > 0.999999) { return q.identity(); }
  if (dot < -0.999999) {
    const axis = new THREE.Vector3(1,0,0).cross(z).length() < 1e-6 ? new THREE.Vector3(0,1,0) : new THREE.Vector3(1,0,0);
    q.setFromAxisAngle(axis, Math.PI);
    return q;
  }
  return q.setFromUnitVectors(z, d);
}
function __qLog(q){
  const qq = q.clone().normalize();
  const v = new THREE.Vector3(qq.x, qq.y, qq.z);
  const w = THREE.MathUtils.clamp(qq.w, -1, 1);
  const len = v.length();
  if (len < 1e-12) return new THREE.Vector3(0,0,0);
  const theta = Math.atan2(len, w);
  return v.multiplyScalar(theta / len);
}
function __qExp(v){
  const a = v.length();
  if (a < 1e-12) return new THREE.Quaternion(1, 0, 0, 0);
  const s = Math.sin(a) / a;
  return new THREE.Quaternion(Math.cos(a), v.x * s, v.y * s, v.z * s);
}
function __qMul(a, b){
  return a.clone().multiply(b);
}
function __qConj(a){
  return a.clone().conjugate();
}

// Ensure quaternions are on the same hemisphere to avoid long-path slerps and flips
function __qHemalign(q, ref){
  // If dot < 0, negate q to keep it near ref
  const d = q.x*ref.x + q.y*ref.y + q.z*ref.z + q.w*ref.w;
  return (d < 0) ? new THREE.Quaternion(-q.x, -q.y, -q.z, -q.w) : q.clone();
}


function __squadTangent(qPrev, qCur, qNext){
  // Align neighbors to current to avoid antipodal issues
  const p = __qHemalign(qPrev, qCur);
  const n = __qHemalign(qNext, qCur);
  const inv = __qConj(qCur);
  const l1 = __qLog(__qMul(inv, p));
  const l2 = __qLog(__qMul(inv, n));
  const avg = l1.add(l2).multiplyScalar(-0.25);
  return __qMul(qCur, __qExp(avg));
}

function __slerp(q1, q2, t){
  const a = q1;
  const b = __qHemalign(q2, q1);
  return a.clone().slerp(b, t);
}
function __squad(q1, q2, s1, s2, t){
  const slerp12 = __slerp(q1, q2, t);
  const slerpSS = __slerp(s1, s2, t);
  const h = 2*t*(1-t);
  return __slerp(slerp12, slerpSS, h);
}
function __dirSQUAD(u0, u1, u2, u3, t){
  let q0 = __qFromDir(u0), q1 = __qFromDir(u1), q2 = __qFromDir(u2), q3 = __qFromDir(u3);
  // Align chain to q1/q2 to maintain hemisphere consistency
  q0 = __qHemalign(q0, q1);
  q2 = __qHemalign(q2, q1);
  q3 = __qHemalign(q3, q2);
  const s1 = __squadTangent(q0, q1, q2);
  const s2 = __squadTangent(q1, q2, q3);
  const q = __squad(q1, q2, s1, s2, t);
  return new THREE.Vector3(0,0,1).applyQuaternion(q).normalize();
}

// --- Tensioned variants to clamp overshoot on near-straight links ---
function __squadTangentTension(qPrev, qCur, qNext, tau){
  // tau in [0,1]; 1 = highest tension (tangents -> 0), 0 = default
  // Align neighbors to current to avoid antipodal issues
  const inv = __qConj(qCur);
  const l1 = __qLog(__qMul(inv, __qHemalign ? __qHemalign(qPrev, qCur) : qPrev));
  const l2 = __qLog(__qMul(inv, __qHemalign ? __qHemalign(qNext, qCur) : qNext));
  const scale = Math.max(0, Math.min(1, 1 - (tau||0)));
  const avg = l1.add(l2).multiplyScalar(-0.25 * scale);
  return __qMul(qCur, __qExp(avg));
}
function __dirSQUADT(u0, u1, u2, u3, t, tau){
  let q0 = __qFromDir(u0), q1 = __qFromDir(u1), q2 = __qFromDir(u2), q3 = __qFromDir(u3);
  if (typeof __qHemalign === 'function'){
    q0 = __qHemalign(q0, q1);
    q2 = __qHemalign(q2, q1);
    q3 = __qHemalign(q3, q2);
  }
  const s1 = __squadTangentTension(q0, q1, q2, tau);
  const s2 = __squadTangentTension(q1, q2, q3, tau);
  const q = __squad(q1, q2, s1, s2, t);
  return new THREE.Vector3(0,0,1).applyQuaternion(q).normalize();
}






// Sample directly between discrete checkpoints with smooth per-DOF easing.
// This avoids direction snaps and ensures velocity AND acceleration near 0 at endpoints.


function sampleCustomPathAt(globalProgress, easeStrength){
  function segSharpness(prev, A, B, next){
    // Use offset vectors to measure turn angle at B
    const v1 = B.offset.clone().sub(A.offset);
    const v2 = (next ? next.offset.clone().sub(B.offset) : new THREE.Vector3()).normalize();
    if (v1.lengthSq() === 0) return 0;
    const n1 = v1.clone().normalize();
    const dot = THREE.MathUtils.clamp(n1.dot(v2), -1, 1);
    return (1 - dot) * 0.5; // 0 straight â†’ 1 full reverse
  }

  const cps = Array.isArray(cinematicPathCheckpoints) ? cinematicPathCheckpoints : null;

  // If we don't have a proper checkpoint path, just sample existing curves directly.
  if (!(cps && cps.length >= 2)) {
    const focus = pathFocusCurve ? pathFocusCurve.getPointAt(globalProgress) : new THREE.Vector3();
    const offset = pathOffsetCurve ? pathOffsetCurve.getPointAt(globalProgress) : new THREE.Vector3(0, 0, 2);
    const fovPt = pathFovCurve ? pathFovCurve.getPointAt(globalProgress) : new THREE.Vector2(globalProgress, 50);
    const fov = (fovPt && typeof fovPt.y === 'number') ? fovPt.y : 50;
    return { focus, offset, fov };
  }

  // Note: Speedramp easing is now applied in the main animation loop BEFORE
  // calling this function, so globalProgress is already ramped if applicable.

  // Map global progress into a segment index and local parameter u in [0,1].
  const n = cps.length - 1;
  const gp = THREE.MathUtils.clamp(globalProgress, 0, 1);
  const f = gp * n;
  const i = Math.min(n - 1, Math.floor(f));
  const u = f - i;

  const A = cps[i];
  const B = cps[Math.min(i + 1, n)];
  const prev = (i > 0) ? cps[i - 1] : null;
  const next = (i < n - 1) ? cps[i + 2] : null;

  let focus, offset, fov;

  // Use feathered progress (if available) purely as a time-warp along the Catmull curves.
  if (typeof __featheredProgress === 'function') {
    const sharp = segSharpness(prev || A, A, B, next || B);
    const baseAlpha = THREE.MathUtils.clamp(easeStrength || 0, 0, 10);
    const alphaSeg = baseAlpha;
    const s = __featheredProgress(u, alphaSeg, sharp);
    const t = (i + THREE.MathUtils.clamp(s, 0, 1)) / n;

    if (pathFocusCurve && typeof pathFocusCurve.getPointAt === 'function' &&
        pathOffsetCurve && typeof pathOffsetCurve.getPointAt === 'function' &&
        pathFovCurve && typeof pathFovCurve.getPointAt === 'function') {

      focus  = pathFocusCurve.getPointAt(t);
      offset = pathOffsetCurve.getPointAt(t);
      const fovPt = pathFovCurve.getPointAt(t);
      fov = (fovPt && typeof fovPt.y === 'number')
        ? fovPt.y
        : (typeof B.fov === 'number' ? B.fov : 50);
    } else {
      // Fallback: lerp directly between checkpoints A and B.
      focus  = A.focus.clone().lerp(B.focus, s);
      offset = A.offset.clone().lerp(B.offset, s);
      fov    = THREE.MathUtils.lerp(A.fov, B.fov, s);
    }
  } else {
    // No feathered progress helper: simple linear mapping within the segment.
    const s = THREE.MathUtils.clamp(u, 0, 1);
    const t = (i + s) / n;

    if (pathFocusCurve && typeof pathFocusCurve.getPointAt === 'function' &&
        pathOffsetCurve && typeof pathOffsetCurve.getPointAt === 'function' &&
        pathFovCurve && typeof pathFovCurve.getPointAt === 'function') {

      focus  = pathFocusCurve.getPointAt(t);
      offset = pathOffsetCurve.getPointAt(t);
      const fovPt = pathFovCurve.getPointAt(t);
      fov = (fovPt && typeof fovPt.y === 'number')
        ? fovPt.y
        : (typeof B.fov === 'number' ? B.fov : 50);
    } else {
      focus  = A.focus.clone().lerp(B.focus, s);
      offset = A.offset.clone().lerp(B.offset, s);
      fov    = THREE.MathUtils.lerp(A.fov, B.fov, s);
    }
  }

  // --- Butter Smoothing (critically-damped pose filter) ---
  let outFocus = focus, outOffset = offset, outFov = fov;
  try{
    const bs = (typeof document!=='undefined') ? document.getElementById('butterSmooth') : null;
    const msEl = (typeof document!=='undefined') ? document.getElementById('butterMs') : null;
    const enabled = !!(bs && bs.checked);
    const ms = msEl ? Math.max(0, parseFloat(msEl.value||'800')) : 800;
    if (enabled && ms > 0) {
      window.__butterState = window.__butterState || { 
        has:false, lastP:-1, t:0, 
        focus:new THREE.Vector3(), dir:new THREE.Vector3(0,0,1), rad:0, fov:0,
        // Second-order state for velocity smoothing
        focusVel:new THREE.Vector3(), dirVel:new THREE.Vector3(), radVel:0, fovVel:0
      };
      if (__butterState.lastP > globalProgress) { __butterState.has = false; } // reset on loop/restart
      __butterState.lastP = globalProgress;
      const now = (typeof performance!=='undefined' ? performance.now()*0.001 : Date.now()*0.001);
      const prevT = __butterState.t || now;
      __butterState.t = now;
      const dt = Math.min(1/15, Math.max(0.00001, now - prevT)); // cap for stability
      const tau = Math.max(0.001, ms / 1000);
      
      // Use a second-order critically damped filter for even smoother motion
      // This smooths both position AND velocity
      const zeta = 1.0; // critically damped
      const omega = 1.0 / tau;
      const k1 = zeta / (Math.PI * omega);
      const k2 = 1.0 / ((2 * Math.PI * omega) * (2 * Math.PI * omega));
      const k3 = zeta * omega;
      
      // Simplified second-order response (critically damped)
      const alpha = Math.min(1.0, dt * omega * 2.0); // Doubled responsiveness for smoother tracking
  
      if (!__butterState.has) {
        __butterState.focus.copy(focus);
        __butterState.dir.copy(offset.clone().normalize());
        __butterState.rad = offset.length();
        __butterState.fov = fov;
        __butterState.focusVel.set(0,0,0);
        __butterState.dirVel.set(0,0,0);
        __butterState.radVel = 0;
        __butterState.fovVel = 0;
        __butterState.has = true;
      } else {
        // Blend direction on the sphere (unit vectors) â€” short path
        const a = __butterState.dir.clone().normalize();
        let b = offset.clone().normalize();
        let d = THREE.MathUtils.clamp(a.dot(b), -1, 1);
        if (d < 0) { b.multiplyScalar(-1); d = -d; }
        const th = Math.acos(d);
        let blended;
        if (th < 1e-5){ blended = a; }
        else {
          const sinT = Math.sin(th);
          const w1 = Math.sin((1 - alpha) * th) / sinT;
          const w2 = Math.sin(alpha * th) / sinT;
          blended = a.multiplyScalar(w1).add(b.multiplyScalar(w2)).normalize();
        }
  
        __butterState.dir.copy(blended);
        __butterState.rad += (offset.length() - __butterState.rad) * alpha;
        __butterState.focus.lerp(focus, alpha);
        __butterState.fov += (fov - __butterState.fov) * alpha;
      }
  
      outFocus = __butterState.focus.clone();
      outOffset = __butterState.dir.clone().multiplyScalar(__butterState.rad);
      outFov = __butterState.fov;
      
      // Triple-Pass Super Smoothing: Apply additional smoothing passes
      const superEl = (typeof document!=='undefined') ? document.getElementById('superSmooth') : null;
      if (superEl && superEl.checked && ms > 100) {
        // Apply two more exponential smoothing passes with reduced time constants
        // This creates an even smoother S-curve response
        window.__butterState2 = window.__butterState2 || {
          focus: outFocus.clone(), offset: outOffset.clone(), fov: outFov
        };
        window.__butterState3 = window.__butterState3 || {
          focus: outFocus.clone(), offset: outOffset.clone(), fov: outFov
        };
        
        // Second pass (50% of main time constant)
        const alpha2 = Math.min(1.0, dt * omega * 1.0);
        __butterState2.focus.lerp(outFocus, alpha2);
        __butterState2.offset.lerp(outOffset, alpha2);
        __butterState2.fov += (outFov - __butterState2.fov) * alpha2;
        
        // Third pass (33% of main time constant)  
        const alpha3 = Math.min(1.0, dt * omega * 0.67);
        __butterState3.focus.lerp(__butterState2.focus, alpha3);
        __butterState3.offset.lerp(__butterState2.offset, alpha3);
        __butterState3.fov += (__butterState2.fov - __butterState3.fov) * alpha3;
        
        // Use the triple-smoothed result
        outFocus = __butterState3.focus.clone();
        outOffset = __butterState3.offset.clone();
        outFov = __butterState3.fov;
      }
    }
  }catch(_){/* non-fatal */}
  
  return { focus: outFocus, offset: outOffset, fov: outFov };

}

// ============================================
// UNIFIED PATH PLAYBACK SYSTEM
// ============================================
// 
// Architecture:
// 1. Equal base time per MOVEMENT segment (pause/transition segments get minimal time)
// 2. Distance-based speed scaling WITHIN each segment (slower when close, faster when far)
// 3. Speedramps override everything in designated zones
// 4. Velocity-preserving easing: camera passes through exact positions with zero velocity at checkpoints
// 5. Butter smoothing (applied later) adds final gimbal polish
//
// NOTE: Recording timing is NOT used - we don't want setup time
// to affect playback speed!
// ============================================

// Precompute segment weights for time allocation
// Movement segments get weight 1.0, pause/transition segments get weight ~0 
function __computeSegmentWeights(cps) {
  if (!cps || cps.length < 2) return null;
  
  const weights = [];
  const PAUSE_WEIGHT = 0.01; // Minimal time for pause segments
  const MIN_DISTANCE = 0.001; // Threshold for "same position"
  
  for (let i = 0; i < cps.length - 1; i++) {
    const cp0 = cps[i];
    const cp1 = cps[i + 1];
    
    // Check if this is a "same position" segment (photo transition)
    const offsetDist = cp0.offset.distanceTo(cp1.offset);
    const focusDist = cp0.focus.distanceTo(cp1.focus);
    const fovDiff = Math.abs(cp0.fov - cp1.fov);
    
    const isStationary = offsetDist < MIN_DISTANCE && focusDist < MIN_DISTANCE && fovDiff < 0.1;
    const isPauseSegment = cp1.isPause || cp0.isPause;
    
    if (isStationary || isPauseSegment) {
      weights.push(PAUSE_WEIGHT);
    } else {
      weights.push(1.0);
    }
  }
  
  return weights;
}

// Get cumulative weighted time for each checkpoint index
// Returns array where result[i] = weighted time position of checkpoint i (0 to 1)
function __getCheckpointWeightedTimes(cps) {
  const weights = __computeSegmentWeights(cps);
  if (!weights || weights.length === 0) return null;
  
  const totalWeight = weights.reduce((a, b) => a + b, 0);
  if (totalWeight <= 0) return null;
  
  const times = [0]; // Checkpoint 0 is at time 0
  let cumulative = 0;
  
  for (let i = 0; i < weights.length; i++) {
    cumulative += weights[i];
    times.push(cumulative / totalWeight);
  }
  
  return times;
}

// Convert video progress to segment progress using weighted time allocation
function __getWeightedSegmentProgress(videoProgress, cps) {
  const weights = __computeSegmentWeights(cps);
  if (!weights || weights.length === 0) return { segmentIdx: 0, localProgress: 0 };
  
  const totalWeight = weights.reduce((a, b) => a + b, 0);
  if (totalWeight <= 0) return { segmentIdx: 0, localProgress: videoProgress };
  
  // Find which segment we're in based on weighted time
  let accumulatedWeight = 0;
  const targetWeight = videoProgress * totalWeight;
  
  for (let i = 0; i < weights.length; i++) {
    const segmentStart = accumulatedWeight;
    const segmentEnd = accumulatedWeight + weights[i];
    
    if (targetWeight <= segmentEnd || i === weights.length - 1) {
      // We're in this segment
      const segmentWeight = weights[i];
      const localProgress = segmentWeight > 0.0001 
        ? (targetWeight - segmentStart) / segmentWeight 
        : 1.0;
      
      return {
        segmentIdx: i,
        localProgress: Math.max(0, Math.min(1, localProgress))
      };
    }
    
    accumulatedWeight = segmentEnd;
  }
  
  return { segmentIdx: weights.length - 1, localProgress: 1 };
}

function getUnifiedPathPose(videoProgress) {
  const cps = cinematicPathCheckpoints;
  
  // Fallback for empty/invalid paths
  if (!cps || cps.length < 2) {
    return { 
      offset: new THREE.Vector3(0, 0, 5), 
      focus: new THREE.Vector3(0, 0, 0), 
      fov: 50, 
      deckIdx: 0, 
      deckFadeMs: 600 
    };
  }

  // Clamp input
  videoProgress = Math.max(0, Math.min(1, videoProgress));

  const numSegments = cps.length - 1;
  
  // ---- STEP 1: Check for speedramp zones using WEIGHTED time boundaries ----
  const speedRampZones = __findSpeedRampZones(cps);
  const checkpointTimes = __getCheckpointWeightedTimes(cps);
  
  let inSpeedRamp = false;
  let speedRampZone = null;
  let zoneLocalProgress = 0;
  
  // Check each speedramp zone using weighted time boundaries
  if (checkpointTimes) {
    for (const zone of speedRampZones) {
      const zoneStart = checkpointTimes[zone.startIdx];
      const zoneEnd = checkpointTimes[zone.endIdx];
      
      if (videoProgress >= zoneStart && videoProgress <= zoneEnd && zoneEnd > zoneStart) {
        inSpeedRamp = true;
        speedRampZone = zone;
        zoneLocalProgress = (videoProgress - zoneStart) / (zoneEnd - zoneStart);
        break;
      }
    }
  }

  // ---- STEP 2: Calculate segment and local progress ----
  let cp0, cp1, t;
  
  if (inSpeedRamp && speedRampZone) {
    // SPEEDRAMP MODE: Interpolate directly between zone endpoints
    cp0 = cps[speedRampZone.startIdx];
    cp1 = cps[speedRampZone.endIdx];
    
    // Use cinematic speedramp for dramatic slow-BLAST-slow effect
    t = __cinematicSpeedRamp(zoneLocalProgress);
    
  } else {
    // NORMAL MODE: Use weighted time allocation (movement segments get more time)
    const { segmentIdx, localProgress } = __getWeightedSegmentProgress(videoProgress, cps);
    
    cp0 = cps[segmentIdx];
    cp1 = cps[Math.min(segmentIdx + 1, cps.length - 1)];
    
    let adjustedProgress = localProgress;
    
    // Handle pause checkpoints - quick transition, mostly for deck change
    if (cp1.isPause) {
      // For pause segments, just do a quick linear pass-through
      // The weighted system already gives this minimal time
      t = localProgress;
      
      // Trigger deck change at midpoint
      const deckIdx = localProgress < 0.5 ? (cp0.deckIdx ?? 0) : (cp1.deckIdx ?? 0);
      const deckFadeMs = cp1.deckFadeMs || 600;
      
      return {
        offset: cp0.offset.clone(),
        focus: cp0.focus.clone(),
        fov: cp0.fov,
        deckIdx,
        deckFadeMs
      };
    }
    
    // ---- Apply distance-based speed scaling WITHIN this segment ----
    if (document.getElementById('enableSpeedScale')?.checked) {
      adjustedProgress = __applyPerSegmentDistanceScaling(cp0, cp1, adjustedProgress);
    }
    
    // ---- Apply velocity-preserving easing ----
    // This ensures camera passes through exact checkpoint positions
    // but with velocity smoothly approaching zero at each checkpoint (sine wave pattern)
    if (document.getElementById('rampCheckpoints')?.checked) {
      adjustedProgress = __velocityZeroEasing(adjustedProgress);
    }
    
    t = adjustedProgress;
  }
  
  // Clamp t for safety
  t = Math.max(0, Math.min(1, t));
  
  // ---- STEP 3: Interpolate pose ----
  const offset = new THREE.Vector3().lerpVectors(cp0.offset, cp1.offset, t);
  const focus = new THREE.Vector3().lerpVectors(cp0.focus, cp1.focus, t);
  const fov = THREE.MathUtils.lerp(cp0.fov, cp1.fov, t);
  
  // Deck index switches at midpoint of transition
  const deckIdx = t < 0.5 ? (cp0.deckIdx ?? 0) : (cp1.deckIdx ?? 0);
  const deckFadeMs = t < 0.5 ? (cp0.deckFadeMs || 600) : (cp1.deckFadeMs || 600);

  return { offset, focus, fov, deckIdx, deckFadeMs };
}

// Velocity-preserving easing using sine curve
// - Position at t=0 maps to exactly 0
// - Position at t=1 maps to exactly 1
// - Velocity at t=0 = 0 (smooth start)
// - Velocity at t=1 = 0 (smooth stop)
// This is like the top/bottom of a sine wave - velocity touches zero before changing direction
function __velocityZeroEasing(t) {
  // Base: (1 - cos(Ï€t)) / 2
  // This is the classic "ease in-out sine" - smooth start AND smooth stop
  // Derivative: (Ï€/2) * sin(Ï€t), which is 0 at t=0 and t=1
  
  // Get the strength from UI (default: moderate easing)
  const power = parseFloat(document.getElementById('rampPower')?.value || 50) / 50;
  
  // Sine-based ease (always has zero velocity at endpoints)
  const sineEased = (1 - Math.cos(Math.PI * t)) / 2;
  
  // Blend between linear and sine-eased based on power
  // power=0: linear (no easing)
  // power=1: full sine easing
  // power>1: apply sine multiple times for even more dramatic slowdown at endpoints
  
  if (power <= 1) {
    return t * (1 - power) + sineEased * power;
  } else {
    // For power > 1, apply sine easing multiple times
    // Each application makes the endpoints even slower
    let result = t;
    const iterations = Math.min(Math.floor(power), 4); // Cap at 4 iterations
    const remainder = power - iterations;
    
    for (let i = 0; i < iterations; i++) {
      result = (1 - Math.cos(Math.PI * result)) / 2;
    }
    
    // Blend in partial iteration
    if (remainder > 0) {
      const nextIter = (1 - Math.cos(Math.PI * result)) / 2;
      result = result * (1 - remainder) + nextIter * remainder;
    }
    
    return result;
  }
}

// Apply distance-based speed scaling within a single segment
// Returns adjusted local progress (0-1) that spends more time when close, less when far
// 
// This uses a closed-form analytical solution instead of discrete sampling.
// For linear distance interpolation d(p) = d0 + p*(d1-d0) and speed = d^power:
// - Integrating 1/speed gives cumulative time as a function of progress
// - Inverting this gives progress as a function of time (what we need)
//
// The math:
// For power â‰  1: p = [(t*(d1^(1-power) - d0^(1-power)) + d0^(1-power))^(1/(1-power)) - d0] / (d1-d0)
// For power = 1: p = d0 * [(d1/d0)^t - 1] / (d1-d0)
//
function __applyPerSegmentDistanceScaling(cp0, cp1, linearTime) {
  const power = parseFloat(document.getElementById('speedScalePower')?.value || 0.5);
  
  // Get start and end distances to focus
  const d0 = Math.max(0.01, cp0.offset.length()); // Clamp to avoid division by zero
  const d1 = Math.max(0.01, cp1.offset.length());
  
  // If distances are nearly identical, no scaling needed
  const dDelta = d1 - d0;
  if (Math.abs(dDelta) < 0.001) {
    return linearTime;
  }
  
  // Clamp time to valid range
  const t = Math.max(0, Math.min(1, linearTime));
  
  // Handle power â‰ˆ 1 separately (logarithmic case)
  if (Math.abs(power - 1) < 0.01) {
    // p = d0 * [(d1/d0)^t - 1] / (d1 - d0)
    const ratio = d1 / d0;
    const p = d0 * (Math.pow(ratio, t) - 1) / dDelta;
    return Math.max(0, Math.min(1, p));
  }
  
  // General case: power â‰  1
  // p = [(t*(d1^(1-power) - d0^(1-power)) + d0^(1-power))^(1/(1-power)) - d0] / (d1-d0)
  const exp = 1 - power;
  const d0Exp = Math.pow(d0, exp);
  const d1Exp = Math.pow(d1, exp);
  
  // Interpolate in the transformed space
  const blended = t * (d1Exp - d0Exp) + d0Exp;
  
  // Transform back and solve for p
  const invExp = 1 / exp;
  const dAtProgress = Math.pow(Math.max(0.0001, blended), invExp);
  const p = (dAtProgress - d0) / dDelta;
  
  return Math.max(0, Math.min(1, p));
}

// Legacy alias for compatibility
function getCustomPathProgress(globalProgress) {
  return getUnifiedPathPose(globalProgress);
}
				enableSpeedScale.addEventListener('change', precomputeSpeedAdjustedPath);
	speedScalePower.addEventListener('input', precomputeSpeedAdjustedPath);
	speedScalePowerN.addEventListener('input', precomputeSpeedAdjustedPath);


	function updateCheckpointUI() {
	checkpointCountEl.textContent = cinematicPathCheckpoints.length;
	pathFinishBtn.disabled = cinematicPathCheckpoints.length < 2;
	pathClearBtn.disabled = cinematicPathCheckpoints.length === 0;
	
	// Show/hide speedramp button based on recording state
	if (isRecordingPath) {
		speedRampBtn.style.display = '';
		// Update speedramp button state
		if (isRecordingSpeedRamp) {
			speedRampBtn.textContent = 'Speedramp End';
			speedRampBtn.style.background = 'linear-gradient(135deg,#3a2040,#2a1a30)';
			speedRampBtn.style.borderColor = '#6a3b7a';
			speedRampIndicator.style.display = '';
			pathRecordBtn.disabled = true;
			pathRecordBtn.style.opacity = '0.5';
		} else {
			speedRampBtn.textContent = 'Speedramp Start';
			speedRampBtn.style.background = 'linear-gradient(135deg,#2a1a30,#1a1a26)';
			speedRampBtn.style.borderColor = '#4a2b5a';
			speedRampIndicator.style.display = 'none';
			pathRecordBtn.disabled = false;
			pathRecordBtn.style.opacity = '1';
		}
	} else {
		speedRampBtn.style.display = 'none';
		speedRampIndicator.style.display = 'none';
		pathRecordBtn.disabled = false;
		pathRecordBtn.style.opacity = '1';
	}
	}

	pathRecordBtn.addEventListener('click', () => {
	if (!isRecordingPath) {
		// Starting path recording
		isRecordingPath = true;
		cinematicPathCheckpoints = [];
		
		// NEW: Initialize timing
		pathRecordingStartTime = performance.now();
		lastCheckpointTime = pathRecordingStartTime;
		
		pathRecordBtn.textContent = 'Add Checkpoint';
		pathRecordBtn.classList.remove('primary');
		pathRecordBtn.classList.add('good');
		pathFinishBtn.disabled = false;
		pathClearBtn.disabled = false;
		if (speedRampBtn) speedRampBtn.style.display = 'inline-block';
		customPathOption.disabled = true;
		if (pathSel.value === 'customPath') {
			pathSel.value = 'orbit360'; 
		}
	}
	
	// Always add a checkpoint when clicking (matches original behavior)
	const now = performance.now();
	const timeSinceStart = now - pathRecordingStartTime;
	const timeSinceLast = now - lastCheckpointTime;
	
	scene.attach(camera);
	const cameraWorldPos = new THREE.Vector3();
	camera.getWorldPosition(cameraWorldPos);
	const offset = cameraWorldPos.clone().sub(focus);
	pivot.attach(camera);
	
	const checkpoint = {
		offset: offset.clone(),
		focus: focus.clone(),
		fov: camera.fov,
		deckIdx: (globalThis.deckIndex != null ? globalThis.deckIndex : 0),
		deckFadeMs: parseInt(document.getElementById('deckFadeMs')?.value || 600),
		// NEW: Timing data
		timestamp: timeSinceStart,           // Absolute time since recording start (ms)
		duration: timeSinceLast / 1000,      // Time since last checkpoint (seconds)
		isPause: false                        // Regular movement checkpoint
	};
	
	if (isRecordingSpeedRamp) {
		checkpoint.speedRampEnd = true;
		isRecordingSpeedRamp = false;
		if (speedRampBtn) {
			speedRampBtn.textContent = 'Speedramp Start';
			speedRampBtn.style.background = 'linear-gradient(135deg,#2a1a30,#1a1a26)';
		}
		if (speedRampIndicator) speedRampIndicator.style.display = 'none';
	}
	
	cinematicPathCheckpoints.push(checkpoint);
	lastCheckpointTime = now;
		
	console.log(`[checkpoint] Added #${cinematicPathCheckpoints.length}:`, {
		timeSinceStart: (timeSinceStart/1000).toFixed(2) + 's',
		duration: checkpoint.duration.toFixed(2) + 's',
		offset: offset.toArray().map(v => v.toFixed(2)),
		fov: camera.fov.toFixed(1)
	});
	
	updateDurationConstraints();
	updateCheckpointUI();
	});

	// Speed Ramp button handler
	speedRampBtn.addEventListener('click', () => {
	if (!isRecordingPath) return;
	
	// Record the camera's state relative to the focus point
	const cameraWorldPos = new THREE.Vector3();
	camera.getWorldPosition(cameraWorldPos);
	const offset = cameraWorldPos.clone().sub(focus);

	const checkpoint = {
		offset: offset,
		focus: focus.clone(),
		fov: camera.fov,
		deckIdx: (typeof globalThis.__deck_getIndex==='function' ? globalThis.__deck_getIndex() : -1),
		deckFadeMs: (parseInt(((document.getElementById('deckFadeMs')||{}).value)) || 600),
		speedRamp: isRecordingSpeedRamp ? 'end' : 'start'  // Mark as speedramp start or end
	};
	
	cinematicPathCheckpoints.push(checkpoint);
	
	// Toggle speedramp recording state
	isRecordingSpeedRamp = !isRecordingSpeedRamp;
	
	updateCheckpointUI();
	});

	// NEW: Automatic waypoint creation for photo transitions
	function handlePhotoTransition(newIndex, fadeMs) {
		if (!isRecordingPath) return;
		
		const now = performance.now();
		const timeSinceStart = now - pathRecordingStartTime;
		const timeSinceLast = now - lastCheckpointTime;
		
		// Get current camera state
		const cameraWorldPos = new THREE.Vector3();
		camera.getWorldPosition(cameraWorldPos);
		const offset = cameraWorldPos.clone().sub(focus);
		
		// Create "before transition" checkpoint - current position with OLD image
		const beforeCheckpoint = {
			offset: offset.clone(),
			focus: focus.clone(),
			fov: camera.fov,
			deckIdx: globalThis.deckIndex || 0,  // Current/old image
			deckFadeMs: fadeMs,
			timestamp: timeSinceStart,
			duration: timeSinceLast / 1000,
			isPause: false
		};
		cinematicPathCheckpoints.push(beforeCheckpoint);
		
		// Create "after transition" checkpoint - same position with NEW image
		// The weighted segment system detects same-position segments and gives minimal time
		// Deck index switches at midpoint, triggering the crossfade
		const afterCheckpoint = {
			offset: offset.clone(),
			focus: focus.clone(),
			fov: camera.fov,
			deckIdx: newIndex,  // New image
			deckFadeMs: fadeMs,
			timestamp: timeSinceStart,
			duration: 0,
			isPause: false
		};
		cinematicPathCheckpoints.push(afterCheckpoint);
		
		lastCheckpointTime = now;
		
		console.log(`[transition] Added 2 waypoints for image transition to ${newIndex}`);
		updateDurationConstraints();
		updateCheckpointUI();
	}

	// Hook into the deck transition buttons
	const hookPhotoTransitions = () => {
		const qcNext = document.getElementById('qcNextImg');
		const qcPrev = document.getElementById('qcPrevImg');
		
		if (qcNext && !qcNext.__pathHooked) {
			const origHandler = qcNext.onclick;
			qcNext.onclick = function(e) {
				if (isRecordingPath && globalThis.deck && globalThis.deck.length > 1) {
					const currentIdx = globalThis.deckIndex || 0;
					const newIdx = (currentIdx + 1) % globalThis.deck.length;
					const fadeMs = parseInt(document.getElementById('deckFadeMs')?.value || 600);
					handlePhotoTransition(newIdx, fadeMs);
				}
				if (origHandler) origHandler.call(this, e);
			};
			qcNext.__pathHooked = true;
		}
		
		if (qcPrev && !qcPrev.__pathHooked) {
			const origHandler = qcPrev.onclick;
			qcPrev.onclick = function(e) {
				if (isRecordingPath && globalThis.deck && globalThis.deck.length > 1) {
					const currentIdx = globalThis.deckIndex || 0;
					const newIdx = (currentIdx - 1 + globalThis.deck.length) % globalThis.deck.length;
					const fadeMs = parseInt(document.getElementById('deckFadeMs')?.value || 600);
					handlePhotoTransition(newIdx, fadeMs);
				}
				if (origHandler) origHandler.call(this, e);
			};
			qcPrev.__pathHooked = true;
		}
	};

	// Install hooks after a delay
	setTimeout(hookPhotoTransitions, 1000);

	pathFinishBtn.addEventListener('click', () => {
	isRecordingPath = false;
	isRecordingSpeedRamp = false; // Reset speedramp state
	pathRecordBtn.textContent = 'Start Building Path';
	pathRecordBtn.classList.add('primary');
	pathRecordBtn.classList.remove('good');
	
	buildCustomPathCurves();

	// Debug: Log checkpoint info and speedramp zones
	console.log('=== PATH FINISHED ===');
	console.log('Checkpoints:', cinematicPathCheckpoints.length);
	cinematicPathCheckpoints.forEach((cp, i) => {
		console.log(`  [${i}] speedRamp: ${cp.speedRamp || 'none'}, offset: (${cp.offset.x.toFixed(2)}, ${cp.offset.y.toFixed(2)}, ${cp.offset.z.toFixed(2)})`);
	});
	const zones = __findSpeedRampZones(cinematicPathCheckpoints);
	console.log('SpeedRamp Zones:', zones);
	zones.forEach((z, i) => {
		const n = cinematicPathCheckpoints.length - 1;
		console.log(`  Zone ${i}: indices ${z.startIdx}-${z.endIdx}, progress ${(z.startIdx/n).toFixed(4)}-${(z.endIdx/n).toFixed(4)}`);
	});
	console.log('=====================');

	customPathOption.disabled = false;
	pathSel.value = 'customPath';
	updatePathControls();
	updateCheckpointUI();
	});

	const handleTensionChange = () => {
	// If a custom path has already been built, rebuild it with the new tension
	if (pathOffsetCurve) {
		buildCustomPathCurves();
	}
	};
	pathTension.addEventListener('input', handleTensionChange);
	pathTensionN.addEventListener('input', handleTensionChange);

	pathClearBtn.addEventListener('click', () => {
	isRecordingPath = false;
	isRecordingSpeedRamp = false; // Reset speedramp state
	cinematicPathCheckpoints = [];
	buildCustomPathCurves();

	pathRecordBtn.textContent = 'Start Building Path';
	pathRecordBtn.classList.add('primary');
	pathRecordBtn.classList.remove('good');
	
	customPathOption.disabled = true;
	if (pathSel.value === 'customPath') {
		pathSel.value = 'orbit360';
	}
	updatePathControls();
	updateCheckpointUI();
	});
	updateCheckpointUI();
// ===== Selfâ€‘tests =====
	function runSelfTests(){
	  try{
	const results=[];
	const c0 = cylFromCamera();
	results.push(['Worldâ€‘space cyl read', isFinite(c0.phi)]);
	const keep = { pos: new THREE.Vector3(), fov: camera.fov }; 
	camera.getWorldPosition(keep.pos);
	applyRig(1.0, 2.0, 0.2, camera.fov);
	const c1 = cylFromCamera();
	results.push(['Zoom preserves Ï†', Math.abs(c1.phi-1.0) < 1e-3 ]);
	const out=document.createElement('div'); 
	out.className='small'; 
	out.textContent = 'Selfâ€‘tests: ' + results.map(([n,ok])=> (ok?'âœ” ':'âœ– ') + n ).join(' Â· ');
	const cards=document.querySelectorAll('#controls .card'); 
	if(cards.length){ cards[cards.length-1].appendChild(out); }
	  }catch(e){ /* ignore diagnostics errors */ }
	}
	runSelfTests();

// --- Auto-frame hooks (one-time after UI changes) ---
try{
  if (typeof frameFrontOfPhoto === 'function'){
	if (presetSel){
	  presetSel.addEventListener('change', ()=>{ setTimeout(()=>{ try{ frameFrontOfPhoto(); }catch(_){} }, 0); });
	}
	if (fileInput){
	  fileInput.addEventListener('change', ()=>{
	setTimeout(()=>{ try{ frameFrontOfPhoto(); }catch(_){} }, 0);
	setTimeout(()=>{ try{ frameFrontOfPhoto(); }catch(_){} }, 50);
	  });
	}
  }
}catch(_){}

// --- UI init: defaults & sync (zoom step, pan focus, autofocus) ---
(function(){
  try{
	const z = document.getElementById('zoomStep');
	const zn = document.getElementById('zoomStepN');
	if (z && zn){
	  const sync = ()=>{ zn.value = z.value; };
	  const syncBack = ()=>{ z.value = zn.value; };
	  ['input','change'].forEach(evt=> z.addEventListener(evt, sync));
	  ['input','change'].forEach(evt=> zn.addEventListener(evt, syncBack));
	}
  }catch(_){}
  try{
	const panChk = document.getElementById('panLocksFocus');
	if (panChk){ panChk.checked = true; } // default CHECKED
  }catch(_){}
  try{
	canvas.setAttribute('tabindex','0');
	setTimeout(()=>{ try{ canvas.focus({preventScroll:true}); }catch(_){} }, 0);
	['pointerdown','mouseenter'].forEach(evt=>{
	  canvas.addEventListener(evt, ()=>{ try{ canvas.focus({preventScroll:true}); }catch(_){} }, {passive:true});
	});
  }catch(_){}
})();



// --- Inertia (throw) for orbit & Alt/RMB pan ---
function __resetPanVelocity(){ try{ __vx=0; __vy=0; __cancelInertia(); }catch(_){ } }
let __inertRAF=null, __vx=0, __vy=0, __lastMoveT=0;
function __cancelInertia(){ if(__inertRAF){ cancelAnimationFrame(__inertRAF); __inertRAF=null; } }
function __feedVelocity(dx,dy,dt){ if(dt<=0) return; const fx=dx/dt, fy=dy/dt; __vx=__vx*0.85+fx*0.15; __vy=__vy*0.85+fy*0.15; }


function __startPanInertia(){ try{ if (typeof __cancelInertia==='function') __cancelInertia(); }catch(_){ } return; }

// Around line 1925, replace the entire function

// Around line 1925, replace the entire function

// Around line 1925, replace the entire function

// Around line 1925, replace the entire function

// Around line 1925
// Around line 1925
// Around line 1925
// REPLACE the entire __startOrbitInertia function with this:

function __startOrbitInertia() {
  __cancelInertia();
  if (controls) controls.enabled = false;

  // This new constant controls how "strong" the coasting feels.
  // Higher value = more noticeable inertia. Let's start by tripling it.
  const INERTIA_SENSITIVITY = 0.005;

  let local_vx = __vx;
  let local_vy = __vy;
  const decay = 0.92;
  let prev = performance.now();

  const inertiaStartVec = new THREE.Vector3().copy(camera.position).sub(focus);
  const inertiaStartSph = new THREE.Spherical().setFromVector3(inertiaStartVec);

  __inertRAF = requestAnimationFrame(function step(t) {
	const dt = t - prev;
	prev = t;

	// Apply decayed velocity using our new sensitivity constant
	inertiaStartSph.theta -= local_vx * INERTIA_SENSITIVITY * dt;
	inertiaStartSph.phi -= local_vy * INERTIA_SENSITIVITY * dt;
	inertiaStartSph.phi = THREE.MathUtils.clamp(inertiaStartSph.phi, EPS, Math.PI - EPS);

	const v = new THREE.Vector3().setFromSpherical(inertiaStartSph);
	camera.position.copy(focus).add(v);
	camera.lookAt(focus);

	local_vx *= decay;
	local_vy *= decay;

	if (Math.hypot(local_vx, local_vy) < 0.1) {
	  __cancelInertia();
	  _endAndCleanupOrbit();
	  return;
	}
	__inertRAF = requestAnimationFrame(step);
  });
}

// Feed velocity from pointer move deltas (capture)
canvas.addEventListener('pointermove', (e)=>{
  const now=performance.now();
  const dx = (e.movementX!==undefined? e.movementX : 0);
  const dy = (e.movementY!==undefined? e.movementY : 0);
  __feedVelocity(dx,dy, Math.max(1, now - (__lastMoveT||now)));
  __lastMoveT = now;
}, true);
// --- Mobile TOUCH safety valve: cancel all sticky modes on touch-down (no effect on desktop) ---
canvas.addEventListener('pointerdown', (e) => {
  if (e.pointerType === 'touch') {
    try { if (typeof panActive !== 'undefined' && panActive && typeof endPan === 'function') endPan(false); } catch(_) {}
    try { window.__orbitLatched = false; } catch(_) {}
    try { rmbLatched = false; } catch(_) {}
    try { rightDown = false; leftDown = false; hasDragged = false; rightHasDragged = false; } catch(_) {}
    try { if (typeof controls !== 'undefined' && controls) controls.enabled = true; } catch(_) {}
  }
}, true);
// Cancel on new input
canvas.addEventListener('pointerdown', ()=>{ try{ __cancelInertia(); }catch(_){ } }, true);
window.addEventListener('keydown', ()=>{ try{ __cancelInertia(); }catch(_){ } }, true);
// ===== Enhanced interactions: Alt(Option)-pan override, A/Z continuous zoom, sticky left-click orbit (v13) =====
(function(){
  if (!canvas) return;
  const rect = ()=>canvas.getBoundingClientRect();
  try{ if(canvas.style) canvas.style.touchAction='none'; }catch(_){}

  // State
  let altHeld = false;
  let panGestureLock = false;  // latch Alt-pan for the duration of a left-drag
  
  let panOverride = false;   // true when we switched to pan while sticky-rotating (no mouse button)
  let leftDown  = false; let rightDown=false, rmbLatched=false; let rmbDownAt=0, rmbDownX=0, rmbDownY=0;
  let __rmbCancelOnly = false;
  let panStartX=0, panStartY=0, lastX=0, lastY=0;
  let hasDragged = false; 
  let rightHasDragged = false; // NEW: State for right-click drag detection
  let panStartFocus = new THREE.Vector3();
  let panStartCamPos = new THREE.Vector3();
  let panStartTarget = new THREE.Vector3();
  let panStartQuaternion = new THREE.Quaternion();
  let panRight0 = new THREE.Vector3();
  let panUp0 = new THREE.Vector3();
  let panSnap = null; // snapshot of cyl at pan start
  let rafFocusSync = false;
  let lastFocusSyncMs = 0;   // throttle DOM sync to reduce jerk when "pan updates focus" is enabled
  

  // Continuous zoom state
  let aHeld=false, zHeld=false, zoomRAF=null, lastZoomT=0;
// Sticky orbit: toggle rotate on quick tap (if enabled)
  window.__orbitLatched = window.__orbitLatched || false;
  let latchOrbit = window.__orbitLatched;
  let clickDownAt = 0, clickDownX = 0, clickDownY = 0;
  const CLICK_TOL_PX = 8, CLICK_TOL_MS = 250;

  // NEW: A robust function to handle exiting pan mode and correctly sync OrbitControls.
  function endPan(withInertia = false) {
	  if (!panActive) return;
  
	  panActive = false;
	  
	  // FIX: Update the pivot's position BEFORE re-attaching the camera.
	  // This prevents the camera's local transform from being calculated against a stale pivot position.
	  pivot.position.copy(focus);
	  pivot.attach(camera); // Re-parent camera to the pivot.
	  
	  if (controls) {
	  // CRITICAL FIX: Sync OrbitControls state AFTER re-parenting and BEFORE it's re-enabled.
	  controls.target.copy(focus);
	  controls.update(); 
	  }
  
	  suppressPanLock = false;
	  panGestureLock = false;
  
	  // Decide whether to start inertia or stop completely.
	  if (withInertia && Math.hypot(__vx, __vy) > 0.1) { // MODIFIED: Lowered threshold for pan inertia
	  if (controls) controls.enabled = false; // Disable during custom animation
	  __startPanInertia(); // This function will now re-enable controls when it's done.
	  } else {
	  if (controls) controls.enabled = true;
	  __resetPanVelocity();
	  }
	  __unlockPointerIfLocked();
  }

  function stopRotate(){
	// try{ endRotate?.(); }catch(_){} // This is the old function, we don't need it.
	try{ orbitRotating=false; cylRotating=false; }catch(_){}
	try{ if(controls) controls.enabled = true; }catch(_){}
  }
  
  // Baseline refresh used by sticky-orbit + zoom
  function refreshRotateBaseline(x, y) {
	try {
	  // If zoom animation is still running, don't do full cleanup
	  // Just set up orbit from current world position - they can coexist
	  if (__wheelZoomRAF) {
		// Ensure camera is in world space (zoom already does this)
		if (camera.parent !== scene) {
		  scene.attach(camera);
		}
		// Set up orbit baseline from current position
		if (controls) controls.enabled = false;
		startX = x; startY = y;
		orbitRotating = true;
		cylRotating = false;
		startVec.copy(camera.position).sub(focus);
		return;
	  }
	  
	  // Normal case: no zoom active, do full cleanup
	  _endAndCleanupOrbit();               // ensure world-space camera
	  if (controls) controls.enabled = false;
	  startX = x; startY = y;              // new drag anchor
	  orbitRotating = true;                // single-flag rotate mode
	  cylRotating = false;
	  startVec.copy(camera.position).sub(focus); // world-space baseline
	} catch (_) {}
  }
  
  // Add this new function after the existing refreshRotateBaseline function (around line 1444):
  
  // Update baseline during sticky-orbit without cleanup/reset
  // Replace the updateStickyOrbitBaseline function with this simpler one:
  
  function updateStickyOrbitBaselineRadius() {
	try {
	  // Ensure camera is in world space (should already be during sticky-orbit)
	  if (camera.parent !== scene) {
		scene.attach(camera);
	  }
	  
	  // Update baseline vector from current world position
	  // CRITICAL: Do NOT touch startX, startY - keep them from last mouse move
	  startVec.copy(camera.position).sub(focus);
	  
	  // Keep rotation flags active
	  orbitRotating = true;
	  cylRotating = false;
	  
	  // Ensure controls stay disabled
	  if (controls) controls.enabled = false;
	} catch (_) {}
  }

  // REPLACE the entire refreshRotateBaseline function with this:
  
  
  function startRotateAt(x,y){
	try{
	  if(controls) controls.enabled = false;
	  refreshRotateBaseline(x,y);
	}catch(_){}
  }
  function startPanAt(x,y){
	panActive = true;
	try{ if(controls) controls.enabled = false; }catch(_){}
	scene.attach(camera);
	__lockPointerIfNeeded();
	panStartX = x; panStartY = y;
	panStartFocus.copy(focus);
	
	try{ suppressPanLock = true; }catch(_){ }
	try{ 
	camera.getWorldPosition(panStartCamPos);
	panStartQuaternion.copy(camera.quaternion);
	} catch(_){}
	try{
	  if (controls && controls.target){ panStartTarget.copy(controls.target); }
	  else { panStartTarget.copy(focus); }
	}catch(_){ panStartTarget.copy(focus); }
	try{
	  panRight0.setFromMatrixColumn(camera.matrix, 0);
	  panUp0.setFromMatrixColumn(camera.matrix, 1);
	  panSnap = cylFromCamera();
	}catch(_){ panSnap = null; }
  }
  function scheduleFocusSync(){
	if(rafFocusSync) return;
	rafFocusSync = true;
	requestAnimationFrame(()=>{
	  rafFocusSync = false;
	  try{
	const chk = document.getElementById('panLocksFocus');
	const now = performance.now();
	if (!chk || chk.checked){
	  if (now - lastFocusSyncMs > 22){
		lastFocusSyncMs = now;
		updateFocusInputs({syncControls:true});
	  }
	}
	  }catch(_){}
	  try{ if(controls) controls.update(); }catch(_){}
	});
  }

  // --- Alt(Option) clutch with mid-drag switching and STICKY override ---
  window.addEventListener('keydown', (e)=>{
	if(e.key==='Alt'){
	  altHeld = true;
	  if (leftDown && !panActive){
	stopRotate();
	panOverride = false;
	panGestureLock = true; startPanAt(lastX, lastY);
	  }
	  if (!leftDown && (window.__orbitLatched || latchOrbit) && !panActive){
	stopRotate();
	panOverride = true;
	startPanAt(lastX, lastY);
	  }
	}
  }, {passive:true});

  // --- FIX: Patched keyup listener to handle state transitions correctly ---
  window.addEventListener('keyup', (e) => {
	  if (e.key !== 'Alt') return;
	  
	  altHeld = false;

	  // If we were in a pan locked to the left mouse button (LMB),
	  // and the LMB is still being held down...
	  if (panGestureLock && leftDown) {
	  // ...then we revert from panning back to orbiting.
	  endPan(false); // End the pan without inertia.
	  panGestureLock = false; // The LMB is no longer co-opted for panning

	  // The user is still holding the mouse down, expecting to rotate now.
	  // So, we start a rotation from the current cursor position.
	  startRotateAt(lastX, lastY);
	  } 
	  // This handles other pan types, like sticky RMB pan, that should stop when Alt is released.
	  else if (true /* always dolly zoom for A/Z as well */) {
	  endPan(false); // End pan without inertia.
	  
	  // After exiting Alt-pan mid-drag, reinitialize orbit baseline so phi/elev and zoom behave normally.
	  if (leftDown){
		try{ panGestureLock = false; }catch(_){}
		try{ __resetPanVelocity?.(); }catch(_){}
		try{ startRotateAt(lastX, lastY); }catch(_){}
	  }
} 
	  // This handles the case where sticky orbit was overridden by an Alt-pan
	  else if (panOverride && !panGestureLock) {
	  __resetPanVelocity();
	  stopRotate();
	  panOverride = false;
	  startRotateAt(lastX, lastY);
	  }
  }, {passive:true});

  // --- Continuous A/Z zoom while held (runs alongside orbit/pan) ---
  function zoomLoop(t){
	if(!(aHeld||zHeld)){ zoomRAF=null; return; }
	if(!lastZoomT) lastZoomT = t;
	const dt = Math.max(0, Math.min(100, t - lastZoomT));
	lastZoomT = t;

	// FIX: Invert zoom direction. Z should move closer (decrease radius/distance).
	let dir = (zHeld? -1:0) + (aHeld? 1:0);

	if (dir !== 0){
	  const zEl = document.getElementById('zoomStep');
	  const pct = Math.max(0.5, Math.min(90, parseFloat((zEl && zEl.value) || '1')));
	  const per = 1 + dir * (pct/100);
	  const frames = dt / 16.7;
	  const factor = Math.pow(per, frames);

	  const minDEl = document.getElementById('minDist');
	  const maxDEl = document.getElementById('maxDist');
	  const minD = parseFloat((minDEl && minDEl.value) || 0.01);
	  const maxD = parseFloat((maxDEl && maxDEl.value) || 100);

	  if (panActive) {
	  // When panning, dolly along the view vector to prevent elevation drift.
	  const viewVector = new THREE.Vector3();
	  viewVector.copy(focus).sub(camera.position).normalize();

	  const currentDist = camera.position.distanceTo(focus);
	  const newDist = THREE.MathUtils.clamp(currentDist * factor, minD, maxD);
	  
	  if (Math.abs(currentDist - newDist) > 1e-6) { // Only update if there's a meaningful change
		  const moveDist = currentDist - newDist;
		  camera.position.addScaledVector(viewVector, moveDist);

		  // FIX: Reset the *entire* pan reference frame to the new state after zooming.
		  // This makes the next pan movement calculate its delta from the new, correct state,
		  // preventing both the snap-back and the elevation drift.
		  panStartCamPos.copy(camera.position);
		  panStartFocus.copy(focus);
		  panStartQuaternion.copy(camera.quaternion);
		  panRight0.setFromMatrixColumn(camera.matrix, 0);
		  panUp0.setFromMatrixColumn(camera.matrix, 1);
		  panStartX = lastX;
		  panStartY = lastY;
	  }
	  } else {
	  // When not panning, use the simpler pivot rig.
	  const c = cylFromCamera();
	  const newR = THREE.MathUtils.clamp(c.r * factor, minD, maxD);
	  if (newR !== c.r) {
		applyRig(c.phi, newR, c.elev);
		try{ if (typeof dragR !== 'undefined') dragR = newR; }catch(_){}
	  }
	  }
	}
	zoomRAF = requestAnimationFrame(zoomLoop);
  }

  function startZooming(){
	if(zoomRAF==null){
	  lastZoomT = 0;
	  zoomRAF = requestAnimationFrame(zoomLoop);
	}
  }
  function stopZoomingIfIdle(){
	if(!(aHeld||zHeld) && zoomRAF!=null){
	  cancelAnimationFrame(zoomRAF);
	  zoomRAF = null;
	  lastZoomT = 0;
	}
  }

  window.addEventListener('keydown', (e)=>{
	const ae = document.activeElement;
	const tag = (ae && ae.tagName) || '';
	if (tag === 'INPUT' || tag === 'TEXTAREA' || tag === 'SELECT' || tag === 'BUTTON') return;
	if (e.repeat) return;
	const key = (e.key||'').toLowerCase();
	const code = e.code||'';
	if (key==='a' || code==='KeyA'){ e.preventDefault(); aHeld = true; startZooming(); }
	if (key==='z' || code==='KeyZ'){ e.preventDefault(); zHeld = true; startZooming(); }
  }, false);

  window.addEventListener('keyup', (e)=>{
	const key = (e.key||'').toLowerCase();
	const code = e.code||'';
	if (key==='a' || code==='KeyA'){ aHeld = false; stopZoomingIfIdle(); }
	if (key==='z' || code==='KeyZ'){ zHeld = false; stopZoomingIfIdle(); }
  }, false);

  // --- Pointer handlers ---
  
// Sticky right-click pan (tap to toggle latched pan)
  canvas.addEventListener('pointerdown', (e) => {
	if (e.pointerType === 'mouse' && e.button === 2) {
	  rightDown = true;
	  try { if (e.pointerId != null) canvas.setPointerCapture(e.pointerId); } catch (_){}
	  rightHasDragged = false; // Reset drag detection flag
  
	  rmbDownAt = performance.now();
	  rmbDownX = e.clientX;
	  rmbDownY = e.clientY;
  
	  if (window.__orbitLatched) {
		// we're in sticky-orbit â†’ treat RMB as "cancel candidate"
		__rmbCancelOnly = true; // do NOT start pan yet
	  } else {
		// NEW: Don't start panning immediately - wait to see if it's a tap or drag
		__rmbCancelOnly = false;
		// DON'T call startPanAt here anymore
	  }
	}
  }, true);





canvas.addEventListener('pointerdown', (e)=>{
	const left = e.pointerType==='mouse' && e.button===0 && !e.shiftKey;
	if (left){
	  try{ if(e.pointerId!=null) canvas.setPointerCapture(e.pointerId); }catch(_){}
	  leftDown = true;
	  hasDragged = false;
	  clickDownAt = performance.now();
	  clickDownX = e.clientX; clickDownY = e.clientY;
	  if (altHeld || e.altKey){
		panGestureLock = true;
		e.stopImmediatePropagation();
		e.preventDefault();
		stopRotate();
		panOverride = false;
		startPanAt(e.clientX, e.clientY);
	  } else {
		// --- THIS IS THE NEW BLOCK TO ADD ---
		
		// ---------------------------------
	  }
	}
  }, true);

  function onPointerMove(e){
	lastX = e.clientX; lastY = e.clientY;

	// PATCH: Handle drag detection
	if (leftDown && !hasDragged && !panActive) {
	const moved = Math.hypot(e.clientX - clickDownX, e.clientY - clickDownY);
	if (moved > CLICK_TOL_PX) {
		hasDragged = true;
		refreshRotateBaseline(clickDownX, clickDownY); // This sets rotating=true
	}
	}
	
	// NEW: Handle right-click drag detection consistently
	// Handle right-click drag detection
	if (rightDown && !rightHasDragged && !panActive){
	  const moved = Math.hypot(e.clientX - rmbDownX, e.clientY - rmbDownY);
	  if (moved > CLICK_TOL_PX){
		rightHasDragged = true;
		if (window.__orbitLatched) {
		  // Cancel sticky orbit first
		  window.__orbitLatched = false;
		  _endAndCleanupOrbit();
		}
		startPanAt(rmbDownX, rmbDownY);
	  }
	}


	
	if (orbitRotating && !panActive) { // We now only use one flag and one function
	  const dx = e.clientX - startX;
	  const dy = e.clientY - startY;
	  applyOrbitFromStart(dx, dy);

	// If we are in latched mode OR zoom is running, continuously update the reference point
	// This prevents hyper-magnified movements when orbiting during zoom inertia
	if (window.__orbitLatched || __wheelZoomRAF) {
		startX = e.clientX;
		startY = e.clientY;
		startVec.copy(camera.position).sub(focus);
	}
	}

	if (panActive && (altHeld || e.altKey || rmbLatched || panGestureLock || rightDown)) {
	  // Guard: If distance changed since the pan baseline (e.g., wheel dolly while latched),
	  // resync the entire baseline to prevent snap-back on the next mouse move.
	  try{
		const __curDist = camera.position.distanceTo(focus);
		const __baseDist = panStartCamPos.distanceTo(panStartFocus);
		if (Math.abs(__curDist - __baseDist) > 1e-6){
		  camera.getWorldPosition(panStartCamPos);
		  panStartFocus.copy(focus);
		  panStartQuaternion.copy(camera.quaternion);
		  panRight0.setFromMatrixColumn(camera.matrix, 0);
		  panUp0.setFromMatrixColumn(camera.matrix, 1);
		  panStartX = e.clientX; panStartY = e.clientY;
		}
	  }catch(_){}

	  try{ suppressPanLock = true; }catch(_){ }
e.preventDefault();
	  e.stopImmediatePropagation();
	  const dx = e.clientX - panStartX, dy = e.clientY - panStartY;
	  const c = cylFromCamera();
	  const vfov = camera.fov * Math.PI/180;
	  const {width:w, height:h} = rect();
	  const aspect = camera.aspect || (w/h || 1);
	  const hfov = 2*Math.atan(Math.tan(vfov/2)*aspect);
	  
	  const panLocks = document.getElementById('panLocksFocus');
	  const panUpdatesFocus = !panLocks || panLocks.checked;

	  if (!panUpdatesFocus){
	const scaleX = 2 * c.r * Math.tan(hfov/2);
	  const scaleY = 2 * c.r * Math.tan(vfov/2);
	const right = new THREE.Vector3().setFromMatrixColumn(camera.matrix, 0);
	const upv   = new THREE.Vector3().setFromMatrixColumn(camera.matrix, 1);
	const worldDX = -dx / Math.max(1,w) * scaleX;
	const worldDY =  dy / Math.max(1,h) * scaleY;
	const delta = right.multiplyScalar(worldDX).add(upv.multiplyScalar(worldDY));
	camera.position.add(delta);
	try{ if (controls && controls.target) controls.target.add(delta); }catch(_){}
	controls?.update?.();
	  } else {
	// Pan-updates-focus ON: This is the corrected "true strafe" logic.
	
	// 1. Get the camera's "right" and "up" vectors at the start of the pan.
	const basisR = (panRight0 && panRight0.lengthSq() > 0) ? panRight0 : new THREE.Vector3().setFromMatrixColumn(camera.matrix, 0);
	const basisU = (panUp0 && panUp0.lengthSq() > 0) ? panUp0 : new THREE.Vector3().setFromMatrixColumn(camera.matrix, 1);

	// 2. Determine the pan magnitude based on mouse movement and camera distance.
	const dist = panStartCamPos.distanceTo(panStartFocus);
	const scaleX = 2 * dist * Math.tan(hfov / 2);
	const scaleY = 2 * dist * Math.tan(vfov / 2);
	const moveMagnitudeX = -dx / Math.max(1, w) * scaleX;
	const moveMagnitudeY = dy / Math.max(1, h) * scaleY;
	
	// 3. Calculate the intended movement delta in 3D space.
	const delta = basisR.clone().multiplyScalar(moveMagnitudeX).add(basisU.clone().multiplyScalar(moveMagnitudeY));

	// 4. Apply delta to get a potential new focus point.
	const newFocusAttempt = panStartFocus.clone().add(delta);
	
	// FIX: Clamp the new focus point to the photo's boundaries to prevent runaway values.
	// Calculate actual mesh dimensions (must match createOrUpdatePhotoMesh logic)
	const PIXEL_SCALE = 0.00025;
	const useNativeDimensions = (typeof window.photoWidth === 'number' && typeof window.photoHeight === 'number');
	
	let width, height;
	if (useNativeDimensions) {
	  width = window.photoWidth * PIXEL_SCALE;
	  height = window.photoHeight * PIXEL_SCALE;
	} else {
	  width = 1;
	  height = width / photoAspect;
	}
	
	const clampedX = THREE.MathUtils.clamp(newFocusAttempt.x, -width/2, width/2);
	const clampedY = THREE.MathUtils.clamp(newFocusAttempt.y, -height/2, height/2);
	const newClampedFocus = new THREE.Vector3(clampedX, clampedY, 0);
	
	// 5. Calculate the *actual* delta applied after clamping.
	const actualDelta = newClampedFocus.clone().sub(panStartFocus);
	
	// 6. Apply this actual, clamped delta to the camera's start position.
	const newCamWorldPos = panStartCamPos.clone().add(actualDelta);
	
	// 7. Update the live state for the camera and focus.
	focus.copy(newClampedFocus);
	camera.position.copy(newCamWorldPos);
	
	// 8. Restore the original orientation to ensure a pure strafe without any rotation.
	camera.quaternion.copy(panStartQuaternion);
	
	// 9. Update the OrbitControls target to prevent conflicts.
	const t = safeTarget();
	if (t) t.copy(focus);
	
	scheduleFocusSync();
	  }
	} else if (panActive && !(altHeld || e.altKey) && !panGestureLock && !rightDown && !rmbLatched) {
	  endPan(true);
	  if (panOverride && (window.__orbitLatched || latchOrbit)){
	startRotateAt(e.clientX, e.clientY);
	panOverride = false;
	  }
	}
  }
  canvas.addEventListener('pointermove', onPointerMove, {passive:false, capture:true});
  // NEW: while latched (sticky-orbit) or during a pan, also listen at the window level
  window.addEventListener('pointermove', (e) => {
    if (e.pointerType !== 'touch' && (window.__orbitLatched || panActive)) onPointerMove(e);
  }, {passive:false});



  // --- FIX: Patched pointerup listener to handle state transitions correctly ---
  // Around line 2085

window.addEventListener('pointerup', (e) => {
  // Mobile TOUCH guard: always end any custom pan/latched states and re-enable controls; don't run desktop sticky logic.
  if (e.pointerType === 'touch') {
    try { if (typeof panActive !== 'undefined' && panActive && typeof endPan === 'function') endPan(false); } catch(_) {}
    try { window.__orbitLatched = false; } catch(_) {}
    try { rmbLatched = false; } catch(_) {}
    try { if (typeof controls !== 'undefined' && controls) controls.enabled = true; } catch(_) {}
    try { orbitRotating = false; } catch(_) {}
    return;
  }
	try { if (e.pointerId != null) canvas.releasePointerCapture(e.pointerId); } catch (_) {}
  
	const left = e.pointerType === 'mouse' && e.button === 0 && !e.shiftKey;
  
	if (left) {
	  const wasPanGesture = panGestureLock;
	  leftDown = false;
	  panGestureLock = false;
  
	  if (panActive) {
		// Left-up while a pan was active â†’ end pan (no inertia)
		endPan(false);
	  } else if (hasDragged) {
		// This was a non-sticky orbit drag. Start the inertia.
		
		orbitRotating = false;   // keep: prevents double-rotation state
		// The inertia function will call the cleanup when it's done.
		__startOrbitInertia();
	  } else {
		// This was a tap.
  
		// If a dblclick just fired, consume the flag and do nothing.
		if (window.__ignoreNextTap) {
		  window.__ignoreNextTap = false;
		  return;
		}
  
		if (controls) controls.enabled = true;
  
		const stickyEl = document.getElementById('stickyOrbit');
		const sticky   = stickyEl ? stickyEl.checked : true;   // your existing default
		const dt       = performance.now() - clickDownAt;
  
		// --- UNIVERSAL CANCEL ON QUICK LMB TAP ---
		// If any sticky mode is active (pan/orbit/RMB latch), a quick left tap cancels it all.
		// ALSO: If clicking from OUTSIDE the canvas, always cancel sticky modes (no time check needed)
		// --- UNIVERSAL CANCEL ON QUICK LMB TAP ---
		const hadOrbit = !!window.__orbitLatched;
		const hadPan   = !!panActive;
		const hadRMB   = !!rmbLatched;
		const anySticky = (hadOrbit || hadPan || hadRMB);
		
		// Check if this click came from outside the canvas
		const canvasEl = canvas || document.getElementById('gl');
		const path = (typeof e.composedPath === 'function') ? e.composedPath() : null;
		const clickedCanvas = path ? path.includes(canvasEl) : (canvasEl && canvasEl.contains(e.target));
		const clickedOutside = !clickedCanvas;
		
		// Cancel sticky modes if: (quick tap on canvas) OR (any click from outside canvas)
		if (anySticky && (dt < CLICK_TOL_MS || clickedOutside)) {
		  try { 
			if (typeof __cancelAllSticky === 'function') { __cancelAllSticky(); }
			else { throw new Error('no helper'); }
		  } catch(_) {
			try{ if (panActive) endPan(false); }catch(_){}
			try{ _endAndCleanupOrbit(); }catch(_){}
			try{ rmbLatched = false; }catch(_){}
			try{ panOverride=false; panGestureLock=false; rightDown=false; leftDown=false; hasDragged=false; rightHasDragged=false; }catch(_){}
			try{ if (controls) controls.enabled = true; }catch(_){}
		  }
		  // If the ONLY sticky was an RMB latch, fall through so we can also toggle sticky-orbit now.
		  if (!(hadRMB && !hadOrbit && !hadPan)) return;
		}
		// --- END UNIVERSAL CANCEL ---

  
		// Regular sticky-orbit toggle on quick tap
		if (sticky && dt < CLICK_TOL_MS) {
		  window.__orbitLatched = !window.__orbitLatched;
		  latchOrbit = window.__orbitLatched;
  
		  if (window.__orbitLatched) {
			if (controls) controls.enabled = false;
			__lockPointerIfNeeded();
			refreshRotateBaseline(e.clientX, e.clientY);
		  } else {
			// Just latched OFF a sticky-orbit â†’ run the unified cleanup
			__unlockPointerIfLocked();
			_endAndCleanupOrbit();
		  }
		}
	  }
	}
	// Right mouse button handling
	if (e.pointerType === 'mouse' && e.button === 2) {
	  rightDown = false;
	  
	  if (__rmbCancelOnly) {
		  __rmbCancelOnly = false;
		  if (window.__orbitLatched) {
			window.__orbitLatched = false;
			_endAndCleanupOrbit();
		  }
		  // Do not toggle rmbLatched or startPanAt()
		  return;
		}
	  
	  if (panActive) {
		// Was panning with RMB - end it
		endPan(false);
	  } else if (!rightHasDragged) {
		// Quick tap without drag - toggle RMB latch
		const dt = performance.now() - rmbDownAt;
		if (dt < CLICK_TOL_MS) {
		  rmbLatched = !rmbLatched;
		  if (rmbLatched) {
			if (controls) controls.enabled = false;
			startPanAt(e.clientX, e.clientY);
		  } else {
			endPan(false);
		  }
		}
	  }
	  
	  rightHasDragged = false;
	}
  });

function __lockPointerIfNeeded(){
	if (!INFINITE_DRAG) return;
	if (document.pointerLockElement !== canvas){
	  try { canvas.requestPointerLock({ unadjustedMovement: true }); } catch(_) {}
	}
  }
  function __unlockPointerIfLocked(){
	if (!INFINITE_DRAG) return;
	if (document.pointerLockElement === canvas){
	  try { document.exitPointerLock(); } catch(_) {}
	}
  }
  
  // When locked, browsers send `mousemove` deltas (not always pointermove), so forward those too:
  document.addEventListener('mousemove', (e)=>{
	if (document.pointerLockElement === canvas) onPointerMove(e);
  }, {passive:false});

  // Cancel states
  window.addEventListener('blur', ()=>{ panActive=false; panOverride=false; window.__orbitLatched=false; rmbLatched = false; stopRotate(); aHeld=false; zHeld=false; __unlockPointerIfLocked(); });
  window.addEventListener('keydown', (e)=>{ if(e.key==='Escape'){ panActive=false; panOverride=false; window.__orbitLatched=false; rmbLatched = false; stopRotate(); aHeld=false; zHeld=false; __unlockPointerIfLocked(); } });

})();

/* --- Patch: gate window-level pointerup to only act on sequences that started on the canvas,
   && reset hasDragged at the end of a sequence. This prevents outside-clicks from moving the photo. --- */
(function(){
  const canvas = document.getElementById('gl');
  if (!canvas) return;

  let __seqOnCanvas = false;
  let __seqPointerId = null;

  // Track where the current primary-pointer sequence began
  window.addEventListener('pointerdown', (e)=>{
	// Primary/left only
	if (e.button !== 0) return;
	
	// Check if any sticky mode is currently active
	const hasStickyOrbit = !!(typeof window.__orbitLatched !== 'undefined' && window.__orbitLatched);
	const hasStickyPan = !!(typeof panActive !== 'undefined' && panActive);
	const hasRMBLatch = !!(typeof rmbLatched !== 'undefined' && rmbLatched);
	const anySticky = hasStickyOrbit || hasStickyPan || hasRMBLatch;
	
	// If sticky mode is active, treat this as if it's on canvas (so release works anywhere)
	if (anySticky) {
	  __seqOnCanvas = true;
	  __seqPointerId = (e.pointerId !== undefined) ? e.pointerId : null;
	  return;
	}
	
	// Did this begin on the canvas?
	const path = (typeof e.composedPath === 'function') ? e.composedPath() : null;
	const onCanvas = path ? path.includes(canvas) : (canvas.contains(e.target));
	__seqOnCanvas = !!onCanvas;
	__seqPointerId = (e.pointerId !== undefined) ? e.pointerId : null;
  }, true); // capture

  // Capture-phase blocker: if sequence didn't start on canvas, block downstream window pointerup handlers
  // EXCEPTION: Always allow pointerup if a sticky mode is active so user can release it anywhere
  
window.addEventListener('pointerup', (e) => {
  // Mobile TOUCH guard: always end any custom pan/latched states and re-enable controls; don't run desktop sticky logic.
  if (e.pointerType === 'touch') {
    try { if (typeof panActive !== 'undefined' && panActive && typeof endPan === 'function') endPan(false); } catch(_) {}
    try { window.__orbitLatched = false; } catch(_) {}
    try { rmbLatched = false; } catch(_) {}
    try { if (typeof controls !== 'undefined' && controls) controls.enabled = true; } catch(_) {}
    try { orbitRotating = false; } catch(_) {}
    return;
  }
	if (e.button !== 0) return;
	const samePointer = (__seqPointerId === null) || (e.pointerId === __seqPointerId);
	
	// Check if any sticky mode is currently active
	const hasStickyOrbit = !!(typeof window.__orbitLatched !== 'undefined' && window.__orbitLatched);
	const hasStickyPan = !!(typeof panActive !== 'undefined' && panActive);
	const hasRMBLatch = !!(typeof rmbLatched !== 'undefined' && rmbLatched);
	const anySticky = hasStickyOrbit || hasStickyPan || hasRMBLatch;
	
	// If a sticky mode is active, ALWAYS let the pointerup through (so user can release anywhere)
	if (anySticky) {
	  // Let it pass through to the main handler
	  return;
	}
	
	if (!__seqOnCanvas || !samePointer){
	  try { e.stopImmediatePropagation(); } catch(_) {}
	  try { e.stopPropagation(); } catch(_) {}
	  // Clean up && make sure any stale drag flags are cleared
	  try { hasDragged = false; } catch(_) {}
	  try { leftDown = false; } catch(_) {}
	  __seqOnCanvas = false;
	  __seqPointerId = null;
	  return;
	}
  }, true); // capture

  // Bubble-phase cleanup after original handlers have run: clear flags at end of valid canvas sequence
  window.addEventListener('pointerup', (e)=>{
	if (e.button !== 0) return;
	if (!__seqOnCanvas) return;
	__seqOnCanvas = false;
	__seqPointerId = null;
	try { hasDragged = false; } catch(_) {}
  }, false);

  // Robustness: clear on blur || when tab is hidden
  const __clear = ()=>{
	__seqOnCanvas = false;
	__seqPointerId = null;
	try { hasDragged = false; } catch(_) {}
	try { leftDown = false; } catch(_) {}
  };
  window.addEventListener('blur', __clear, true);
  document.addEventListener('visibilitychange', ()=>{
	if (document.visibilityState !== 'visible') __clear();
  }, true);
})();
/* --- End patch --- */


// === expose photo globals for deck (fixL) ===
(() => {
  try {
    const _export = () => {
      try {
        if (typeof photoMesh !== 'undefined') globalThis.photoMesh = photoMesh;
        if (typeof photoCoat !== 'undefined') globalThis.photoCoat = photoCoat;
        if (typeof photoTex !== 'undefined') globalThis.photoTex = photoTex;
        if (typeof photoAspect !== 'undefined') globalThis.photoAspect = photoAspect;
      } catch(_) {}
    };
    _export();

    if (typeof createOrUpdatePhotoMesh === 'function') {
      const __origCreate = createOrUpdatePhotoMesh;
      createOrUpdatePhotoMesh = function(...args){
        const out = __origCreate.apply(this, args);
        try { _export(); } catch(_){}
        return out;
      };
    }

    try {
      const single = document.getElementById('file');
      if (single) {
        ['change','input'].forEach(evt => single.addEventListener(evt, () => {
          setTimeout(_export, 0);
          setTimeout(_export, 50);
          setTimeout(_export, 150);
          setTimeout(_export, 400);
        }));
      }
    } catch(_){}
  } catch (err) {
    console.warn('fixL exporter failed', err);
  }
})();
// === end expose photo globals (fixL) ===


// --- Patch: TedEnv azimuth + elevation (front = -Z), back is opposite azimuth ---
(function(){
  const G = (typeof globalThis!=='undefined'?globalThis:window);
  if (!G.TedEnv) return;

  G.TedEnv.build = function(renderer, params){
    const ambI  = Number(params && params.ambI != null ? params.ambI : 1.0);
    const keyI  = Number(params && params.keyI != null ? params.keyI : 1.0);
    const backI = Number(params && params.backI != null ? params.backI : 1.0);
    const elevDeg = Number(params && params.keyElevDeg != null ? params.keyElevDeg
                   : (params && params.keyAngDeg != null ? params.keyAngDeg : 15));
    const azDeg   = Number(params && params.keyAzDeg != null ? params.keyAzDeg : 0);

    const elev = THREE.MathUtils.degToRad(elevDeg);
    const az   = THREE.MathUtils.degToRad(azDeg);
    const R = 6.0;
    const cx = Math.cos(elev);
    const sx = Math.sin(elev);
    // Front is -Z in this app's convention
    const xk = R * cx * Math.sin(az);
    const yk = R * sx;
    const zk = -R * cx * Math.cos(az);

    // Back = opposite azimuth, same elevation (180Â° away)
    const xb = -xk, yb = yk, zb = -zk;

    if (!this.pmrem) this.pmrem = new THREE.PMREMGenerator(renderer);
    if (!this.scene){
      this.scene = new THREE.Scene();
      this.scene.background = new THREE.Color(0x050607);
      const mkPanel = (sc,w,h)=>{ const g=new THREE.PlaneGeometry(w,h); const m=new THREE.MeshBasicMaterial({color:0xffffff,transparent:true,opacity:1}); const q=new THREE.Mesh(g,m); sc.add(q); return q; };
      this.boxes = this.boxes || {};
      this.boxes.key  = this.boxes.key  || mkPanel(this.scene, 6.0, 3.0);
      this.boxes.key2 = this.boxes.key2 || mkPanel(this.scene, 6.0, 3.0);
      this.boxes.fill = this.boxes.fill || mkPanel(this.scene, 4.0, 2.2);
      this.boxes.back = this.boxes.back || mkPanel(this.scene, 8.0, 8.0);
    }

    const key = this.boxes.key;  key.position.set(xk, yk, zk); key.lookAt(0,0,0);
    const key2 = this.boxes.key2; key2.position.copy(key.position); key2.rotation.copy(key.rotation);
    const fill = this.boxes.fill; fill.position.set(-xk*0.6, yk*0.5, zk*0.7 - 1.4); fill.lookAt(0,0,0);
    const back = this.boxes.back; back.position.set(xb, yb, zb); back.lookAt(0,0,0);

    key.material.opacity  = Math.min(1, keyI * 1.0);
    key.material.color.setRGB(4.0,4.0,4.0);
    key2.material.opacity = Math.min(1, keyI * 1.0);
    key2.material.color.setRGB(4.0,4.0,4.0);

    fill.material.opacity = Math.min(1, ambI * 1.0);
    fill.material.color.setRGB(2.5,2.5,2.5);

    back.material.opacity = Math.min(1, backI * 1.0);
    back.material.color.setRGB(3.0,3.0,3.0);

    try { if (this.rt) { if (this.rt.texture && this.rt.texture.dispose) this.rt.texture.dispose(); if (this.rt.dispose) this.rt.dispose(); } } catch(e){}
    this.rt = this.pmrem.fromScene(this.scene, 0.04);
    this.tex = this.rt.texture;

    // Also move real scene lights if present
    try{
      if (G.keyLight){ G.keyLight.position.set(xk, yk, zk); G.keyLight.intensity = keyI; if(G.keyLight.target) G.keyLight.target.position.set(0,0,0); }
      if (G.backLight){ G.backLight.position.set(xb, yb, zb); G.backLight.intensity = backI; if(G.backLight.target) G.backLight.target.position.set(0,0,0); }
      if (G.ambLight) { G.ambLight.intensity = ambI; }
    }catch(e){}

    return this.tex;
  };

  G.TedEnv.refreshFromUI = function(){
    try{
      const amb  = parseFloat((document.getElementById('amb')||{}).value || 1);
      const key  = parseFloat((document.getElementById('key')||{}).value || 1);
      const back = parseFloat((document.getElementById('backKey')||{}).value || 1);
      const elev = parseFloat((document.getElementById('keyAng')||{}).value || 0);
      const az   = parseFloat((document.getElementById('keyAz')||{}).value || 0);
      const r = G.renderer || G['renderer'];
      if (!r) { setTimeout(G.TedEnv.refreshFromUI, 120); return; }
      const tex = G.TedEnv.build(r, { ambI:amb, keyI:back, backI:key, keyElevDeg:elev, keyAzDeg:az });
      if (G.scene) G.scene.environment = tex;
      if (G.photoCoat && G.photoCoat.material) { G.photoCoat.material.envMap = tex; G.photoCoat.material.needsUpdate = true; }
      // console.log('[TedEnv] rebuilt env', {amb, key, back, elev, az});
    }catch(e){ console.warn('[TedEnv] refresh error', e); }
  };

  
function hookAz(){
  const el  = document.getElementById('keyAz');
  const elN = document.getElementById('keyAzN');
  if (!el || !elN) return;
  const syncToSlider = ()=>{ el.value = String(elN.value); el.dispatchEvent(new Event('input', {bubbles:true})); };
  const syncToNumber = ()=>{ elN.value = String(el.value); };
  el.addEventListener('input', ()=>{ syncToNumber(); if (window.G && G.TedEnv) G.TedEnv.refreshFromUI(); });
  elN.addEventListener('input', syncToSlider);
  // initialize
  syncToNumber();
}

  document.addEventListener('DOMContentLoaded', hookAz);
  setTimeout(hookAz, 300);
  setInterval(hookAz, 1500);
})();

</script>
<script type="module">
(function(){
  if (window.__PLANE_STRAFE_V11__) return;
  window.__PLANE_STRAFE_V11__ = true;
  let WORLD_UP;
  let raycaster;
  let planeInfo=null, planePanActive=false, panLastP=null, panLastT=0;
  let planeVel, lastMoveTime=0, recentSpeed=0;
  const SPEED_ALPHA=0.25, IDLE_MS=80, FLICK_VEL=0.00025, RELEASE_GUARD_MS=300;
  let releaseGuardUntil=0, prevControlsEnabled, prevEnableRotate, prevEnableDamping, prevAutoRotate;
  let lockedNormalDist=null, renderPatched=false;

  function tryGetPhotoMesh(){
    const c=[window.photoMesh, window.imagePlane, window.photoPlane, window.mainPlane,
      (window.scene&&scene.getObjectByName&&scene.getObjectByName('photo')),
      (window.scene&&scene.getObjectByName&&scene.getObjectByName('imagePlane'))];
    return c.find(Boolean)||null;
  }
  function rebuildPlaneInfo(){
    const m=tryGetPhotoMesh();
    if(m){
      m.updateMatrixWorld(true);
      const origin=new THREE.Vector3().setFromMatrixPosition(m.matrixWorld);
      const c0=new THREE.Vector3().setFromMatrixColumn(m.matrixWorld,0);
      const c1=new THREE.Vector3().setFromMatrixColumn(m.matrixWorld,1);
      const right=c0.clone().normalize();
      const vProj=c1.clone().sub(right.clone().multiplyScalar(c1.dot(right)));
      const up=vProj.lengthSq()>1e-12? vProj.normalize(): new THREE.Vector3(0,1,0);
      const normal=new THREE.Vector3().crossVectors(right,up).normalize();
      const plane=new THREE.Plane().setFromNormalAndCoplanarPoint(normal,origin);
      planeInfo={origin,uAxis:right,vAxis:up,normal,plane};
    }else{
      const origin=new THREE.Vector3(0,0,0), right=new THREE.Vector3(1,0,0), up=new THREE.Vector3(0,1,0), normal=new THREE.Vector3(0,0,1);
      const plane=new THREE.Plane().setFromNormalAndCoplanarPoint(normal,origin);
      planeInfo={origin,uAxis:right,vAxis:up,normal,plane};
    }
  }
  function getCanvas(){ return (renderer&&renderer.domElement)?renderer.domElement:null; }
  function getFocusRef(){
    const f=(typeof focus!=='undefined'&&focus&&focus.isVector3)?focus:null;
    if(f) return f;
    if(controls&&controls.target&&controls.target.isVector3) return controls.target;
    const tmp=new THREE.Vector3(0,0,0); window.__planePanFallbackFocus=tmp; return tmp;
  }
  function ndcToPlanePoint(nx,ny){
    if(!planeInfo) rebuildPlaneInfo();
    raycaster.setFromCamera({x:nx,y:ny},camera);
    const p=new THREE.Vector3(); raycaster.ray.intersectPlane(planeInfo.plane,p); return p;
  }
  function clampFocusToPhotoBounds(f,aspect){
    if(!planeInfo) rebuildPlaneInfo();
    const rel=f.clone().sub(planeInfo.origin);
    const u=rel.dot(planeInfo.uAxis), v=rel.dot(planeInfo.vAxis);
    const halfW=0.5, halfH=0.5/Math.max(1e-9,aspect||1);
    const uC=THREE.MathUtils.clamp(u,-halfW,halfW), vC=THREE.MathUtils.clamp(v,-halfH,halfH);
    return planeInfo.origin.clone().addScaledVector(planeInfo.uAxis,uC).addScaledVector(planeInfo.vAxis,vC);
  }
  function getAspect(){ return (typeof window.photoAspect==='number'&&window.photoAspect>0)?window.photoAspect:1.0; }
  function makeWorldUpBasis(){
  // Plane-aligned orthonormal basis to keep camera perfectly perpendicular to the photo plane
  const right = planeInfo.uAxis.clone().normalize();
  const up    = planeInfo.vAxis.clone().normalize();
  const forward = planeInfo.normal.clone().negate().normalize();
  const mat = new THREE.Matrix4().makeBasis(right, up, forward).invert();
  const q = new THREE.Quaternion().setFromRotationMatrix(mat);
  return {right, up, forward, mat, q};
};
  function enforcePerpendicular(focusRef){
  if (!planeInfo) rebuildPlaneInfo();
  if (lockedNormalDist === null){
    const camToFocus = camera.position.clone().sub(focusRef);
    lockedNormalDist = camToFocus.dot(planeInfo.normal);
  }
  camera.position.copy(focusRef).addScaledVector(planeInfo.normal, lockedNormalDist);
  const right = planeInfo.uAxis.clone().normalize();
  const up    = planeInfo.vAxis.clone().normalize();
  const fwd   = planeInfo.normal.clone().negate().normalize();
  const mat   = new THREE.Matrix4().makeBasis(right, up, fwd).invert();
  const q     = new THREE.Quaternion().setFromRotationMatrix(mat);
  camera.quaternion.copy(q);
  camera.up.copy(up);
  try{ if (pivot){ pivot.up.copy(up); } }catch(_){ }
  camera.updateMatrixWorld(true);
}
  function patchRendererRender(){
    if(!renderer||renderPatched) return;
    if(!renderer.__origRender){
      renderer.__origRender=renderer.render;
      renderer.render=function(sceneArg,cameraArg){
        const now=performance.now();
        if((window.__PLANE_STRAFE_ACTIVE__||now<releaseGuardUntil)&&planeInfo){
          const f=getFocusRef(); enforcePerpendicular(f);
          if(controls&&controls.target) controls.target.copy(f);
        }
        return renderer.__origRender.call(this,sceneArg,cameraArg);
      };
      renderPatched=true;
    }
  }
  function unpatchRendererRender(){
    if(renderer&&renderer.__origRender){ renderer.render=renderer.__origRender; delete renderer.__origRender; }
    renderPatched=false;
  }
  function beginPlanePan(clientX,clientY){
	try{ __resetPanVelocity?.(); }catch(_){}
    const el=getCanvas(); if(!el) return;
    const rect=el.getBoundingClientRect();
    const nx=(clientX-rect.left)/rect.width*2-1, ny=-(clientY-rect.top)/rect.height*2+1;
    try{ scene.attach(camera); }catch(_){}
    panLastP=ndcToPlanePoint(nx,ny); panLastT=performance.now();
    planeVel.set(0,0,0); lastMoveTime=panLastT; recentSpeed=0; lockedNormalDist=null; releaseGuardUntil=0;
    if(controls){ prevControlsEnabled=controls.enabled;
      prevEnableRotate=('enableRotate'in controls)?controls.enableRotate:undefined;
      prevEnableDamping=('enableDamping'in controls)?controls.enableDamping:undefined;
      prevAutoRotate=('autoRotate'in controls)?controls.autoRotate:undefined;
      controls.enabled=false; if('enableRotate'in controls) controls.enableRotate=false;
      if('enableDamping'in controls) controls.enableDamping=false;
      if('autoRotate'in controls) controls.autoRotate=false;
    }
    try{ if(typeof __vx!=='undefined') __vx=0; }catch(_){}
    try{ if(typeof __vy!=='undefined') __vy=0; }catch(_){}
    try{ if(typeof __vr!=='undefined') __vr=0; }catch(_){}
    window.__PLANE_STRAFE_ACTIVE__=true; patchRendererRender();
  }
  function movePlanePan(clientX,clientY){
    const el=getCanvas(); if(!el) return;
    const rect=el.getBoundingClientRect();
    const nx=(clientX-rect.left)/rect.width*2-1, ny=-(clientY-rect.top)/rect.height*2+1;
    const now=performance.now();
    const pNow=ndcToPlanePoint(nx,ny);
    if(!panLastP){ panLastP=pNow.clone(); panLastT=now; return; }
    const dt=Math.max(1,now-panLastT);
    const delta=pNow.clone().sub(panLastP);
    planeVel.copy(delta).divideScalar(dt); lastMoveTime=now;
    recentSpeed=SPEED_ALPHA*planeVel.length()+(1-SPEED_ALPHA)*recentSpeed;
    const f=getFocusRef(); const newF=clampFocusToPhotoBounds(f.clone().add(delta),getAspect());
    f.copy(newF); enforcePerpendicular(f);
    panLastP.copy(pNow); panLastT=now;
  }
  let inertiaRAF=0;
  function startPlanePanInertia(){
    cancelAnimationFrame(inertiaRAF);
    const damping=0.92, stopEps2=1e-6; let last=performance.now();
    function step(t){
      const dt=t-last; last=t;
      const f=getFocusRef(); const delta=planeVel.clone().multiplyScalar(dt);
      const newF=clampFocusToPhotoBounds(f.clone().add(delta),getAspect());
      f.copy(newF); enforcePerpendicular(f); planeVel.multiplyScalar(damping);
      if(planeVel.lengthSq()<stopEps2){
        window.__PLANE_STRAFE_ACTIVE__=false;
releaseGuardUntil=performance.now()+RELEASE_GUARD_MS;
try{ if (typeof pivot!=='undefined' && pivot){ const right=planeInfo.uAxis.clone().normalize(); const up=planeInfo.vAxis.clone().normalize(); const fwd=planeInfo.normal.clone().negate().normalize(); const mat=new THREE.Matrix4().makeBasis(right,up,fwd).invert(); const qBasis=new THREE.Quaternion().setFromRotationMatrix(mat); pivot.up.copy(up); pivot.quaternion.copy(qBasis); camera.quaternion.copy(qBasis); camera.up.copy(up); camera.updateMatrixWorld(true);} }catch(_){}
if(controls){ controls.enabled=false; }
restoreControlsAfterGuard();
return;
      }
      inertiaRAF=requestAnimationFrame(step);
    }
    inertiaRAF=requestAnimationFrame(step);
  }
  function finishNoInertia(){
	try{ __resetPanVelocity?.(); }catch(_){}
    const f=getFocusRef(); enforcePerpendicular(f);
    window.__PLANE_STRAFE_ACTIVE__=false; releaseGuardUntil=performance.now()+RELEASE_GUARD_MS;
    try{ if(typeof pivot!=='undefined'&&pivot){ const basis=makeWorldUpBasis(); pivot.position.copy(f); pivot.quaternion.copy(basis.q); pivot.attach(camera); camera.quaternion.copy(basis.q); camera.updateMatrixWorld(true);} }catch(_){}
    if(controls){ controls.enabled=(prevControlsEnabled!==undefined?prevControlsEnabled:true);
      if('enableRotate'in controls&&prevEnableRotate!==undefined) controls.enableRotate=prevEnableRotate;
      if('enableDamping'in controls&&prevEnableDamping!==undefined) controls.enableDamping=false;
      if('autoRotate'in controls&&prevAutoRotate!==undefined) controls.autoRotate=prevAutoRotate;
      if(controls.target) controls.target.copy(f); controls.update();
    }
  }
  function installPlanePan(){
	WORLD_UP = new THREE.Vector3(0,1,0);
	raycaster = new THREE.Raycaster();
	planeVel = new THREE.Vector3();
    const el=getCanvas(); if(!el) return;
    el.addEventListener('contextmenu', e=>{ e.preventDefault(); }, {passive:false});
    el.addEventListener('pointerdown', e=>{
      if(e.button===2){ rebuildPlaneInfo(); planePanActive=true; beginPlanePan(e.clientX,e.clientY); el.setPointerCapture(e.pointerId);
        e.preventDefault(); e.stopPropagation(); if(e.stopImmediatePropagation) e.stopImmediatePropagation(); }
    }, {capture:true, passive:false});
    el.addEventListener('pointermove', e=>{
      if(!planePanActive) return; movePlanePan(e.clientX,e.clientY);
      e.preventDefault(); e.stopPropagation(); if(e.stopImmediatePropagation) e.stopImmediatePropagation();
    }, {capture:true, passive:false});
    function endPan(e){
	  if(!planePanActive) return; planePanActive=false;
	  try{ el.releasePointerCapture(e.pointerId); }catch(_){}
	  const now = performance.now();
	
	  // If the mouse has been idle for more than 80ms, FORGET the last velocity.
	  // This is the key change that solves the "stuck" velocity problem.
	  if (now - lastMoveTime > IDLE_MS) {
	planeVel.set(0, 0, 0);
	  }
	
	  // Now, the decision is simple: if there's any velocity left, start inertia. Otherwise, stop.
	  if (planeVel.lengthSq() > 1e-6) {
	startPlanePanInertia();
	  } else {
	finishNoInertia();
	  }
	
	  e.preventDefault(); e.stopPropagation(); if(e.stopImmediatePropagation) e.stopImmediatePropagation();
	}
    el.addEventListener('pointerup', endPan, {capture:true, passive:false});
    el.addEventListener('pointercancel', endPan, {capture:true, passive:false});
    el.addEventListener('lostpointercapture', endPan, {capture:true, passive:false});
    // Block third-party mouseup inertia
    el.addEventListener('mouseup', e=>{ if(planePanActive) endPan(e); e.preventDefault(); e.stopPropagation(); if(e.stopImmediatePropagation) e.stopImmediatePropagation(); }, {capture:true, passive:false});
    window.addEventListener('blur', ()=>{ planePanActive=false; window.__PLANE_STRAFE_ACTIVE__=false; releaseGuardUntil=performance.now()+RELEASE_GUARD_MS; }, {passive:true});
  }
  let tries=0;(function wait(){ tries++; if(window.renderer&&renderer.domElement&&window.camera&&window.THREE){ installPlanePan(); patchRendererRender(); } else if(tries<100){ setTimeout(wait,50); } })();
})();


// === expose photo globals for deck (fixR) ===
(() => {
  try {
    const _export = () => {
      try {
        if (typeof photoMesh !== 'undefined') globalThis.photoMesh = photoMesh;
        if (typeof photoCoat !== 'undefined') globalThis.photoCoat = photoCoat;
        if (typeof photoTex !== 'undefined') globalThis.photoTex = photoTex;
        if (typeof photoAspect !== 'undefined') globalThis.photoAspect = photoAspect;
      } catch(_) {}
    };
    _export();
    if (typeof createOrUpdatePhotoMesh === 'function') {
      const __origCreate = createOrUpdatePhotoMesh;
      createOrUpdatePhotoMesh = function(...args){
        const out = __origCreate.apply(this, args);
        try { _export(); } catch(_){}
        return out;
      };
    }
    try {
      const single = document.getElementById('file');
      if (single) {
        ['change','input'].forEach(evt => single.addEventListener(evt, () => {
          setTimeout(_export, 0);
          setTimeout(_export, 50);
          setTimeout(_export, 150);
          setTimeout(_export, 400);
        }));
      }
    } catch(_){}
  } catch (err) {
    console.warn('fixR exporter failed', err);
  }
})();
// === end expose photo globals (fixR) ===
// --- FORCE EXPORT CONTROLS (Gold Master) ---
(function(){
  try {
    // Kill flag for aborting zoom inertia (used by wheel zoom)
    window.__wheelZoomKilled = false;

    // Bridge helper used by the deck crossfade code.
    // IMPORTANT: This version does NOT touch pivot or recouple the rig.
    // It only:
    //   1) stops wheel-zoom inertia, and
    //   2) reports the current cylindrical camera state via cylFromCamera.
    window.prepareForZoom = function() {
      // 1. KILL INERTIA
      // Stop the scroll loop instantly so it can't reset the pivot/camera while we crossfade.
      try {
        window.__wheelZoomKilled = true;
        if (typeof __wheelZoomRAF !== 'undefined' && __wheelZoomRAF) {
          cancelAnimationFrame(__wheelZoomRAF);
          __wheelZoomRAF = null;
        }
        if (typeof __wheelZoomVel !== 'undefined') {
          __wheelZoomVel = 0;
        }
      } catch (e) {}

      // 2. READ CURRENT CYLINDRICAL STATE WITHOUT MODIFYING THE RIG
      if (typeof window.cylFromCamera === 'function') {
        const c = window.cylFromCamera();
        return { phi: c.phi, r: c.r, elev: c.elev };
      }

      // Fallback: neutral, in case cylFromCamera is somehow missing.
      return { phi: 0, r: 2, elev: 0 };
    };

    // Expose a stable photo-size helper for the crossfade logic.
    window.getPhotoDimensions = function() {
      try {
        const mesh =
          (typeof photoMesh !== 'undefined' && photoMesh) ? photoMesh :
          (window.photoMesh || globalThis.photoMesh || null);

        if (mesh && mesh.material && mesh.material.map && mesh.material.map.image) {
          return {
            w: mesh.material.map.image.width,
            h: mesh.material.map.image.height
          };
        }
      } catch (e) {}
      return { w: window.photoWidth || 1, h: window.photoHeight || 1 };
    };

    console.log('[Bridge] Gold Master Ready.');
  } catch (e) {
    console.error('[Bridge] Failed:', e);
  }
})();</script>


<!-- No-inertia guard (appended) -->
<script>
(function(){
  try{
    document.addEventListener('pointerup', function(){
      try{ if (typeof __vx!=='undefined') __vx = 0; }catch(_){}
      try{ if (typeof __vy!=='undefined') __vy = 0; }catch(_){}
      try{ if (typeof __cancelInertia==='function') __cancelInertia(); }catch(_){}
    }, {capture:true});
    document.addEventListener('mouseup', function(){
      try{ if (typeof __vx!=='undefined') __vx = 0; }catch(_){}
      try{ if (typeof __vy!=='undefined') __vy = 0; }catch(_){}
      try{ if (typeof __cancelInertia==='function') __cancelInertia(); }catch(_){}
    }, {capture:true});
  }catch(_){}
})();
</script>

<script>(function(){ try{ document.title = (document.title||"") + " [KILL-LEGACY-INERTIA]"; }catch(_){}})();</script>


<!-- RMB Planar Inertia v14c (FENCED, silky): regression v0, soft edge, long glide -->
<!--  <script>window.__RMB_PLANAR_STICKY_V15__=true;</script>  -->
<!-- RMB Planar Sticky-Pan v15 (with toggle) -->
<script>
(function(){
  if (window.__RMB_PLANAR_STICKY_V15__) return;
  window.__RMB_PLANAR_STICKY_V15__ = true;

  // ===== Config =====
  var DEFAULT_DAMPING_FACTOR = 0.001;
  var STOP_EPSILON = 1e-8;
  var MAX_SECONDS = 60.0;
  var RELEASE_GUARD_MS = 800;
  var TRACE_MS = 120;
  var EDGE_SOFTNESS = 0.02;
  var CLICK_TOL_PX = 8;
  var CLICK_TOL_MS = 250;

  // ===== State =====
  var planeInfo=null, raycaster=null;
  var rmbActive=false, rmbLatched=false; // Add sticky latch state
  var lastP=null, lastT=0, vel=null, canvasRef=null;
  var rmbDownAt=0, rmbDownX=0, rmbDownY=0, rmbHasDragged=false;
  var prev = { enabled: undefined, rotate: undefined, damping: undefined, auto: undefined, rightMap: undefined };
  var inertiaRAF = 0, guardUntil = 0;
  var trace = [];

  // ===== Shortcuts =====
  function hasThree(){ try{ return !!window.THREE; }catch(_){ return false; } }
  function cam(){ try{ return window.camera || (typeof camera!=='undefined'&&camera) || null; }catch(_){ return null; } }
  function scn(){ try{ return window.scene || (typeof scene!=='undefined'&&scene) || null; }catch(_){ return null; } }
  function ctrls(){ try{ if (typeof controls!=='undefined' && controls) return controls; }catch(_){ } try{ if (window.controls) return window.controls; }catch(_){ } return null; }
  function focusRef(){
	try{ if (typeof focus!=='undefined'&&focus&&focus.isVector3) return focus; }catch(_){}
	var c = ctrls(); if (c && c.target && c.target.isVector3) return c.target;
	if (!window.__rmbPlanarFallbackFocus) window.__rmbPlanarFallbackFocus = new THREE.Vector3(0,0,0);
	return window.__rmbPlanarFallbackFocus;
  }
  function pickCanvasFromEvent(e){
	var t = e.target; if (t && t.closest){ var c=t.closest('canvas'); if (c) return c; }
	var p = (typeof e.composedPath==='function') ? e.composedPath() : (e.path||[]);
	for (var i=0;i<p.length;i++){ var n=p[i]; if (n && n.tagName && n.tagName.toLowerCase()==='canvas') return n; }
	return document.querySelector('canvas');
  }

  // ===== Plane helpers (same as before) =====
  function tryGetPhotoMesh(){
	var s=scn();
	var cands=[window.photoMesh, window.imagePlane, window.photoPlane, window.mainPlane];
	for (var i=0;i<cands.length;i++){ if (cands[i]) return cands[i]; }
	if (s && s.getObjectByName){
	  var p = s.getObjectByName('photo') || s.getObjectByName('imagePlane');
	  if (p) return p;
	}
	return null;
  }
  function rebuildPlaneInfo(){
	var THREE_ = window.THREE;
	var m=tryGetPhotoMesh();
	if(m){
	  m.updateMatrixWorld(true);
	  var origin=new THREE_.Vector3().setFromMatrixPosition(m.matrixWorld);
	  var c0=new THREE_.Vector3().setFromMatrixColumn(m.matrixWorld,0);
	  var c1=new THREE_.Vector3().setFromMatrixColumn(m.matrixWorld,1);
	  var right=c0.clone().normalize();
	  var vProj=c1.clone().sub(right.clone().multiplyScalar(c1.dot(right)));
	  var up=vProj.lengthSq()>1e-12? vProj.normalize(): new THREE_.Vector3(0,1,0);
	  var normal=new THREE_.Vector3().crossVectors(right,up).normalize();
	  var plane=new THREE_.Plane().setFromNormalAndCoplanarPoint(normal,origin);
	  planeInfo={origin:origin,uAxis:right,vAxis:up,normal:normal,plane:plane};
	}else{
	  var origin2=new THREE_.Vector3(0,0,0);
	  var right2=new THREE_.Vector3(1,0,0);
	  var up2=new THREE_.Vector3(0,1,0);
	  var normal2=new THREE_.Vector3(0,0,1);
	  var plane2=new THREE_.Plane().setFromNormalAndCoplanarPoint(normal2,origin2);
	  planeInfo={origin:origin2,uAxis:right2,vAxis:up2,normal:normal2,plane:plane2};
	}
  }
  function ndcToPlanePoint(nx,ny){
	var THREE_ = window.THREE, camera = cam();
	if (!raycaster) raycaster = new THREE_.Raycaster();
	if(!planeInfo) rebuildPlaneInfo();
	var p=new THREE_.Vector3();
	raycaster.setFromCamera({x:nx,y:ny},camera);
	raycaster.ray.intersectPlane(planeInfo.plane,p);
	return p;
  }
  function clampFocusToPhotoBounds(f,aspect){
	var THREE_ = window.THREE;
	if(!planeInfo) rebuildPlaneInfo();
	var rel=f.clone().sub(planeInfo.origin);
	var u=rel.dot(planeInfo.uAxis), v=rel.dot(planeInfo.vAxis);
	var halfW=0.5, halfH=0.5/Math.max(1e-9,aspect||1);
	u = THREE_.MathUtils.clamp(u,-halfW,halfW);
	v = THREE_.MathUtils.clamp(v,-halfH,halfH);
	return planeInfo.origin.clone()
	  .addScaledVector(planeInfo.uAxis,u)
	  .addScaledVector(planeInfo.vAxis,v);
  }
  function edgeAttenuation(nextF){
	var THREE_ = window.THREE;
	var rel = nextF.clone().sub(planeInfo.origin);
	var u = Math.abs(rel.dot(planeInfo.uAxis));
	var v = Math.abs(rel.dot(planeInfo.vAxis));
	var halfW=0.5, halfH=0.5/Math.max(1e-9,getAspect());
	var du = halfW - u, dv = halfH - v;
	var m = EDGE_SOFTNESS;
	var su = THREE_.MathUtils.clamp(du / m, 0, 1);
	var sv = THREE_.MathUtils.clamp(dv / m, 0, 1);
	su = su*su*(3-2*su); sv = sv*sv*(3-2*sv);
	return Math.min(su, sv);
  }
  function getAspect(){ return (typeof window.photoAspect==='number'&&window.photoAspect>0)?window.photoAspect:1.0; }
  function makeBasisQuat(){
	var THREE_ = window.THREE;
	var right = planeInfo.uAxis.clone().normalize();
	var up = planeInfo.vAxis.clone().normalize();
	var forward = planeInfo.normal.clone().normalize();
	var basis = new THREE_.Matrix4().makeBasis(right, up, forward);
	return new THREE_.Quaternion().setFromRotationMatrix(basis);
  }
  function enforcePerpendicular(focusRef){
	var THREE_ = window.THREE, camera = cam();
	if (!planeInfo) rebuildPlaneInfo();
	if (window.__lockedNormalDist == null){
	  var camToFocus = camera.position.clone().sub(focusRef);
	  window.__lockedNormalDist = camToFocus.dot(planeInfo.normal);
	  if (!isFinite(window.__lockedNormalDist) || Math.abs(window.__lockedNormalDist) < 1e-5){
		var euclid = camera.position.distanceTo(focusRef) || 1.0;
		var viewDir = new THREE_.Vector3(); camera.getWorldDirection(viewDir);
		var sign = (viewDir.dot(planeInfo.normal) < 0) ? 1 : -1;
		window.__lockedNormalDist = sign * euclid;
	  }
	}
	camera.position.copy(focusRef).addScaledVector(planeInfo.normal, window.__lockedNormalDist);
	if (camera.position.distanceToSquared(focusRef) < 1e-8){
	  camera.position.addScaledVector(planeInfo.normal, 1e-2);
	}
	camera.quaternion.copy(makeBasisQuat());
	camera.up.copy(planeInfo.vAxis);
	camera.updateMatrixWorld(true);
  }

  // ===== Controls fencing =====
  function fenceControls(){
	var c=ctrls(); if (!c || c.__rmbPlanarWrapped) return;
	var origUpdate = (typeof c.update==='function') ? c.update.bind(c) : null;
	c.__rmbPlanarWrapped = true;
	c.__rmbPlanarOrigUpdate = origUpdate;
	c.update = function(){
	  var now = performance.now();
	  var inGuard = now < guardUntil;
	  if (window.__PLANE_STRAFE_ACTIVE__ || inGuard){
		try{
		  if (this.sphericalDelta){ this.sphericalDelta.theta=0; this.sphericalDelta.phi=0; if ('radius' in this.sphericalDelta) this.sphericalDelta.radius=0; }
		  if (this.rotateDelta && this.rotateDelta.set) this.rotateDelta.set(0,0);
		  if (this.panOffset && this.panOffset.set) this.panOffset.set(0,0,0);
		  if ('zoomDelta' in this) this.zoomDelta=0;
		  if ('_zoomDelta' in this) this._zoomDelta=0;
		  if ('scale' in this) this.scale=1;
		}catch(_){}
		return false;
	  }
	  return origUpdate ? origUpdate() : false;
	};
  }
  function hardFlushControls(){
	var c=ctrls(); if (!c) return;
	try{
	  if (c.sphericalDelta){ c.sphericalDelta.theta=0; c.sphericalDelta.phi=0; if ('radius' in c.sphericalDelta) c.sphericalDelta.radius=0; }
	  if (c.rotateDelta && c.rotateDelta.set) c.rotateDelta.set(0,0);
	  if (c.panOffset && c.panOffset.set) c.panOffset.set(0,0,0);
	  if ('zoomDelta' in c) c.zoomDelta=0;
	  if ('_zoomDelta' in c) c._zoomDelta=0;
	  if ('scale' in c) c.scale=1;
	}catch(_){}
	try{ if (c.update) c.update(); }catch(_){}
  }

  function beginPanGesture(clientX, clientY){
	fenceControls();
	var c=ctrls();
	if (c){
	  prev.enabled = c.enabled;
	  prev.rotate = ('enableRotate' in c) ? c.enableRotate : undefined;
	  prev.damping = ('enableDamping' in c) ? c.enableDamping : undefined;
	  prev.auto = ('autoRotate' in c) ? c.autoRotate : undefined;
	  prev.rightMap = (c.mouseButtons && 'RIGHT' in c.mouseButtons) ? c.mouseButtons.RIGHT : undefined;

	  c.enabled=false;
	  if('enableRotate' in c) c.enableRotate=false;
	  if('enableDamping' in c) c.enableDamping=false;
	  if('autoRotate' in c) c.autoRotate=false;
	  try{ if (c.mouseButtons && 'RIGHT' in c.mouseButtons) c.mouseButtons.RIGHT = null; }catch(_){}
	  hardFlushControls();
	}

	rebuildPlaneInfo();
	var rect = canvasRef.getBoundingClientRect();
	var nx=(clientX-rect.left)/rect.width*2-1, ny=-(clientY-rect.top)/rect.height*2+1;
	lastP = ndcToPlanePoint(nx,ny); lastT = performance.now();
	vel = new THREE.Vector3(0,0,0);
	trace.length = 0; trace.push({p:lastP.clone(), t:lastT});
	rmbActive = true;
	window.__PLANE_STRAFE_ACTIVE__ = true;
  }

  // ===== Gesture =====
  function onDownCapture(e){
	if (e.button !== 2) return;
	if (!hasThree() || !cam()) return;
	var cv = pickCanvasFromEvent(e); if (!cv) return; canvasRef = cv;

	e.preventDefault(); e.stopPropagation(); if (e.stopImmediatePropagation) e.stopImmediatePropagation();

	rmbDownAt = performance.now();
	rmbDownX = e.clientX;
	rmbDownY = e.clientY;
	rmbHasDragged = false;

	// If already latched, this is a cancel tap candidate
	if (rmbLatched) {
	  // Don't start new gesture yet - wait to see if it's a quick tap to unlatch
	  return;
	}

	// Not latched - could be either:
	// 1. Quick tap to latch
	// 2. Drag to pan once
	// We'll decide in onMoveCapture or onUpCapture

	document.addEventListener('pointermove', onMoveCapture, {capture:true, passive:false});
	document.addEventListener('pointerup', onUpCapture, {capture:true, passive:false});
	document.addEventListener('pointercancel', onUpCapture, {capture:true, passive:false});
  }

  function onMoveCapture(e){
	// Check if we've moved enough to be considered a drag
	if (!rmbHasDragged) {
	  var moved = Math.hypot(e.clientX - rmbDownX, e.clientY - rmbDownY);
	  if (moved > CLICK_TOL_PX) {
		rmbHasDragged = true;
		// Start the pan gesture
		if (!rmbActive) {
		  beginPanGesture(rmbDownX, rmbDownY);
		}
	  } else {
		// Not enough movement yet
		return;
	  }
	}

	// Continue panning
	if (!rmbActive) return;
	var rect = canvasRef.getBoundingClientRect();
	var nx=(e.clientX-rect.left)/rect.width*2-1, ny=-(e.clientY-rect.top)/rect.height*2+1;
	var now=performance.now();
	var pNow=ndcToPlanePoint(nx,ny);
	if(!lastP){ lastP=pNow.clone(); lastT=now; return; }

	var dt=Math.max(1, now-lastT) * 0.001;
	var delta = pNow.clone().sub(lastP);

	if (!vel) vel = new THREE.Vector3(0,0,0);
	var instV = delta.clone().divideScalar(dt);
	var alpha = Math.min(0.35, Math.max(0.15, dt / 0.06));
	vel.multiplyScalar(1 - alpha).addScaledVector(instV, alpha);

	var f=focusRef();
	var newF=clampFocusToPhotoBounds(f.clone().add(delta),getAspect());
	f.copy(newF);
	enforcePerpendicular(f);

	lastP.copy(pNow); lastT=now;
	trace.push({p:pNow.clone(), t:now});
	var cutoff = now - TRACE_MS;
	while (trace.length && trace[0].t < cutoff) trace.shift();

	e.preventDefault(); e.stopPropagation(); if (e.stopImmediatePropagation) e.stopImmediatePropagation();
  }

  function estimateReleaseVelocity(){
	if (trace.length < 2) return vel ? vel.clone() : new THREE.Vector3(0,0,0);
	var newest = trace[trace.length-1];
	var targetAge = newest.t - 80;
	var ref = trace[0];
	for (var i=0;i<trace.length;i++){
	  if (trace[i].t >= targetAge){ ref = trace[i]; break; }
	}
	var dt = (newest.t - ref.t) * 0.001;
	if (dt <= 1e-3) return vel ? vel.clone() : new THREE.Vector3(0,0,0);
	var dp = newest.p.clone().sub(ref.p);
	return dp.divideScalar(dt);
  }

  function onUpCapture(e){
	var dt = performance.now() - rmbDownAt;
	var isQuickTap = !rmbHasDragged && dt < CLICK_TOL_MS;

	// Case 1: Quick tap while latched â†’ unlatch
	if (isQuickTap && rmbLatched) {
	  rmbLatched = false;
	  rmbActive = false;
	  window.__PLANE_STRAFE_ACTIVE__ = false;
	  guardUntil = performance.now() + RELEASE_GUARD_MS;
	  setTimeout(restoreControls, RELEASE_GUARD_MS);
	  vel = null; lastP = null; trace.length = 0;
	  e.preventDefault(); e.stopPropagation(); if (e.stopImmediatePropagation) e.stopImmediatePropagation();
	  document.removeEventListener('pointermove', onMoveCapture, {capture:true});
	  document.removeEventListener('pointerup', onUpCapture, {capture:true});
	  document.removeEventListener('pointercancel', onUpCapture, {capture:true});
	  return;
	}

	// Case 2: Quick tap while NOT latched â†’ latch and start panning
	if (isQuickTap && !rmbLatched) {
	  rmbLatched = true;
	  beginPanGesture(e.clientX, e.clientY);
	  e.preventDefault(); e.stopPropagation(); if (e.stopImmediatePropagation) e.stopImmediatePropagation();
	  // Stay in move/up handlers for latched mode
	  return;
	}

	// Case 3: Was dragging (not latched) â†’ end with inertia
	if (rmbHasDragged && !rmbLatched) {
	  rmbActive = false;
	  window.__PLANE_STRAFE_ACTIVE__ = false;

	  var v0 = estimateReleaseVelocity();
	  var speed = v0.length();
	  if (speed > STOP_EPSILON) startInertia(v0);
	  vel = null; lastP = null; trace.length = 0;

	  guardUntil = performance.now() + RELEASE_GUARD_MS;
	  setTimeout(restoreControls, RELEASE_GUARD_MS);

	  e.preventDefault(); e.stopPropagation(); if (e.stopImmediatePropagation) e.stopImmediatePropagation();

	  document.removeEventListener('pointermove', onMoveCapture, {capture:true});
	  document.removeEventListener('pointerup', onUpCapture, {capture:true});
	  document.removeEventListener('pointercancel', onUpCapture, {capture:true});
	}

	rmbHasDragged = false;
  }

  function restoreControls(){
	var c=ctrls(); if (!c) return;
	try{
	  if ('enabled' in c) c.enabled = (prev.enabled!==undefined?prev.enabled:true);
	  if ('enableRotate' in c && prev.rotate!==undefined) c.enableRotate = prev.rotate;
	  if ('enableDamping' in c && prev.damping!==undefined) c.enableDamping = prev.damping;
	  if ('autoRotate' in c && prev.auto!==undefined) c.autoRotate = prev.auto;
	  if (c.mouseButtons && 'RIGHT' in c.mouseButtons && prev.rightMap!==undefined) c.mouseButtons.RIGHT = prev.rightMap;
	  hardFlushControls();
	}catch(_){}
  }

  // ===== Inertia =====
  function startInertia(v0){
	cancelAnimationFrame(inertiaRAF);

	var c = ctrls();
	var df = (c && typeof c.dampingFactor==='number' && c.dampingFactor>0.001) ? c.dampingFactor : DEFAULT_DAMPING_FACTOR;
	var oneMinus = 1 - Math.max(0.001, Math.min(0.2, df));
	var lambda = -60 * Math.log(oneMinus);
	var last = performance.now();
	var elapsed = 0;
	var v = v0.clone();

	function step(t){
	  var dt = (t - last) * 0.001; if (dt <= 0){ inertiaRAF=requestAnimationFrame(step); return; }
	  last=t; elapsed += dt;

	  var f = focusRef();
	  var delta = v.clone().multiplyScalar(dt);

	  var nextF = clampFocusToPhotoBounds(f.clone().add(delta), getAspect());
	  var att = edgeAttenuation(nextF);
	  if (att < 1){
		delta.multiplyScalar(att);
		nextF = clampFocusToPhotoBounds(f.clone().add(delta), getAspect());
	  }

	  f.copy(nextF);
	  enforcePerpendicular(f);

	  v.multiplyScalar(Math.exp(-lambda*dt));

	  if (v.length() < STOP_EPSILON || elapsed > MAX_SECONDS){
		guardUntil = performance.now() + RELEASE_GUARD_MS;
		setTimeout(restoreControls, RELEASE_GUARD_MS);
		return;
	  }
	  inertiaRAF = requestAnimationFrame(step);
	}
	inertiaRAF = requestAnimationFrame(step);
  }

  document.addEventListener('pointerdown', onDownCapture, {capture:true, passive:false});
  document.addEventListener('contextmenu', function(e){ e.preventDefault(); }, {capture:true, passive:false});
  
  // Cleanup on blur
  window.addEventListener('blur', function(){
	rmbLatched = false;
	rmbActive = false;
	window.__PLANE_STRAFE_ACTIVE__ = false;
  });

  try{ document.title = (document.title||"") + " [RMB-STICKY v15]"; }catch(_){}
})();
</script>

<script type="module">
// === Deck/Crossfade Hotfix (fixAF: shader-mix + absolute event record/playback) ===
(() => {
  const gt = globalThis;
  const byId = (id) => document.getElementById(id);

  // 1) Ensure deck UI exists
  const controlsDiv = byId('controls');
  if (controlsDiv && !byId('filesMulti')) {
	const card = document.createElement('div');
	card.className = 'card';
	card.innerHTML = `<h3>1b) Image Deck</h3>
	<div class="stack">
	  <input id="filesMulti" type="file" accept="image/*" multiple style="display:none" />
	  <div class="small">Uses files selected in â€œ1) Image(s)â€.</div>
	  <label>Crossfade (ms)
		<span>
		  <input id="fadeMs" type="range" min="100" max="4000" step="50" value="900">
		  <input id="fadeMsN" type="number" min="100" max="4000" step="50" value="900">
		</span>
	  </label>
	  <div class="row" style="gap:8px;flex-wrap:wrap">
		<button id="prevImgBtn">â—€ Prev</button>
		<button id="nextImgBtn" class="primary">Next â–¶</button>
	  </div>
	  <div class="small">Shortcuts: <b>.</b> Next, <b>,</b> Prev</div>
	</div>`;
	controlsDiv.insertBefore(card, controlsDiv.children[1] || null);
  }

  function replaceNode(id){
	const el = byId(id);
	if (!el) return null;
	const nu = el.cloneNode(true);
	el.replaceWith(nu);
	return nu;
  }
  const filesEl = replaceNode('filesMulti');
  const nextBtn = replaceNode('nextImgBtn');
  const prevBtn = replaceNode('prevImgBtn');
  
  // Enable/disable next/prev when fewer than 2 images
  function updateDeckUIState(){
	const disabled = deck.length <= 1;
	try { nextBtn.disabled = disabled; } catch(_){}
	try { prevBtn.disabled = disabled; } catch(_){}
  }
const fadeMs  = byId('fadeMs');
  const fadeMsN = byId('fadeMsN');
  if (!filesEl || !nextBtn || !prevBtn) { console.log('[fixAF] deck UI not present'); return; }

  // 2) State
  const deck = [];
  
  // Expose deck and index via getters so they're always current
  Object.defineProperty(gt, 'deck', {
	get() { return deck; },
	configurable: true
  });
  
  Object.defineProperty(gt, 'deckIndex', {
	get() { return deckIndex; },
	set(val) { deckIndex = val; },  // ADD THIS LINE
	configurable: true
  });
  
    // Allow external callers (single-uploader) to set the deck
  gt.__deck_ingestFileArray = async function(files){
	const arr = Array.from(files || []).slice(0, 20); // cap at 20
	console.log(`[deck] ======================================`);
	console.log(`[deck] Starting ingestion of ${arr.length} files`);
	console.log(`[deck] ======================================`);
	deck.length = 0;
	if (!arr.length) { deckIndex = deck.length ? 0 : -1; updateDeckUIState(); return; }
	
	try {
	  console.log(`[deck] Loading entries SEQUENTIALLY to ensure independence and proper THREE.js initialization`);
	  
	  // CRITICAL: Load entries sequentially instead of Promise.all
	  const entries = [];
	  for (let i = 0; i < arr.length; i++) {
		console.log(`[deck] *** Creating entry ${i+1}/${arr.length} ***`);
		const entry = await toEntryWithSeq(arr[i], i);
		console.log(`[deck] *** Entry ${i} created ***`);
		console.log(`[deck]     Texture: ${entry.texture ? 'EXISTS' : 'NULL'}`);
		console.log(`[deck]     UUID: ${entry.texture?.uuid}`);
		
		entries.push(entry);
		
		// Check if this entry's texture matches any previous entry
		for (let j = 0; j < i; j++) {
		  if (entries[j].texture === entry.texture) {
			console.error(`[deck] ðŸš¨ BUG DETECTED! Entry ${i} has THE SAME TEXTURE OBJECT as entry ${j}!`);
			console.error(`[deck] UUID: ${entry.texture?.uuid}`);
		  }
		}
	  }
	  
	  console.log(`[deck] All ${entries.length} entries created`);
	  entries.sort((a,b)=> (a.seq ?? 0) - (b.seq ?? 0));
	  
	  console.log(`[deck] Received ${entries.length} entries from toEntryWithSeq`);
	  
	  for (const e of entries) {
		deck.push(e);
		console.log(`[deck] Pushed entry ${e.seq}:`, {
		  file: e.file?.name,
		  hasTexture: !!e.texture,
		  textureName: e.texture?.name,
		  textureUUID: e.texture?.uuid,
		  canvasId: e.texture?.userData?.sourceCanvas?.id,
		  width: e.width,
		  height: e.height
		});
	  }
	  
	  console.log(`[deck] Deck array now has ${deck.length} entries`);
	  
	  // Initialize photoMesh with first deck image
	  if (deck.length > 0 && deck[0].texture) {
		console.log(`[deck] ======================================`);
		console.log(`[deck] INITIALIZING photoMesh with first deck texture`);
		console.log(`[deck] ======================================`);
		
		// Set globals
		gt.photoTex = deck[0].texture;
		gt.photoAspect = deck[0].aspect;
		gt.photoWidth = deck[0].width;
		gt.photoHeight = deck[0].height;
		
		// Also set window globals
		window.photoTex = deck[0].texture;
		window.photoAspect = deck[0].aspect;
		window.photoWidth = deck[0].width;
		window.photoHeight = deck[0].height;
		
		console.log(`[deck] Set photoTex:`, !!gt.photoTex);
		console.log(`[deck] Set photoAspect:`, gt.photoAspect);
		console.log(`[deck] Set photoWidth:`, gt.photoWidth);
		console.log(`[deck] Set photoHeight:`, gt.photoHeight);
		console.log(`[deck] Texture UUID:`, gt.photoTex?.uuid);
		
		// Call createOrUpdatePhotoMesh
		console.log(`[deck] Looking for createOrUpdatePhotoMesh...`);
		console.log(`[deck]   gt.createOrUpdatePhotoMesh:`, typeof gt.createOrUpdatePhotoMesh);
		console.log(`[deck]   window.createOrUpdatePhotoMesh:`, typeof window.createOrUpdatePhotoMesh);
		console.log(`[deck]   globalThis.createOrUpdatePhotoMesh:`, typeof globalThis.createOrUpdatePhotoMesh);
		
		let createFn = gt.createOrUpdatePhotoMesh || window.createOrUpdatePhotoMesh || globalThis.createOrUpdatePhotoMesh;
		
		if (createFn) {
		  console.log(`[deck] Calling createOrUpdatePhotoMesh...`);
		  try {
			createFn();
			console.log(`[deck] âœ“ createOrUpdatePhotoMesh completed`);
			console.log(`[deck] photoMesh exists:`, !!gt.photoMesh);
			console.log(`[deck] window.photoMesh exists:`, !!window.photoMesh);
		  } catch(e) {
			console.error(`[deck] createOrUpdatePhotoMesh failed:`, e);
		  }
		} else {
		  console.error(`[deck] createOrUpdatePhotoMesh not found!`);
		}
		
		// Enable record button
		if (typeof gt.recordBtn !== 'undefined') {
		  gt.recordBtn.disabled = false;
		} else if (typeof recordBtn !== 'undefined') {
		  recordBtn.disabled = false;
		}
		
		console.log(`[deck] ======================================`);
		console.log(`[deck] Initialization complete`);
		console.log(`[deck] ======================================`);
	  }
	  
	} catch(err){
	  console.error('[deck] Deck load failed', err);
	}
	
	deckIndex = deck.length ? 0 : -1; 
	updateDeckUIState();
	
	console.log(`[deck] ======================================`);
	console.log(`[deck] VERIFICATION: Checking texture uniqueness`);
	console.log(`[deck] ======================================`);
	
	// Detailed verification
	if (deck.length > 1) {
	  for (let i = 0; i < Math.min(deck.length, 3); i++) {
		const entry = deck[i];
		console.log(`[deck] Entry ${i}:`, {
		  file: entry.file?.name,
		  texture: entry.texture,
		  textureName: entry.texture?.name,
		  textureUUID: entry.texture?.uuid,
		  textureImage: entry.texture?.image,
		  imageWidth: entry.texture?.image?.width,
		  imageHeight: entry.texture?.image?.height
		});
	  }
	  
	  // Check if first two are the same
	  const tex0 = deck[0].texture;
	  const tex1 = deck[1].texture;
	  
	  console.log(`[deck] Comparing deck[0] vs deck[1]:`);
	  console.log(`[deck]   Same object? ${tex0 === tex1}`);
	  console.log(`[deck]   Same UUID? ${tex0?.uuid === tex1?.uuid}`);
	  console.log(`[deck]   Same image? ${tex0?.image === tex1?.image}`);
	  console.log(`[deck]   Texture 0 UUID: ${tex0?.uuid}`);
	  console.log(`[deck]   Texture 1 UUID: ${tex1?.uuid}`);
	  
	  if (tex0 === tex1) {
		console.error('[deck] âŒ CRITICAL BUG: First two textures are THE SAME OBJECT!');
		console.error('[deck] This should never happen with the new code!');
	  } else if (tex0?.image === tex1?.image) {
		console.error('[deck] âŒ BUG: Textures are different objects but share the same image source!');
	  } else {
		console.log('[deck] âœ“ SUCCESS: Textures are unique objects with unique image sources');
	  }
	}
	
	console.log(`[deck] ======================================`);
	console.log(`[deck] Deck loading complete`);
	console.log(`[deck] ======================================`);
  };

  let deckIndex = -1;
  const sync = (a,b)=>{ if(a&&b){ a.addEventListener('input',()=> b.value=a.value); b.addEventListener('input',()=> a.value=b.value); } };
  sync(fadeMs, fadeMsN);

  
  updateDeckUIState();
  
  // Helper to create properly initialized textures that can be serialized
  function createProperTexture(source, baseMap) {
    try {
      // Determine the right texture constructor
      const TexCtor = (baseMap?.constructor?.name === 'CanvasTexture' || baseMap?.constructor?.name === 'Texture')
        ? (gt.THREE?.CanvasTexture || gt.THREE?.Texture)
        : (gt.THREE?.Texture);
      
      if (!TexCtor || !source) return null;
      
      // Create texture
      const tex = new TexCtor(source);
      
      // Set essential properties immediately after construction
      tex.colorSpace = gt.THREE.SRGBColorSpace || 'srgb';
      tex.flipY = false;
      tex.wrapS = gt.THREE.ClampToEdgeWrapping || 1001;
      tex.wrapT = gt.THREE.ClampToEdgeWrapping || 1001;
      tex.minFilter = gt.THREE.LinearMipmapLinearFilter || 1008;
      tex.magFilter = gt.THREE.LinearFilter || 1006;
      tex.generateMipmaps = true;
      
      // Set anisotropy if available
      const aniso = gt.renderer?.capabilities?.getMaxAnisotropy?.() || 
                    gt.renderer?.capabilities?.maxAnisotropy || 1;
      if (aniso > 1) tex.anisotropy = aniso;
      
      // Mark for update
      tex.needsUpdate = true;
      
      return tex;
    } catch(e) {
      console.warn('[createProperTexture] Failed:', e);
      return null;
    }
  }
  
  // Expose globally so other scripts can use it
  gt.createProperTexture = createProperTexture;
  if (typeof globalThis !== 'undefined') globalThis.createProperTexture = createProperTexture;
  if (typeof window !== 'undefined') window.createProperTexture = createProperTexture;
  
function mirrorTextureSettings(dst, baseMap){
	try{
	  if (!dst || !baseMap) return;
	  
	  // Only copy properties that actually exist and are defined in baseMap
	  if ('colorSpace' in baseMap && baseMap.colorSpace !== undefined && baseMap.colorSpace !== null) {
	    dst.colorSpace = baseMap.colorSpace;
	  }
	  if ('flipY' in baseMap && baseMap.flipY !== undefined) {
	    dst.flipY = baseMap.flipY;
	  }
	  if ('wrapS' in baseMap && baseMap.wrapS !== undefined) {
	    dst.wrapS = baseMap.wrapS;
	  }
	  if ('wrapT' in baseMap && baseMap.wrapT !== undefined) {
	    dst.wrapT = baseMap.wrapT;
	  }
	  if ('minFilter' in baseMap && baseMap.minFilter !== undefined) {
	    dst.minFilter = baseMap.minFilter;
	  }
	  if ('magFilter' in baseMap && baseMap.magFilter !== undefined) {
	    dst.magFilter = baseMap.magFilter;
	  }
	  if ('rotation' in baseMap && baseMap.rotation !== undefined) {
	    dst.rotation = baseMap.rotation;
	  }
	  if ('offset' in dst && 'offset' in baseMap && dst.offset && baseMap.offset) {
	    dst.offset.copy(baseMap.offset);
	  }
	  if ('repeat' in dst && 'repeat' in baseMap && dst.repeat && baseMap.repeat) {
	    dst.repeat.copy(baseMap.repeat);
	  }
	  if ('center' in dst && 'center' in baseMap && dst.center && baseMap.center) {
	    dst.center.copy(baseMap.center);
	  }
	  if ('anisotropy' in baseMap && baseMap.anisotropy !== undefined && baseMap.anisotropy > 0) {
	    dst.anisotropy = baseMap.anisotropy;
	  }
	  if ('needsUpdate' in dst) dst.needsUpdate = true;
	}catch(e){
	  console.warn('[mirrorTextureSettings] Error:', e);
	}
  }

  // Helper to wait for THREE.js to be available
  async function waitForTHREE(maxWait = 5000) {
	const start = Date.now();
	while (!window.THREE && !globalThis.THREE && !gt.THREE) {
	  if (Date.now() - start > maxWait) {
		throw new Error('THREE.js failed to load within timeout');
	  }
	  await new Promise(resolve => setTimeout(resolve, 50));
	}
	return window.THREE || globalThis.THREE || gt.THREE;
  }

  async function toEntryWithSeq(file, seq){
	console.log(`[deck] === Loading image ${seq}: ${file.name} ===`);
	
	// CRITICAL: Wait for THREE.js to be available
	let THREE;
	try {
	  console.log(`[deck] Waiting for THREE.js...`);
	  THREE = await waitForTHREE();
	  console.log(`[deck] THREE.js is available:`, !!THREE);
	  console.log(`[deck] THREE.REVISION:`, THREE?.REVISION);
	  console.log(`[deck] THREE.CanvasTexture exists:`, !!THREE?.CanvasTexture);
	} catch(e) {
	  console.error(`[deck] CRITICAL: THREE.js not available after waiting:`, e);
	  return { texture: null, aspect: 1, width: 0, height: 0, seq, file };
	}
	
	console.log(`[deck] Using manual texture creation for ${file.name}`);
	
	// Load image data
	let bmp;
	try {
	  console.log(`[deck] Creating ImageBitmap...`);
	  if ('createImageBitmap' in window) {
		bmp = await createImageBitmap(file);
	  } else {
		bmp = await new Promise((res,rej)=>{
		  const img = new Image();
		  img.onload = () => res(img);
		  img.onerror = rej;
		  img.src = URL.createObjectURL(file);
		});
	  }
	  console.log(`[deck] ImageBitmap created: ${bmp.width}x${bmp.height}`);
	} catch(e) {
	  console.error(`[deck] Failed to create ImageBitmap:`, e);
	  return { texture: null, aspect: 1, width: 0, height: 0, seq, file };
	}
	
	const width = bmp.width, height = bmp.height;
	const aspect = width/height;
	console.log(`[deck] Image ${seq} dimensions: ${width}x${height}, aspect: ${aspect.toFixed(2)}`);
	
	// Use fixed max size - NO dependency on any other texture
	const targetMax = 4096;
	const scale = Math.min(1, targetMax / Math.max(width, height));
	
	// Create UNIQUE canvas for this texture
	console.log(`[deck] Creating canvas...`);
	const c = document.createElement('canvas');
	c.width = (scale >= 1) ? width : Math.round(width * scale);
	c.height = (scale >= 1) ? height : Math.round(height * scale);
	c.id = `deck-canvas-${seq}-${Date.now()}`; // Unique ID for debugging
	console.log(`[deck] Canvas created: ${c.id}, ${c.width}x${c.height}`);
	
	const ctx = c.getContext('2d', {alpha:false});
	if (!ctx) {
	  console.error(`[deck] Failed to get 2d context!`);
	  return { texture: null, aspect, width, height, seq, file };
	}
	
	try { 
	  ctx.imageSmoothingEnabled = true; 
	  ctx.imageSmoothingQuality = 'high'; 
	} catch(_){}
	
	console.log(`[deck] Drawing to canvas...`);
	ctx.drawImage(bmp, 0, 0, c.width, c.height);
	console.log(`[deck] Image drawn to canvas`);
	
	// Dispose ImageBitmap
	if (typeof bmp.close === 'function') {
	  try { bmp.close(); } catch(_){}
	}
	
	// Create INDEPENDENT texture - NO baseMap reference at all
	let tex = null;
	try {
	  console.log(`[deck] Creating THREE.CanvasTexture...`);
	  console.log(`[deck] THREE available:`, !!THREE);
	  console.log(`[deck] THREE.CanvasTexture:`, THREE.CanvasTexture);
	  
	  // Create texture directly from canvas - this is our OWN texture
	  tex = new THREE.CanvasTexture(c);
	  console.log(`[deck] Texture created:`, !!tex);
	  console.log(`[deck] Texture type:`, tex?.constructor?.name);
	  
	  if (!tex) {
		console.error(`[deck] Texture is null after creation!`);
		return { texture: null, aspect, width, height, seq, file };
	  }
	  
	  // Set ALL properties explicitly - NO inheritance
	  console.log(`[deck] Setting texture properties...`);
	  tex.colorSpace = THREE.SRGBColorSpace;
	  tex.flipY = false;
	  tex.wrapS = THREE.ClampToEdgeWrapping;
	  tex.wrapT = THREE.ClampToEdgeWrapping;
	  tex.minFilter = THREE.LinearMipmapLinearFilter;
	  tex.magFilter = THREE.LinearFilter;
	  tex.generateMipmaps = true;
	  
	  // Get anisotropy
	  const renderer = gt.renderer || (typeof window !== 'undefined' && window.renderer);
	  const aniso = renderer?.capabilities?.getMaxAnisotropy?.() || 
	                renderer?.capabilities?.maxAnisotropy || 4;
	  tex.anisotropy = Math.min(aniso, 16);
	  
	  tex.needsUpdate = true;
	  
	  // Generate unique ID for this texture
	  tex.name = `deck-texture-${seq}-${file.name}-${Date.now()}`;
	  
	  console.log(`[deck] âœ“ Created INDEPENDENT texture #${seq}`);
	  console.log(`[deck]   Name: ${tex.name}`);
	  console.log(`[deck]   UUID: ${tex.uuid}`);
	  console.log(`[deck]   Canvas: ${c.id}`);
	  console.log(`[deck]   Image: ${tex.image?.id || 'no id'}`);
	  
	  // Verify texture has a UUID
	  if (!tex.uuid) {
		console.error(`[deck] WARNING: Texture has no UUID! This is abnormal.`);
	  }
	  
	} catch(e) {
	  console.error(`[deck] CRITICAL: Texture creation failed for ${file.name}:`, e);
	  console.error(`[deck] Error stack:`, e.stack);
	  return { texture: null, aspect, width, height, seq, file };
	}
	
	// Store canvas reference in texture for debugging
	tex.userData = tex.userData || {};
	tex.userData.sourceCanvas = c;
	tex.userData.sourceFile = file.name;
	tex.userData.deckIndex = seq;
	
	console.log(`[deck] === Completed loading image ${seq} ===`);
	
	return { 
	  texture: tex, 
	  aspect, 
	  width,
	  height,
	  seq, 
	  file 
	};
  }

  // 3) Shader-mix pipeline: blend nextMap into diffuseColor after map_fragment
  function ensureMixPipeline(material){
	if (!material) return null;
	if (material.userData && material.userData.__mixPatched) return material.userData.shader || null;
	material.userData = material.userData || {};
	material.onBeforeCompile = (shader) => {
	  // uniforms
	  shader.uniforms.uMix = { value: 0.0 };
	  shader.uniforms.uUseNext = { value: false };
	  shader.uniforms.nextMap = { value: null };

	  const decl = 'uniform float uMix;\n'
				 + 'uniform bool uUseNext;\n'
				 + 'uniform sampler2D nextMap;\n';
	  // convert to real newlines
	  const header = decl.replace(/\\n/g, '\n');

	  shader.fragmentShader = header + shader.fragmentShader.replace(
		'#include <map_fragment>',
		`#include <map_fragment>
		#ifdef USE_MAP
		  vec4 nextColMix = texture2D( nextMap, vMapUv );
		  if (uUseNext) {
			diffuseColor.rgb = mix( diffuseColor.rgb, nextColMix.rgb, clamp(uMix, 0.0, 1.0) );
		  }
		#endif
		`
	  );
	  material.userData.shader = shader;
	};
	material.userData.__mixPatched = true;
	material.needsUpdate = true; // trigger recompile
	return null;
  }

  function setNextTexture(material, nextTex){
	const sh = material.userData && material.userData.shader;
	if (!sh) return false;
	sh.uniforms.nextMap.value = nextTex || null;
	sh.uniforms.uUseNext.value = !!nextTex;
	return true;
  }

  
// === PATCH: Mix-first-then-rebuild crossfade for dimension changes ===
function __mixFadeThenRebuild(index, entry, dur){
  try {
    const pm = gt.photoMesh;
    const pc = gt.photoCoat;
    if (!pm || !pm.material) { console.warn('[mixFadeThenRebuild] no photoMesh'); return; }
    const coatWasVisible = (pc ? pc.visible : false);
    if (pc) pc.visible = false;

    ensureMixPipeline(pm.material);
    const nextTex = (entry && entry.texture) ? entry.texture : null;
    if (!nextTex) {
      console.warn('[mixFadeThenRebuild] nextTex missing â€” doing immediate swap + rebuild');
      try { applyTextureImmediate(pm, entry?.texture || null, pm.material.map); } catch(_){}
      deckIndex = index;
      try { updateImageDimensions(entry); } catch(_){}
      try { if (typeof createOrUpdatePhotoMesh === 'function') createOrUpdatePhotoMesh(); } catch(_){}
      if (pc && pc.material && pm.material && pm.material.map) {
        pc.material.map = pm.material.map;
        if ('needsUpdate' in pc.material.map) pc.material.map.needsUpdate = true;
        pc.material.needsUpdate = true;
      }
      if (pc) pc.visible = coatWasVisible;
      return;
    }

    if (!setNextTexture(pm.material, nextTex)) {
      return waitShaderReady(pm.material, 16,
        (sh) => __mixFadeThenRebuild(index, entry, dur),
        () => {
          console.warn('[mixFadeThenRebuild] shader not ready â€” immediate swap');
          try { applyTextureImmediate(pm, nextTex, pm.material.map); } catch(_){}
          deckIndex = index;
          try { updateImageDimensions(entry); } catch(_){}
          try { if (typeof createOrUpdatePhotoMesh === 'function') createOrUpdatePhotoMesh(); } catch(_){}
          if (pc && pc.material && pm.material && pm.material.map) {
            pc.material.map = pm.material.map;
            if ('needsUpdate' in pc.material.map) pc.material.map.needsUpdate = true;
            pc.material.needsUpdate = true;
          }
          if (pc) pc.visible = coatWasVisible;
        }
      );
    }

    const sh = pm.material.userData.shader;
    const t0 = performance.now();
    (function step(){
      const t = Math.min(1, (performance.now() - t0) / (Number.isFinite(dur) ? dur : 900));
      try { sh.uniforms.uMix.value = t; } catch(_){}
      if (t < 1) return requestAnimationFrame(step);

      try { sh.uniforms.uUseNext.value = false; } catch(_){}
      try { applyTextureImmediate(pm, nextTex, pm.material.map); } catch(_){}
      deckIndex = index;
      try { updateImageDimensions(entry); } catch(_){}
      try { if (typeof createOrUpdatePhotoMesh === 'function') createOrUpdatePhotoMesh(); } catch(_){}

      if (pc && pc.material && pm.material && pm.material.map) {
        pc.material.map = pm.material.map;
        if ('needsUpdate' in pc.material.map) pc.material.map.needsUpdate = true;
        pc.material.needsUpdate = true;
      }
      if (pc) pc.visible = coatWasVisible;
    })();
  } catch(e) {
    console.warn('[mixFadeThenRebuild] error', e);
  }
}

// ==== PATCH: Overlay group crossfade (image + frame), then swap originals ====
function __overlayCrossfadeThenSwap(index, entry, dur){
  const pm = gt.photoMesh;
  const pc = gt.photoCoat;
  if (!pm || !pm.material) { console.warn('[overlayCF] no photoMesh'); return; }

  // Build nextTex as your pipeline already does by this point (entry.texture should exist)
  const nextTex = (entry && entry.texture) ? entry.texture : null;
  if (!nextTex) { console.warn('[overlayCF] missing next texture'); return; }

  // 1) Freeze references to old originals and hide them
  const pmOld = pm, pcOld = pc;
  try { pmOld.visible = false; } catch(_){}
  try { if (pcOld) pcOld.visible = false; } catch(_){}

  // 2) Create outgoing duplicates (image + frame) that share maps (no clones) and keep background occluded
  const oldGroup = new THREE.Group();
  (function makeOldImage(){
    const Ctor = (pmOld.material && pmOld.material.constructor) ? pmOld.material.constructor : THREE.MeshBasicMaterial;
    const mat = new Ctor();
    try {
      if (pmOld.material.color && mat.color) mat.color.copy(pmOld.material.color);
      ['metalness','roughness','blending','depthTest'].forEach(k=>{ if (pmOld.material[k] !== undefined) mat[k] = pmOld.material[k]; });
      if (pmOld.material.emissive && mat.emissive) mat.emissive.copy(pmOld.material.emissive);
      ['map','emissiveMap','normalMap','envMap','clearcoatMap','clearcoatNormalMap'].forEach(k=>{ if (pmOld.material[k]) mat[k] = pmOld.material[k]; });
    } catch(_){}
    mat.side = THREE.DoubleSide;  // Render from both sides so fade is visible from any angle
    mat.transparent = true;       // Enable transparency from the start
    mat.opacity = 1.0;             // Start fully opaque
    mat.depthWrite = true;         // Write to depth buffer to occlude background
    mat.depthTest  = true;         // Test against depth buffer
    const mesh = new THREE.Mesh(pmOld.geometry, mat);
    mesh.position.copy(pmOld.position);
    mesh.quaternion.copy(pmOld.quaternion);
    mesh.scale.copy(pmOld.scale);
    oldGroup.add(mesh);
  })();
  (function makeOldFrame(){
    if (!pcOld) return;
    const Ctor = (pcOld.material && pcOld.material.constructor) ? pcOld.material.constructor : THREE.MeshPhysicalMaterial;
    const mat = new Ctor();
    try {
      if (pcOld.material.color && mat.color) mat.color.copy(pcOld.material.color);
      ['metalness','roughness','clearcoat','clearcoatRoughness','blending','depthTest'].forEach(k=>{ if (pcOld.material[k] !== undefined) mat[k] = pcOld.material[k]; });
      if (pcOld.material.emissive && mat.emissive) mat.emissive.copy(pcOld.material.emissive);
      ['map','emissiveMap','normalMap','envMap','clearcoatMap','clearcoatNormalMap'].forEach(k=>{ if (pcOld.material[k]) mat[k] = pcOld.material[k]; });
    } catch(_){}
    mat.side = THREE.DoubleSide;  // Render from both sides so fade is visible from any angle
    mat.transparent = true;       // Enable transparency from the start
    mat.opacity = 1.0;             // Start fully opaque
    mat.depthWrite = true;         // Write to depth buffer
    mat.depthTest  = true;         // Test against depth buffer
    const mesh = new THREE.Mesh(pcOld.geometry, mat);
    mesh.position.copy(pcOld.position);
    mesh.quaternion.copy(pcOld.quaternion);
    mesh.scale.copy(pcOld.scale);
    oldGroup.add(mesh);
  })();
  oldGroup.renderOrder = (pmOld.renderOrder || 0) + 5;
  gt.scene.add(oldGroup);
  console.log('[crossfade] Old group created:', oldGroup.children.length, 'children');
  oldGroup.children.forEach((c, i) => {
    console.log(`  [${i}] side=${c.material.side}, transparent=${c.material.transparent}, opacity=${c.material.opacity}`);
  });

  // 3) Build the new originals (geometry for new dimensions)
  //    We temporarily set gt.photoMesh to old to keep API stable, then rebuild.
  let pmNew, pcNew;
  try {
    updateImageDimensions(entry);
    if (typeof createOrUpdatePhotoMesh === 'function') createOrUpdatePhotoMesh();
    pmNew = gt.photoMesh;
    pcNew = gt.photoCoat;
    if (pmNew) pmNew.visible = false;
    if (pcNew) pcNew.visible = false;
  } catch(e){
    console.warn('[overlayCF] rebuild error, falling back to immediate swap', e);
    try { pmOld.material.map = nextTex; pmOld.material.needsUpdate = true; } catch(_){}
    return;
  }

  // 4) Create incoming duplicates (image + frame) reusing new maps; draw on top (no depth test) and fade them in
  const inGroup = new THREE.Group();
  (function makeNewImage(){
    const Ctor = (pmNew.material && pmNew.material.constructor) ? pmNew.material.constructor : THREE.MeshBasicMaterial;
    const mat = new Ctor();
    try {
      if (pmNew.material.color && mat.color) mat.color.copy(pmNew.material.color);
      ['metalness','roughness','blending'].forEach(k=>{ if (pmNew.material[k] !== undefined) mat[k] = pmNew.material[k]; });
      if (pmNew.material.emissive && mat.emissive) mat.emissive.copy(pmNew.material.emissive);
      ['map','emissiveMap','normalMap','envMap','clearcoatMap','clearcoatNormalMap'].forEach(k=>{ if (pmNew.material[k]) mat[k] = pmNew.material[k]; });
    } catch(_){}
    mat.side = THREE.DoubleSide;  // Render from both sides so fade is visible from any angle
    mat.transparent = true;
    mat.opacity = 0.0;
    mat.depthWrite = false;
    mat.depthTest  = false;   // always overlay
    const mesh = new THREE.Mesh(pmNew.geometry, mat);
    mesh.position.copy(pmNew.position);
    mesh.quaternion.copy(pmNew.quaternion);
    mesh.scale.copy(pmNew.scale);
    inGroup.add(mesh);
  })();
  (function makeNewFrame(){
    if (!pcNew) return;
    const Ctor = (pcNew.material && pcNew.material.constructor) ? pcNew.material.constructor : THREE.MeshPhysicalMaterial;
    const mat = new Ctor();
    try {
      if (pcNew.material.color && mat.color) mat.color.copy(pcNew.material.color);
      ['metalness','roughness','clearcoat','clearcoatRoughness','blending'].forEach(k=>{ if (pcNew.material[k] !== undefined) mat[k] = pcNew.material[k]; });
      if (pcNew.material.emissive && mat.emissive) mat.emissive.copy(pcNew.material.emissive);
      ['map','emissiveMap','normalMap','envMap','clearcoatMap','clearcoatNormalMap'].forEach(k=>{ if (pcNew.material[k]) mat[k] = pcNew.material[k]; });
    } catch(_){}
    mat.side = THREE.DoubleSide;  // Render from both sides so fade is visible from any angle
    mat.transparent = true;
    mat.opacity = 0.0;
    mat.depthWrite = false;
    mat.depthTest  = false;
    const mesh = new THREE.Mesh(pcNew.geometry, mat);
    mesh.position.copy(pcNew.position);
    mesh.quaternion.copy(pcNew.quaternion);
    mesh.scale.copy(pcNew.scale);
    inGroup.add(mesh);
  })();
  inGroup.renderOrder = oldGroup.renderOrder + 1;
  gt.scene.add(inGroup);
  console.log('[crossfade] New group created:', inGroup.children.length, 'children');
  inGroup.children.forEach((c, i) => {
    console.log(`  [${i}] side=${c.material.side}, transparent=${c.material.transparent}, opacity=${c.material.opacity}`);
  });

  // 5) Crossfade both groups
  const start = performance.now();
  const D = Number.isFinite(dur) ? dur : 900;
  (function step(){
    const t = Math.min(1, (performance.now() - start) / D);
    // Fade out old group
    for (const obj of oldGroup.children) {
      if (obj.material) { 
        obj.material.opacity = 1 - t;
        obj.material.needsUpdate = true;
      }
    }
    // Fade in new group
    for (const obj of inGroup.children) {
      if (obj.material) { 
        obj.material.opacity = t; 
        obj.material.needsUpdate = true; 
      }
    }
    // Debug logging every 10 frames
    if (Math.floor(t * 100) % 10 === 0) {
      console.log(`[crossfade] t=${t.toFixed(3)}, oldOpacity=${(1-t).toFixed(3)}, newOpacity=${t.toFixed(3)}`);
    }
    if (t < 1) return requestAnimationFrame(step);

    // 6) Commit: show new originals, remove duplicates, update deckIndex
    try { deckIndex = index; } catch(_){}
    try { if (pmNew) pmNew.visible = true; } catch(_){}
    try { if (pcNew) pcNew.visible = true; } catch(_){}
    try { gt.scene.remove(oldGroup); } catch(_){}
    try { gt.scene.remove(inGroup); } catch(_){}
    try {
      oldGroup.traverse(n => n.material && n.material.dispose && n.material.dispose());
      inGroup.traverse(n => n.material && n.material.dispose && n.material.dispose());
    } catch(_){}
  })();
}

function waitShaderReady(material, tries, onReady, onTimeout){
	let n = tries || 12;
	(function tick(){
	  const sh = material.userData && material.userData.shader;
	  if (sh) { onReady(sh); return; }
	  if (--n <= 0) { onTimeout && onTimeout(); return; }
	  requestAnimationFrame(tick);
	})();
  }

  
  function applyTextureImmediate(pm, tex, baseMapRef){
	try {
	  if (!tex) return false;
	  if (typeof mirrorTextureSettings === 'function') mirrorTextureSettings(tex, baseMapRef || pm.material.map);
	  pm.material.map = tex;
	  if ('needsUpdate' in pm.material.map) pm.material.map.needsUpdate = true;
	  if ('needsUpdate' in pm.material) pm.material.needsUpdate = true;
	  return true;
	} catch(_){ return false; }
  }

  // Helper function to update dimensions when switching images
  function updateImageDimensions(entry){
	try {
	  if (entry.width && entry.height && entry.aspect) {
		gt.photoWidth = entry.width;
		gt.photoHeight = entry.height;
		gt.photoAspect = entry.aspect;
		console.log('[deck] Updated dimensions:', {width: entry.width, height: entry.height, aspect: entry.aspect});
		
		// Update focus ranges and pan limits for the new image dimensions
		if (typeof gt.updateFocusRanges === 'function') {
		  gt.updateFocusRanges();
		} else if (typeof updateFocusRanges === 'function') {
		  updateFocusRanges();
		}
		
		// IMPORTANT: Clamp the current focus point to the new boundaries
		// This prevents issues when switching from a large photo to a smaller one
		if (typeof gt.updateFocusInputs === 'function') {
		  gt.updateFocusInputs({syncControls:true});
		} else if (typeof updateFocusInputs === 'function') {
		  updateFocusInputs({syncControls:true});
		}
		
		// Optionally update the mesh geometry to match new dimensions
		if (typeof gt.createOrUpdatePhotoMesh === 'function') {
		  gt.createOrUpdatePhotoMesh();
		} else if (typeof createOrUpdatePhotoMesh === 'function') {
		  createOrUpdatePhotoMesh();
		}
	  }
	} catch(e) {
	  console.warn('[deck] Failed to update dimensions:', e);
	}
  }

  // 4) Crossfade with Auto-Zoom and Logging
	function crossfadeTo(index, durOverride){
	  const pm = gt.photoMesh;
	  if (!pm || !pm.material?.map) { console.warn('Load a source image first.'); return; }
	  if (index === deckIndex || !deck[index]) return;
  
	  const dur = (Number.isFinite(durOverride) ? durOverride : (parseFloat((fadeMs && fadeMs.value) || (fadeMsN && fadeMsN.value) || '900') || 900));
	  const entry = deck[index];
	  
	  // --- ROBUST ZOOM LOGIC ---
	  let doZoom = false;
	  let startR = 0, targetR = 0, basePhi = 0, baseElev = 0;
	  
	  try {
		const getCyl = window.cylFromCamera || gt.cylFromCamera;
		const getDims = window.getPhotoDimensions; // Use our new helper if available
  
		// 1. Determine OLD Dimensions
		let oldW = 1, oldH = 1;
		if (typeof getDims === 'function') {
		   const d = getDims(); oldW = d.w; oldH = d.h;
		} else {
		   // Fallback
		   oldW = gt.photoWidth || 1; oldH = gt.photoHeight || 1;
		}
		const oldDim = Math.max(oldW, oldH);
  
		// 2. Determine NEW Dimensions
		// Try entry properties first, then the texture image itself
		const newW = entry.width || (entry.texture?.image?.width) || (entry.img?.width);
		const newH = entry.height || (entry.texture?.image?.height) || (entry.img?.height);
		const newDim = (newW && newH) ? Math.max(newW, newH) : 0;
  
		// 3. Calculate Zoom
		if (oldDim > 0 && newDim > 0 && typeof getCyl === 'function') {
		  const ratio = newDim / oldDim; 
		  
		  // Only zoom if difference is > 1%
		  if (Math.abs(1.0 - ratio) > 0.01) {
			const c = getCyl(); 
			startR = c.r; 
			basePhi = c.phi; 
			baseElev = c.elev;
			targetR = startR * ratio; // Proportional Distance
  
			// Clamp
			const minD = parseFloat(document.getElementById('minDist')?.value || 0.1);
			const maxD = parseFloat(document.getElementById('maxDist')?.value || 50);
			targetR = Math.max(minD, Math.min(maxD, targetR));
  
			doZoom = true;
			console.log(`[Zoom] Active! ${oldDim}px -> ${newDim}px (x${ratio.toFixed(2)}). Dist: ${startR.toFixed(2)} -> ${targetR.toFixed(2)}`);
		  } else {
			console.log(`[Zoom] Skipped. Sizes match (${oldDim} vs ${newDim})`);
		  }
		} else {
		  console.log('[Zoom] Skipped. Missing data:', { oldDim, newDim, hasCylFn: typeof getCyl==='function' });
		}
	  } catch(e) { console.warn('[Zoom] Error:', e); }
	  // -----------------------
  
	  ensureMixPipeline(pm.material);
  
	  // Build next texture
	  let nextTex = null;
	  try {
		if (entry.texture) nextTex = entry.texture;
		else if (entry.img) {
		  const baseMapRef = pm.material.map;
		  let source = entry.img;
		  if (source && typeof createImageBitmap !== 'undefined' && source.constructor?.name === 'ImageBitmap') {
			const c = document.createElement('canvas');
			c.width = source.width; c.height = source.height;
			const ctx = c.getContext('2d', {alpha:false});
			ctx.drawImage(source, 0, 0);
			source = c;
		  }
		  nextTex = createProperTexture(source, baseMapRef);
		  if (nextTex && baseMapRef) mirrorTextureSettings(nextTex, baseMapRef);
		  if (nextTex && 'needsUpdate' in nextTex) nextTex.needsUpdate = true;
		}
	  } catch(e){ console.error('[deck] Error building nextTex:', e); }
  
	  const fromIdx = deckIndex;
	  const startFade = (shader) => {
		try {
		  shader.uniforms.nextMap.value = nextTex;
		  shader.uniforms.uUseNext.value = true;
		  shader.uniforms.uMix.value = 0.0;
		} catch(_){}
  
		try { if (gt.deckEvents && gt.deckEvents.armed) gt.deckEvents.mark('to', index, dur, fromIdx); } catch(_){}
  
		const t0 = performance.now();
		function step(){
		  const now = performance.now();
		  const rawT = (now - t0) / dur;
		  const t = Math.min(1, rawT);
		  
		  try { shader.uniforms.uMix.value = t; } catch(_){}
  
		  // --- EXECUTE ZOOM ---
		  if (doZoom && t <= 1.0) {
			 const setRig = window.applyRig || gt.applyRig;
			 if (typeof setRig === 'function') {
			   // Ease-in-out
			   const ease = t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
			   const curR = startR + (targetR - startR) * ease;
			   setRig(basePhi, curR, baseElev);
			 }
		  }
		  // --------------------
  
		  if (t < 1) {
			requestAnimationFrame(step);
		  } else {
			try {
			  applyTextureImmediate(pm, nextTex, pm.material.map);
			  shader.uniforms.uUseNext.value = false; shader.uniforms.uMix.value = 0.0; if ('needsUpdate' in pm.material) pm.material.needsUpdate = true;
			} catch(_){}
			deckIndex = index;
			updateImageDimensions(entry);
			try { ensureMixPipeline(pm.material); if (pm.material?.map && 'needsUpdate' in pm.material.map) pm.material.map.needsUpdate = true; } catch(_){} 
		  }
		}
		requestAnimationFrame(step);
	  };
  
	  if (!nextTex) {
		// Fallback: Immediate swap
		let swapped = false;
		try { if (entry.texture) swapped = applyTextureImmediate(pm, entry.texture, pm.material.map); } catch(_){}
		deckIndex = index;
		updateImageDimensions(entry);
		try { ensureMixPipeline(pm.material); if (pm.material?.map && 'needsUpdate' in pm.material.map) pm.material.map.needsUpdate = true; } catch(_){}
		return;
	  }
  
	  if (!setNextTexture(pm.material, nextTex)) {
		return waitShaderReady(pm.material, 16, (sh) => startFade(sh), () => {
		   try { applyTextureImmediate(pm, nextTex, pm.material.map); } catch(_) {}
		   deckIndex = index;
		   updateImageDimensions(entry);
		   try { ensureMixPipeline(pm.material); if (pm.material?.map && 'needsUpdate' in pm.material.map) pm.material.map.needsUpdate = true; } catch(_){} 
		});
	  }
  
	  const sh = pm.material.userData.shader;
	  startFade(sh);
	}
  
  function crossfadePrev(){ if (deck.length>1) gt.__deck_crossfadeTo((deckIndex - 1 + deck.length) % deck.length); }
  function crossfadeNext(){ if (deck.length>1) gt.__deck_crossfadeTo((deckIndex + 1) % deck.length); }

  prevBtn.addEventListener('click', ()=>{ console.log('[deck] Prev clicked'); crossfadePrev(); });
  nextBtn.addEventListener('click', ()=>{ console.log('[deck] Next clicked'); crossfadeNext(); });

  document.addEventListener('keydown', (e)=>{
	const t = e.target;
	const formish = t && (t.tagName === 'INPUT' || t.tagName === 'TEXTAREA' || t.isContentEditable);
	if (formish) return;
	if (e.key === '.' || e.key === ',') e.stopImmediatePropagation();
	if (e.key === '.') { e.preventDefault(); crossfadeNext(); }
	if (e.key === ',') { e.preventDefault(); crossfadePrev(); }
  }, {capture:true});

  filesEl.addEventListener('change', async ()=>{ try { await gt.__deck_ingestFileArray(filesEl.files); } catch(err){ console.error(err); } });// --- Deck Events API (absolute targets) ---
  gt.deckEvents = gt.deckEvents || {
	armed: false,
	t0: 0,
	events: [],
	start(t0){
	  this.events = [];
	  this.t0 = (typeof t0 === 'number' ? t0 : performance.now());
	  this.armed = true;
	  console.log('[deckEvents] armed at', this.t0);
	},
	stop(){
	  this.armed = false;
	  console.log('[deckEvents] disarmed; events:', this.events.length);
	  return this.events.slice();
	},
	mark(kind, toIndex, fadeMs, fromIndex){
	  if (!this.armed) return;
	  const t = performance.now() - this.t0;
	  this.events.push({ t, kind, to: toIndex, from: fromIndex, fadeMs });
	}
  };

  gt.deckEventsPlay = function(events, opts){
	const list = (events || []).slice().sort((a,b)=> a.t - b.t);
	if (!list.length) return { stop(){} };

	// Optionally set initial image to first.from
	try {
	  const first = list[0];
	  if (Number.isInteger(first.from) && typeof gt.__deck_crossfadeTo === 'function') {
		gt.__deck_crossfadeTo(first.from, 0);
	  }
	} catch(_){}

	const clock = (opts && typeof opts.clock === 'function')
	  ? opts.clock
	  : (() => performance.now() - t0);
	let t0 = performance.now();
	let i = 0, active = true;

	function tick(){
	  if (!active) return;
	  const t = clock();
	  while (i < list.length && list[i].t <= t) {
		const e = list[i++];
		if (e.kind === 'to' && Number.isInteger(e.to)) {
		  const dur = (opts && Number.isFinite(opts.fadeMs)) ? opts.fadeMs : e.fadeMs;
		  try {
			if (typeof gt.__deck_crossfadeTo === 'function') {
			  gt.__deck_crossfadeTo(e.to, dur);
			} else {
			  crossfadeTo(e.to, dur);
			}
		  } catch(err) { console.warn('[deckEvents] play error', err); }
		}
	  }
	  if (i < list.length) requestAnimationFrame(tick);
	}
	requestAnimationFrame(tick);
	return { stop(){ active = false; } };
  };

  // Expose crossfade for playback
  gt.__deck_crossfadeTo = crossfadeTo;
  // Expose current deck index via closure-safe getter (no try/catch)
  if (!gt.__deck_getIndex) { gt.__deck_getIndex = () => deckIndex; }

  console.log('[fixAF] deck hotfix applied (shader mix; gamma-safe; absolute event capture/playback)');
})();
</script>

<script type="module">
// === Deck â†” Path Bridge (fix-dim-fade v2) ===
console.log('[DIMS] Script loading...');
(() => {
  console.log('[DIMS] IIFE starting');
  const gt = globalThis;
  
  console.log('[DIMS] Starting dimension handler');
  
  // 1) Enhance deck loader
  let deckLoadRetries = 0;
  function enhanceDeckLoader() {
	const origIngest = gt.__deck_ingestFileArray;
	if (!origIngest) {
	  if (deckLoadRetries++ < 50) {
		setTimeout(enhanceDeckLoader, 100);
		return;
	  }
	  console.warn('[DIMS] deck loader not found');
	  return;
	}
	
	const wrapped = origIngest;
	gt.__deck_ingestFileArray = async function(files) {
	  console.log('[DIMS] === DECK INGEST STARTING ===');
	  console.log('[DIMS] Files to load:', files.length);
	  
	  await wrapped.call(this, files);
	  
	  const deck = gt.deck;
	  if (!deck || !Array.isArray(deck)) {
		console.error('[DIMS] No deck array after ingest!');
		return;
	  }
	  
	  console.log('[DIMS] Deck after ingest, before dimension enhancement:', 
		deck.map((e,i) => ({
		  index: i,
		  hasTexture: !!e?.texture,
		  hasFile: !!e?.file,
		  hasWidth: !!e?.width,
		  width: e?.width,
		  height: e?.height
		}))
	  );
	  
	  for (let i = 0; i < deck.length; i++) {
		const entry = deck[i];
		if (!entry) continue;
		
		if (entry.width && entry.height) {
		  console.log(`[DIMS] Entry ${i} already has dimensions: ${entry.width}Ã—${entry.height}`);
		  continue;
		}
		
		try {
		  if (entry.texture?.image) {
			entry.width = entry.texture.image.width;
			entry.height = entry.texture.image.height;
			entry.aspect = entry.width / entry.height;
			console.log(`[DIMS] Entry ${i} got dims from texture: ${entry.width}Ã—${entry.height}`);
			continue;
		  }
		  
		  if (entry.file) {
			console.log(`[DIMS] Entry ${i} loading from file...`);
			let bmp;
			if ('createImageBitmap' in window) {
			  bmp = await createImageBitmap(entry.file);
			} else {
			  bmp = await new Promise((res, rej) => {
				const img = new Image();
				img.onload = () => res(img);
				img.onerror = rej;
				img.src = URL.createObjectURL(entry.file);
			  });
			}
			entry.width = bmp.width;
			entry.height = bmp.height;
			entry.aspect = entry.width / entry.height;
			console.log(`[DIMS] Entry ${i} loaded from file: ${entry.width}Ã—${entry.height}`);
		  }
		} catch (err) {
		  console.error(`[DIMS] Failed to get dimensions for entry ${i}:`, err);
		}
	  }
	  
	  console.log('[DIMS] === DECK INGEST COMPLETE ===');
	  console.log('[DIMS] Final deck state:', 
		deck.map((e, i) => ({
		  index: i,
		  width: e.width,
		  height: e.height,
		  aspect: e.aspect
		}))
	  );
	  
	  // Initialize globals from first entry if not set
	  if (deck[0] && !gt.photoWidth) {
		gt.photoWidth = deck[0].width;
		gt.photoHeight = deck[0].height;
		gt.photoAspect = deck[0].aspect;
		console.log('[DIMS] Initialized globals from deck[0]:', gt.photoWidth, gt.photoHeight);
	  }
	  
	  // Ensure deck[0] has the current photoTex if it's null
	  if (deck[0] && !deck[0].texture && gt.photoTex) {
		deck[0].texture = gt.photoTex;
		console.log('[DIMS] Linked current photoTex to deck[0]');
	  }
	};
	
	console.log('[DIMS] Deck loader enhanced');
  }
  
  // 2) Wrap crossfade
  let crossfadeRetries = 0;
  function enhanceCrossfade() {
	const origCrossfade = gt.__deck_crossfadeTo;
	if (!origCrossfade) {
	  if (crossfadeRetries++ < 50) {
		setTimeout(enhanceCrossfade, 100);
		return;
	  }
	  console.warn('[DIMS] crossfade not found');
	  return;
	}
	
	gt.__deck_crossfadeTo = async function(index, durOverride) {
	  console.log('[CROSSFADE] === START (Gold Master) ===');
	  
	  const deck = gt.deck || [];
	  const entry = deck[index];
	  if (!entry) return;
	
	  // --- ZOOM SETUP ---
	  let doZoom = false;
	  let startR = 0, targetR = 0, basePhi = 0, baseElev = 0;
	  
	  try {
		// 1. PREPARE RIG
		// Call our new Bridge function. It stops inertia, recouples the camera,
		// and returns the clean starting coordinates.
		if (window.prepareForZoom) {
			const c = window.prepareForZoom();
			startR = c.r;
			basePhi = c.phi;
			baseElev = c.elev;
		} else {
			// Fallback (should not happen with correct bridge)
			console.warn('[Zoom] Bridge missing, using fallback');
			if (window.cylFromCamera) { const c = window.cylFromCamera(); startR = c.r; basePhi = c.phi; baseElev = c.elev; }
		}
	
		// 2. Calculate Target
		const oldW = gt.photoWidth || 1; 
		const oldH = gt.photoHeight || 1;
		const oldDim = Math.max(oldW, oldH);
	
		let newW = entry.width;
		let newH = entry.height;
		if (!newW || !newH) {
		   if (entry.texture && entry.texture.image) { newW = entry.texture.image.width; newH = entry.texture.image.height; }
		   else if (entry.img) { newW = entry.img.width; newH = entry.img.height; }
		}
		const newDim = (newW && newH) ? Math.max(newW, newH) : 0;
	
		if (oldDim > 0 && newDim > 0 && startR > 0) {
		   const ratio = newDim / oldDim;
		   if (Math.abs(1.0 - ratio) > 0.01) {
			 targetR = startR * ratio;
			 
			 const minD = parseFloat(document.getElementById('minDist')?.value || 0.1);
			 const maxD = parseFloat(document.getElementById('maxDist')?.value || 50);
			 targetR = Math.max(minD, Math.min(maxD, targetR));
			 
			 doZoom = true;
			 console.log(`[Zoom] x${ratio.toFixed(2)} | phi:${basePhi.toFixed(3)}`);
		   }
		}
	  } catch(e) { console.warn('[Zoom] Error:', e); }
	  // ------------------
	  
	  // Load texture on-demand
	  if (!entry.texture && entry.file) {
		try {
		  const bmp = await createImageBitmap(entry.file);
		  const c = document.createElement('canvas');
		  c.width = bmp.width; c.height = bmp.height;
		  const ctx = c.getContext('2d', {alpha:false});
		  ctx.drawImage(bmp, 0, 0);
		  
		  const baseMap = gt.photoMesh?.material?.map;
		  const createProperTextureFn = gt.createProperTexture || window.createProperTexture || globalThis.createProperTexture;
		  
		  if (createProperTextureFn) entry.texture = createProperTextureFn(c, baseMap);
		  else {
			const TexCtor = (baseMap && baseMap.constructor) ? baseMap.constructor : (gt.THREE && gt.THREE.Texture);
			if (TexCtor) {
			  entry.texture = new TexCtor(c);
			  entry.texture.colorSpace = gt.THREE.SRGBColorSpace || 'srgb';
			  entry.texture.flipY = false;
			  entry.texture.needsUpdate = true;
			}
		  }
		  if (entry.texture && baseMap && typeof mirrorTextureSettings === 'function') mirrorTextureSettings(entry.texture, baseMap);
		  if (entry.texture) entry.texture.needsUpdate = true;
		} catch (err) { console.error(err); }
	  }
	  
	  if (!entry.width || !entry.height) {
		if (entry.texture?.image) {
		  entry.width = entry.texture.image.width;
		  entry.height = entry.texture.image.height;
		  entry.aspect = entry.width / entry.height;
		}
	  }
	  
	  const prevWidth = gt.photoWidth;
	  const prevHeight = gt.photoHeight;
	  const dimsChanged = (prevWidth !== entry.width) || (prevHeight !== entry.height);
	  
	  const dur = Number.isFinite(durOverride) ? durOverride : (parseFloat(document.getElementById('fadeMs')?.value || '900') || 900);
	  const pm = window.photoMesh || gt.photoMesh;
	  if (!pm) return;
	  
	  const allMeshes = [];
	  if (pm) allMeshes.push(pm);
	  const pc = window.photoCoat || gt.photoCoat;
	  if (pc) allMeshes.push(pc);
	  if (pm.parent && pm.parent.isGroup) {
		pm.parent.children.forEach(child => {
		  if (child.isMesh && child.material && !allMeshes.includes(child)) allMeshes.push(child);
		});
	  }
	  
	  const originalMaterialStates = new Map();
	  allMeshes.forEach(m => {
		if (!m) return;
		const materials = Array.isArray(m.material) ? m.material : [m.material];
		materials.forEach(mat => {
		  if (mat && !originalMaterialStates.has(mat)) {
			originalMaterialStates.set(mat, { transparent: mat.transparent, opacity: mat.opacity !== undefined ? mat.opacity : 1.0, depthWrite: mat.depthWrite });
		  }
		});
	  });
	  
	  globalThis.__crossfadeActive = true;
	  const halfDur = dur / 2;
	  const startTime1 = performance.now();
	  
	  function fadeOutStep() {
		const elapsed = performance.now() - startTime1;
		const t = Math.min(1.0, elapsed / halfDur);
		const totalT = Math.min(1.0, elapsed / dur);
	
		// --- EXECUTE ZOOM ---
		if (doZoom && totalT <= 1.0) {
			try {
				const setRig = window.applyRig || gt.applyRig;
				if (typeof setRig === 'function') {
					const zoomT = Math.min(1, elapsed / dur);
					const ease = zoomT < 0.5 ? 2 * zoomT * zoomT : -1 + (4 - 2 * zoomT) * zoomT;
					const curR = startR + (targetR - startR) * ease;
					setRig(basePhi, curR, baseElev);
				}
			} catch(_){}
		}
		// --------------------
		
		allMeshes.forEach(m => {
		  if (!m) return;
		  const materials = Array.isArray(m.material) ? m.material : [m.material];
		  materials.forEach(mat => {
			if (!mat) return;
			const orig = originalMaterialStates.get(mat);
			if (orig && orig.opacity > 0) {
			  mat.transparent = true;
			  mat.opacity = orig.opacity * (1 - t);
			  mat.needsUpdate = true;
			}
		  });
		});
		
		if (t < 1.0) {
		  requestAnimationFrame(fadeOutStep);
		} else {
		  if (entry.width && entry.height) {
			gt.photoWidth = entry.width;
			gt.photoHeight = entry.height;
			gt.photoAspect = entry.aspect || (entry.width / entry.height);
		  }
		  if (entry.texture) {
			gt.photoTex = entry.texture;
			window.photoTex = entry.texture;
		  }
		  
		  if (dimsChanged && typeof gt.createOrUpdatePhotoMesh === 'function') {
			gt.createOrUpdatePhotoMesh();
		  } else {
			try {
			  const currentPm = gt.photoMesh;
			  if (currentPm && currentPm.material && entry.texture) {
				if (typeof mirrorTextureSettings === 'function' && currentPm.material.map) mirrorTextureSettings(entry.texture, currentPm.material.map);
				currentPm.material.map = entry.texture;
				currentPm.material.needsUpdate = true;
			  }
			} catch(_){}
		  }
	
		  // RE-ASSERT RIG STATE
		  // Just in case createOrUpdatePhotoMesh touched something
		  if (doZoom && window.prepareForZoom) {
			 try {
				const setRig = window.applyRig || gt.applyRig;
				if (typeof setRig === 'function') {
					const midT = 0.5;
					const ease = midT < 0.5 ? 2 * midT * midT : -1 + (4 - 2 * midT) * midT;
					const midR = startR + (targetR - startR) * ease;
					setRig(basePhi, midR, baseElev);
				}
			 } catch(e) {}
		  }
		  
		  const newPm = window.photoMesh || gt.photoMesh;
		  const newPc = window.photoCoat || gt.photoCoat;
		  const newMeshes = [];
		  if (newPm) newMeshes.push(newPm);
		  if (newPc) newMeshes.push(newPc);
		  if (newPm && newPm.parent && newPm.parent.isGroup) {
			newPm.parent.children.forEach(child => {
			  if (child.isMesh && child.material && !newMeshes.includes(child)) newMeshes.push(child);
			});
		  }
		  
		  const newMaterialStates = new Map();
		  newMeshes.forEach(m => {
			if (!m) return;
			const materials = Array.isArray(m.material) ? m.material : [m.material];
			materials.forEach(mat => {
			  if (mat && !newMaterialStates.has(mat)) {
				newMaterialStates.set(mat, { transparent: mat.transparent, opacity: mat.opacity !== undefined ? mat.opacity : 1.0, depthWrite: mat.depthWrite });
			  }
			});
		  });
		  
		  newMeshes.forEach(m => {
			if (!m) return;
			const materials = Array.isArray(m.material) ? m.material : [m.material];
			materials.forEach(mat => {
			  if (!mat) return;
			  const orig = newMaterialStates.get(mat);
			  if (orig && orig.opacity > 0) {
				mat.transparent = true;
				mat.opacity = 0.0;
				mat.needsUpdate = true;
			  }
			});
		  });
		  
		  const startTime2 = performance.now();
		  function fadeInStep() {
			const elapsed = performance.now() - startTime2;
			const t = Math.min(1.0, elapsed / halfDur);
			const totalElapsed = (performance.now() - startTime1);
	
			// --- ZOOM PART 2 ---
			if (doZoom) {
				try {
					const setRig = window.applyRig || gt.applyRig;
					if (typeof setRig === 'function') {
						const zoomT = Math.min(1, totalElapsed / dur);
						const ease = zoomT < 0.5 ? 2 * zoomT * zoomT : -1 + (4 - 2 * zoomT) * zoomT;
						const curR = startR + (targetR - startR) * ease;
						setRig(basePhi, curR, baseElev);
					}
				} catch(_){}
			}
			
			newMeshes.forEach(m => {
			  if (!m) return;
			  const materials = Array.isArray(m.material) ? m.material : [m.material];
			  materials.forEach(mat => {
				if (!mat) return;
				const orig = newMaterialStates.get(mat);
				if (orig && orig.opacity > 0) {
				  mat.opacity = orig.opacity * t;
				  mat.needsUpdate = true;
				}
			  });
			});
			
			if (t < 1.0) {
			  requestAnimationFrame(fadeInStep);
			} else {
			  newMeshes.forEach(m => {
				if (!m) return;
				const materials = Array.isArray(m.material) ? m.material : [m.material];
				materials.forEach(mat => {
				  if (!mat) return;
				  const orig = newMaterialStates.get(mat);
				  if (orig) {
					mat.transparent = orig.transparent;
					mat.opacity = orig.opacity;
					mat.needsUpdate = true;
				  }
				});
			  });
			  globalThis.__crossfadeActive = false;
			  gt.deckIndex = index;
			  try { if (typeof deckIndex !== 'undefined') deckIndex = index; } catch(_){}
			  try { if (gt.deckEvents && gt.deckEvents.armed) gt.deckEvents.mark('to', index, dur, gt.deckIndex); } catch(_){}
			}
		  }
		  requestAnimationFrame(fadeInStep);
		}
	  }
	  requestAnimationFrame(fadeOutStep);
	};
	
	console.log('[DIMS] Crossfade enhanced');
  }  // Closes enhanceCrossfade function
  
  enhanceDeckLoader();
  enhanceCrossfade();
  
  console.log('[DIMS] Dimension handler ready');
})();
</script>




<script type="module">
// === Deck â†” Path Bridge (fixAG) ===
// Auto-wires deckEvents to your app's record/preview functions and UI.
(() => {
  const gt = globalThis;

  // Safe wrappers
  function wrapIfExists(names, wrapper){
    names.forEach(name => {
      const fn = gt[name];
      if (typeof fn === 'function' && !fn.__deckWrapped){
        const w = function(...args){ return wrapper(fn, this, args, name); };
        w.__deckWrapped = true;
        gt[name] = w;
       // console.log('[fixAG] wrapped', name);
      }
    });
  }

  // Keep a reference to last recorded deck events & path
  gt.__lastDeckEvents = gt.__lastDeckEvents || null;
  gt.__lastDeckPath   = gt.__lastDeckPath   || null;

  // Hook recording start
  wrapIfExists(['startRecording','beginRecording','recordStart','startPathRecording'], (orig, self, args, name) => {
    try { if (gt.deckEvents) gt.deckEvents.start(); } catch(_) {}
    return orig.apply(self, args);
  });

  // Hook recording stop -> attach events to returned path (if any)
  wrapIfExists(['stopRecording','endRecording','recordStop','stopPathRecording'], (orig, self, args, name) => {
    const ret = orig.apply(self, args);
    let evs = [];
    try { evs = (gt.deckEvents && gt.deckEvents.stop()) || []; } catch(_) {}
    gt.__lastDeckEvents = evs.slice();

    // Attach to returned path if object-like
    if (ret && typeof ret === 'object') {
      try { ret.deckEvents = evs.slice(); gt.__lastDeckPath = ret; } catch(_) {}
    } else if (gt.currentPath && typeof gt.currentPath === 'object') {
      try { gt.currentPath.deckEvents = evs.slice(); gt.__lastDeckPath = gt.currentPath; } catch(_) {}
    } else {
      // Fallback: stash a tiny path-like holder
      gt.__lastDeckPath = { deckEvents: evs.slice() };
    }
  //  console.log('[fixAG] stopRecording attached deckEvents:', (gt.__lastDeckPath && gt.__lastDeckPath.deckEvents && gt.__lastDeckPath.deckEvents.length) || 0);
    return ret;
  });

  // Helper: choose a path-like object from args or globals
  function pickPath(args){
    for (const a of args){
      if (a && typeof a === 'object' && (Array.isArray(a.deckEvents) || a.keyframes || a.nodes || a.camera || a.timeline)) return a;
    }
    if (gt.currentPath && typeof gt.currentPath === 'object') return gt.currentPath;
    if (gt.__lastDeckPath) return gt.__lastDeckPath;
    return null;
  }

  // Hook preview/playback: after original starts, kick deckEventsPlay
  function afterPreviewKickDeck(ret, args, fname){
    const path = pickPath(args);
    const evs = (path && Array.isArray(path.deckEvents)) ? path.deckEvents : (gt.__lastDeckEvents || []);
    if (!evs || evs.length === 0) { console.log('[fixAG] no deckEvents to play'); return ret; }

    // Try to use player's clock if exposed
    let clock = null;
    try {
      if (typeof gt.getPlayheadMs === 'function') clock = () => gt.getPlayheadMs();
      else if (gt.player && typeof gt.player.getTimeMs === 'function') clock = () => gt.player.getTimeMs();
      else if (gt.timeline && typeof gt.timeline.timeMs === 'number') {
        const t0 = gt.timeline.timeMs; const tStart = performance.now();
        clock = () => (gt.timeline.timeMs - t0) || (performance.now() - tStart);
      }
    } catch(_) {}

   try { gt.deckEventsPlay(evs, clock ? { clock } : undefined); } catch(err){ console.warn('[fixAG] deckEventsPlay failed', err); }
    return ret;
  }

  wrapIfExists(['previewPath','startPreview','playPreview','startPlayback','playPath'], (orig, self, args, name) => {
    const ret = orig.apply(self, args);
    return afterPreviewKickDeck(ret, args, name);
  });

  // As a UI fallback, try to detect a "Preview" button click
  function wirePreviewButtons(){
    const candidates = Array.from(document.querySelectorAll('button, [role="button"], .button, .btn')).filter(el => {
      const t = (el.textContent || '').toLowerCase().trim();
      const id = (el.id || '').toLowerCase();
      return /preview/.test(t) || /preview/.test(id);
    });
    for (const el of candidates){
      if (el.__deckPrevWired) continue;
      el.addEventListener('click', () => afterPreviewKickDeck(null, [], 'uiPreview'));
      el.__deckPrevWired = true;
   //   console.log('[fixAG] wired preview UI button');
    }
  }
  wirePreviewButtons();
  setTimeout(wirePreviewButtons, 500);
  setTimeout(wirePreviewButtons, 1500);

 // console.log('[fixAG] Deckâ†”Path bridge active');
})();
</script>

<script type="module">
(() => {
  const gt = globalThis;
  const fe = document.getElementById('file');
  if (!fe) return;
  // Ensure multiple-selection is on even if markup was cached.
  try { fe.setAttribute('multiple','multiple'); } catch (_){}
  fe.addEventListener('change', async () => {
    const files = Array.from(fe.files || []);
    if (!files.length) return;
    if (typeof gt.__deck_ingestFileArray === 'function') {
      try { await gt.__deck_ingestFileArray(files); } catch (e) { console.warn(e); }
    }
  });
})();
</script>


<script>
// --- Robust Look & Light slider listeners ---
(function(){
  function hookLL(){
    var ids = ['amb','key','backKey','keyAng'];
    ids.forEach(function(id){
      var el = document.getElementById(id);
      if (el && !el.__llHooked){
        var fire = function(){
          try { if (typeof updateLookAndLighting === 'function') updateLookAndLighting(true); } catch(e){}
          try { if (window.TedEnv && TedEnv.refreshFromUI) TedEnv.refreshFromUI(); } catch(e){}
        };
        el.addEventListener('input', fire);
        el.addEventListener('change', fire);
        el.__llHooked = true;
      }
    });
  }
  document.addEventListener('DOMContentLoaded', hookLL);
  setTimeout(hookLL, 300);
  setInterval(hookLL, 1500);
})();
</script>

<script>
// --- Robust clearcoat applicator: ensures env + coat params are active ---
(function(){
  function applyCoatParams(){
    try{
      var pc = (window.photoCoat||null);
      if (!pc || !pc.material) return;
      function val(id, dflt){
        var el = document.getElementById(id);
        var v = el ? parseFloat(el.value) : NaN;
        return isFinite(v) ? v : dflt;
      }
      pc.material.clearcoat           = val('coat', 0.3);
      pc.material.clearcoatRoughness  = val('coatRough', 0.2);
      pc.material.envMapIntensity     = val('coatEnv', 0.3);
      pc.visible = true;
      pc.material.needsUpdate = true;
    }catch(e){ console.warn('[coat] apply params error', e); }
  }
  function ensureEnv(){
    try{
      var tex = (window.TedEnv && TedEnv.tex) ? TedEnv.tex : null;
      if (!tex && window.TedEnv && TedEnv.refreshFromUI){ TedEnv.refreshFromUI(); tex = TedEnv.tex || null; }
      var sc = window.scene || null;
      if (sc && tex && sc.environment !== tex) sc.environment = tex;
      var pc = (window.photoCoat||null);
      if (pc && pc.material && tex && pc.material.envMap !== tex){
        pc.material.envMap = tex;
        pc.material.needsUpdate = true;
       // console.log('[coat] env applied to photoCoat');
      }
      applyCoatParams();
    }catch(e){ console.warn('[coat] ensure env error', e); }
  }
  function hook(){
    ['coat','coatRough','coatEnv'].forEach(function(id){
      var el = document.getElementById(id);
      if (el && !el.__coatHook){
        var fn = function(){ try{ applyCoatParams(); ensureEnv(); }catch(e){} };
        el.addEventListener('input', fn);
        el.addEventListener('change', fn);
        el.__coatHook = true;
      }
    });
  }
  document.addEventListener('DOMContentLoaded', hook);
  setTimeout(hook, 300);
  setInterval(hook, 1200);
  // Periodic ensure for startup race conditions
  setTimeout(ensureEnv, 200);
  var ticks = 0;
  var iv = setInterval(function(){ ensureEnv(); if (++ticks>20) clearInterval(iv); }, 300);
})();
</script>




</body>
</html>

<script type="module">
// -- Quick Controls wiring & mirroring (robust) --
(() => {
  const $ = (id)=>document.getElementById(id);

  function dispatchClick(el){
    try {
      // Prefer PointerEvent so any pointer-based handlers react
      if (window.PointerEvent) {
        const ev = new PointerEvent('click', {bubbles:true, cancelable:true});
        el.dispatchEvent(ev);
      } else {
        el.click();
      }
    } catch(_) { try { el.click(); } catch(_){} }
  }

  function wireProxy(proxyId, realId){
    const proxy = $(proxyId);
    if (!proxy) return;
    proxy.addEventListener('click', () => {
      const target = $(realId);
      if (target) {
        dispatchClick(target);
      } else {
        console.warn('[quick] target not found for', proxyId, 'â†’', realId);
      }
    });
  }

  // Path Builder
  wireProxy('qcPathRecord','pathRecordBtn');
  wireProxy('qcSpeedRamp','speedRampBtn');  // Speed ramp button
  wireProxy('qcPathFinish','pathFinishBtn');
  wireProxy('qcPathClear','pathClearBtn');
  // Deck
  wireProxy('qcPrevImg','prevImgBtn');
  wireProxy('qcNextImg','nextImgBtn');
  // Record
  wireProxy('qcPreview','previewBtn');
  wireProxy('qcRecord','recordBtn');
  wireProxy('qcStop','stopBtn');

  // Mirror label/disabled and checkpoint count
  function syncText(proxyId, realId){
    const p=$(proxyId), r=$(realId);
    if (!p || !r) return;
    p.textContent = r.textContent;
    ['primary','good','warn'].forEach(cls=>{ if(r.classList.contains(cls)) p.classList.add(cls); else p.classList.remove(cls); });
    p.disabled = !!r.disabled;
    p.style.opacity = r.style.opacity || '';  // Sync opacity for speedramp disabled state
  }
  function syncCount(){
    const src = $('checkpointCountEl');
    const dst = $('qcCheckpointCount');
    if (src && dst) dst.textContent = src.textContent;
  }
  // Sync speedramp button state
  function syncSpeedRamp(){
    const srcBtn = $('speedRampBtn');
    const dstBtn = $('qcSpeedRamp');
    const srcInd = $('speedRampIndicator');
    const dstInd = $('qcSpeedRampIndicator');
    if (srcBtn && dstBtn) {
      dstBtn.style.display = srcBtn.style.display;
      dstBtn.textContent = srcBtn.textContent;
      dstBtn.style.background = srcBtn.style.background;
      dstBtn.style.borderColor = srcBtn.style.borderColor;
    }
    if (srcInd && dstInd) {
      dstInd.style.display = srcInd.style.display;
    }
  }
  function fullSync(){
    syncText('qcPathRecord','pathRecordBtn');
    syncText('qcPathFinish','pathFinishBtn');
    syncText('qcPathClear','pathClearBtn');
    syncSpeedRamp();  // Sync speedramp button
    // deck/record disabled states
    const dlen = (window.deck && Array.isArray(window.deck)) ? window.deck.length : (Array.isArray(globalThis.deck)? globalThis.deck.length : undefined);
    const disabled = (typeof dlen === 'number') ? (dlen <= 1) : false;
    ['qcPrevImg','qcNextImg'].forEach(id=>{ const el=$(id); if (el) el.disabled = disabled; });
    ['qcPreview','qcRecord','qcStop'].forEach(id=>{ const el=$(id); if (el) el.disabled = false; });
    syncCount();
  }

  const mo = new MutationObserver(fullSync);
  const observeIds = ['pathRecordBtn','pathFinishBtn','pathClearBtn','checkpointCountEl','speedRampBtn','speedRampIndicator'];
  function hook(){
    observeIds.forEach(id=>{ const el=$(id); if (el) mo.observe(el, {attributes:true, childList:true, characterData:true}); });
    fullSync();
  }
  document.addEventListener('DOMContentLoaded', hook);
  setTimeout(hook, 500);
  setInterval(fullSync, 800);

 // console.log('[quick] proxies wired');
})();

// -- Mobile Support & Touch Controls --
(() => {
  const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
  const isIOS = /iPhone|iPad|iPod/i.test(navigator.userAgent);
  
  // Mobile detection and optimization
  if (isMobile) {
    console.log('[mobile] Mobile device detected, enabling optimizations');
    
    // CRITICAL: Prevent sticky orbit from disabling controls on mobile
    window.__orbitLatched = false;
    setInterval(() => { 
	  if (window.__orbitLatched) window.__orbitLatched = false;
	  if (typeof rmbLatched !== 'undefined' && rmbLatched) rmbLatched = false;      // NEW
	  if (typeof controls !== 'undefined' && controls && controls.enabled === false) // NEW
		controls.enabled = true;                                                     // NEW
	  if (panActive && !leftDown && !rightDown) panActive = false;
	}, 100);

    
    // CRITICAL: Disable cylindrical mode on mobile (it blocks OrbitControls!)
    setTimeout(() => {
      const cylModeCheckbox = document.getElementById('cylMode');
      if (cylModeCheckbox) {
        cylModeCheckbox.checked = false;
        // Trigger change event to update controls
        cylModeCheckbox.dispatchEvent(new Event('change', { bubbles: true }));
        console.log('[mobile] Cylindrical mode disabled for touch controls');
      }
    }, 100);
    
    // Toggle controls button functionality - delayed to ensure DOM is ready
    setTimeout(() => {
      const toggleBtn = document.getElementById('toggleControlsBtn');
      const leftPanel = document.getElementById('left');
      let controlsVisible = false; // Start with controls hidden on mobile
      
      if (toggleBtn && leftPanel) {
        // Start with controls hidden
        leftPanel.classList.add('mobile-hidden');
        toggleBtn.textContent = 'â˜° Show Controls';
        
        toggleBtn.addEventListener('click', () => {
          controlsVisible = !controlsVisible;
          if (controlsVisible) {
            leftPanel.classList.remove('mobile-hidden');
            toggleBtn.textContent = 'âœ• Hide Controls';
            toggleBtn.style.background = '#ff6b6b';
          } else {
            leftPanel.classList.add('mobile-hidden');
            toggleBtn.textContent = 'â˜° Show Controls';
            toggleBtn.style.background = 'var(--accent)';
          }
          console.log('[mobile] Controls toggled:', controlsVisible);
        });
        console.log('[mobile] Toggle controls button initialized');
      } else {
        console.error('[mobile] Toggle button or left panel not found!', {toggleBtn, leftPanel});
      }
    }, 500); // Wait half second for DOM to be ready
    
    // Collapse all cards on mobile by default (except Quick Controls)
    setTimeout(() => {
      const cards = document.querySelectorAll('#controls .card.collapsible');
      cards.forEach(card => {
        if (card.id !== 'quickControlsCard') {
          card.classList.remove('open');
        }
      });
      console.log('[mobile] Cards collapsed on mobile');
    }, 500);
    
    // Hide Screen Record Mode button if direct recording is supported
    const hasMediaRecorder = 'MediaRecorder' in window && typeof window.MediaRecorder === 'function';
    if (hasMediaRecorder) {
      console.log('[mobile] MediaRecorder supported - hiding Screen Record Mode button');
      setTimeout(() => {
        const btn = document.getElementById('mobileRecordBtn');
        if (btn) {
          btn.style.display = 'none !important';
          btn.remove(); // Just remove it entirely
          console.log('[mobile] Screen Record Mode button removed (direct recording available)');
        }
      }, 2000);
    } else {
      console.log('[mobile] MediaRecorder NOT supported - Screen Record Mode button visible');
    }
    
    // Reduce effects for performance on mobile
    setTimeout(() => {
      try {
        // Reduce bloom quality
        const bloomThreshold = document.getElementById('bloomThreshold');
        const bloomStrength = document.getElementById('bloomStrength');
        if (bloomThreshold && parseFloat(bloomThreshold.value) < 0.8) {
          bloomThreshold.value = 0.85;
          document.getElementById('bloomThresholdN').value = 0.85;
        }
        if (bloomStrength && parseFloat(bloomStrength.value) > 0.4) {
          bloomStrength.value = 0.3;
          document.getElementById('bloomStrengthN').value = 0.3;
        }
        // Reduce god rays
        const grDensity = document.getElementById('grDensity');
        if (grDensity && parseFloat(grDensity.value) > 0.7) {
          grDensity.value = 0.5;
          document.getElementById('grDensityN').value = 0.5;
        }
      } catch(e) { console.warn('[mobile] Could not reduce effects', e); }
    }, 1000);
  }

  // Touch feedback visual (doesn't interfere with OrbitControls)
  function showTouchFeedback(x, y) {
    const feedback = document.createElement('div');
    feedback.className = 'touch-feedback';
    feedback.style.left = (x - 30) + 'px';
    feedback.style.top = (y - 30) + 'px';
    document.body.appendChild(feedback);
    setTimeout(() => feedback.remove(), 600);
  }

  // Add non-interfering touch feedback to canvas
  // OrbitControls handles all the actual touch interaction
  setTimeout(() => {
    const canvas = document.querySelector('canvas');
    if (!canvas) return;

    // Just show visual feedback on touch, don't prevent default
    // This lets OrbitControls handle the actual gesture
    canvas.addEventListener('touchstart', (e) => {
      const touches = e.touches;
      if (touches.length === 1) {
        showTouchFeedback(touches[0].clientX, touches[0].clientY);
      }
    }, { passive: true }); // passive: true = doesn't block OrbitControls

    console.log('[mobile] Touch controls enabled (via OrbitControls)');
  }, 2000);

  console.log('[mobile] OrbitControls native touch support active');

  // Help button functionality (keep this)
  const instructionsOverlay = document.getElementById('instructionsOverlay');
  const closeInstructions = document.getElementById('closeInstructions');
  const showMobileHelp = document.getElementById('showMobileHelp');

  // Show instructions on first mobile visit
  if (isMobile && !localStorage.getItem('seenMobileInstructions')) {
    setTimeout(() => {
      if (instructionsOverlay) instructionsOverlay.classList.add('active');
    }, 2000);
    localStorage.setItem('seenMobileInstructions', 'true');
  }

  closeInstructions?.addEventListener('click', () => {
    instructionsOverlay?.classList.remove('active');
  });

  showMobileHelp?.addEventListener('click', () => {
    instructionsOverlay?.classList.add('active');
  });

  // Screen Record Mode removed - use direct recording instead
  // All screen record functionality removed since button is gone

  // Prevent double-tap zoom on mobile
  let lastTap = 0;
  document.addEventListener('touchend', (e) => {
    const currentTime = new Date().getTime();
    const tapLength = currentTime - lastTap;
    if (tapLength < 500 && tapLength > 0) {
      e.preventDefault();
    }
    lastTap = currentTime;
  });

  // Show helpful hint on iOS
  if (isIOS) {
    setTimeout(() => {
      const hint = document.createElement('div');
      hint.style.cssText = 'position:fixed;bottom:20px;left:50%;transform:translateX(-50%);background:rgba(138,210,255,0.9);color:#000;padding:12px 20px;border-radius:20px;font-size:13px;z-index:999;text-align:center;max-width:80%;box-shadow:0 4px 12px rgba(0,0,0,0.2);';
      hint.innerHTML = 'ðŸ’¡ Tap â˜° to show controls<br><span style="font-size:11px;opacity:0.7;">Touch viewport to position camera</span>';
      document.body.appendChild(hint);
      setTimeout(() => {
        hint.style.transition = 'opacity 0.5s';
        hint.style.opacity = '0';
        setTimeout(() => hint.remove(), 500);
      }, 5000);
    }, 3000);
  }

  console.log('[mobile] Screen record mode initialized');
})();

// -- Collapsible everything-but-Quick --
(() => {
  const container = document.querySelector('#controls');
  if (!container) return;
  const cards = Array.from(container.querySelectorAll(':scope > .card')).filter(c=>c.id!=='quickControlsCard');
  cards.forEach(card => {
    if (card.dataset.collapsible==='1') return;
    card.dataset.collapsible='1';
    const h3 = card.querySelector('h3');
    if (!h3) return;
    const header = document.createElement('div');
    header.className='card-header';
    const title = document.createElement('div');
    title.textContent = h3.textContent;
    const chev = document.createElement('span');
    chev.className='chev'; chev.textContent='â–¸';
    header.appendChild(title); header.appendChild(chev);
    const body = document.createElement('div');
    body.className='card-body';
    let sib=h3.nextSibling; const mv=[]; while(sib){ const n=sib.nextSibling; mv.push(sib); sib=n; }
    mv.forEach(n=>body.appendChild(n));
    card.innerHTML=''; card.appendChild(header); card.appendChild(body);
    card.classList.add('collapsible'); card.classList.remove('open');
    header.addEventListener('click', ()=>{ const o=card.classList.toggle('open'); chev.textContent=o?'â–¾':'â–¸'; });
  });
  const qc = document.getElementById('quickControlsCard'); if (qc) qc.classList.add('open');
 // console.log('[quick] collapsibles active');
})();
// --- Touch: double-tap => run the desktop perpendicular command on mobile (desktop unaffected)
(() => {
  const isTouchCapable = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
  if (!isTouchCapable) return; // desktop: do nothing
  const el = document.getElementById('gl') || document.querySelector('canvas');
  if (!el) return;

  // Make double-tap more tolerant on mobile
  let lastUpTime = 0, lastX = 0, lastY = 0;
  const TAP_MAX_DELAY = 360;     // ms between taps
  const TAP_MAX_DIST  = 24;      // px movement allowance

  el.addEventListener('pointerup', (e) => {
    if (e.pointerType !== 'touch' || e.isPrimary === false) return;
    const now = performance.now();
    const dx = e.clientX - lastX;
    const dy = e.clientY - lastY;

    if ((now - lastUpTime) < TAP_MAX_DELAY && (dx*dx + dy*dy) < (TAP_MAX_DIST*TAP_MAX_DIST)) {
      // Doubleâ€‘tap confirmed: prefer triggering the actual perpendicular action button,
      // fallback to a synthetic dblclick if not present.
      const pb = document.getElementById('perpendicularBtn');
      if (pb) {
        try { pb.click(); e.preventDefault(); } catch(_) {}
      } else {
        const dbl = new MouseEvent('dblclick', {
          bubbles: true,
          cancelable: true,
          clientX: e.clientX,
          clientY: e.clientY,
          button: 0,
          detail: 2
        });
        el.dispatchEvent(dbl);
        try { e.preventDefault(); } catch(_) {}
      }
    }
    lastUpTime = now;
    lastX = e.clientX; lastY = e.clientY;
  }, { passive: false, capture: true });
})();</script>



